;; -----------------------------------------------------------------------------------------------------------
;; Disassembly of "Head over Heels" - Amstrad CPC
;; -----------------------------------------------------------------------------------------------------------
;; Author : Fred Limouzin (fphenix@hotmail.com)
;;
;; Tool used: mostly WinApe and Notepad++! (and a tiny bit of ManageDsk.exe in spite of the bugs!)
;; Note: This file is currently not compilable! It's mainly a text document. It shows
;; the addresses, the machine-codes and the assembly.
;;
;; -----------------------------------------------------------------------------------------------------------
;; Note: A big thanks and credit must be given to Simon Frankau (https://github.com/simon-frankau/head-over-heels)
;; who did a similar work for the ZX-Spectrum version (from which the CPC version has been ported hence
;; which is very similar)
;; -----------------------------------------------------------------------------------------------------------

Stack:
Entry:
	0100 C3 03 01       JP Reentry											; debut de HEADOVER.II
.Reentry
	0103 31 00 01       LD SP,Stack											; Stack pointer #0100 (which means the first stack byte used will be 00FF, then 00FE etc..)
	0106 CD E7 22       CALL Init_setup										; Initialization
	0109 CD 54 0B       CALL Keyboard_scanning_ending						; Reset PSG Keyboard scanning
	010C 18 0E          JR Main												; Continue at Main (011C)

;; -----------------------------------------------------------------------------------------------------------
current_Room_ID:
	010E DATAWORD 00 00														; Current room ID ; eg. Head's first room = #8A40
Do_Objects_Phase:
	0110 DATABYTE 00             											; top bit toggles every "Do_Objects" loop

Last_Direction:
	0111 DATABYTE EF
Current_Direction:
	0112 DATABYTE FF

;; -----------------------------------------------------------------------------------------------------------
.special_key_pressed:
	;; for the following 3 bytes:
	;; 		bit1 = 'currently being pressed' (if set)
	;;      bit0 = 'recently pressed' (if set)
	;;		bit2 (Swop key) will store which of Head or Heels will be
	;;          selected next time we swop; this is to have the cycle
	;;			"Heels, Both, Head, Both" when we swop with Head on
	;;          the top of Heels.
.CarryObject_Pressed:														; index 0 : Carry/Purse
	0113 DATABYTE 00
.SwopChara_Pressed:															; Swop
	0114 DATABYTE 00
.FireDonuts_Pressed:														; Fire Donut
	0115 DATABYTE 00

Frame_counter:
	0116 DATABYTE 01														; used as Character speed (or rather how much delay you add)
Saved_Dir_ptr:
	0117 DATABYTE FB 														; copy of Heels character_direction
	0118 DATABYTE FB														; copy of Head character_direction

;; -----------------------------------------------------------------------------------------------------------
;; Entry point and main loop
.Game_over:																	; branch here and continue to 'main' when game over
	0119 CD 20 30       CALL Game_over_screen
.Main:
	011C 31 00 01       LD SP,Stack											; Make sure the SP is reset
	011F CD 24 2F       CALL Main_Screen									; Draw main menu screen
	0122 30 05          JR NC,Main_continue_game							; if Carry=0 goto Main_continue_game
	0124 CD ED 22       CALL Init_new_game									; Init a new game!
	0127 18 06          JR Main_game_start									; Start the game

.Main_continue_game:														; If an old game existed (saved point fish), can continue it
	0129 CD A5 0B       CALL Play_HoH_Tune									; Play main Theme
	012C CD 4A 23       CALL Init_Continue_game								; Continue a saved (Fish) game
.Main_game_start:															; Play a fresh game
	012F CD 41 45       CALL Show_World_Crowns_screen						; show the Crowns/Worlds page
	0132 3E 40          LD A,40												; Delay Setting for the First cannon ball in the Victory room
	0134 32 28 4C       LD (delay_CannonBall),A								; Update delay_CannonBall to 40 (64)
.Enter_New_Room:															; "Entering a room" loop
	0137 AF             XOR A												; phase = 0
	0138 32 10 01       LD (Do_Objects_Phase),A								; init Do_Objects_Phase
	013B CD 70 23       CALL Do_Enter_Room									; Enter a Room
.Main_loop:																	; Game Main loop within a room
	013E CD C4 01       CALL WaitFrame_Delay								; Sync with VSYNC
	0141 CD 12 02       CALL Check_User_Input								; Check user inputs
	0144 CD 68 01       CALL Victory_Room									; Check if in Victory Room and if so, do the Victory anim
	0147 CD 2B 04       CALL Do_Objects										; Manage the objects in the link list
	014A CD D0 01       CALL Check_Pause									; Check if ESC pressed to Pause the game
	014D CD 76 02       CALL Check_Swop										; Swop key pressed?
play_a_sound:																; play a sound (if one exists)
	0150 21 AE 24       LD HL,Sound_ID										; pointer on Sound_ID
	0153 7E             LD A,(HL)											; get Sound_ID
	0154 D6 01          SUB 01												; set Carry flag if Sound_ID was = 0, else Carry is 0
	0156 36 00          LD (HL),00											; reset Sound_ID
	0158 47             LD B,A												; B = Sound_ID
	0159 D4 91 0D       CALL NC,Play_Sound									; if Carry=0 (Sound_ID not 0) then Play the Sound
	015C 18 E0          JR Main_loop										; Main game loop

;; -----------------------------------------------------------------------------------------------------------
;; Sub function of Victory_Room
;; Set Z if in Victory room, else Z is reset ("NZ" set):
RoomID_Victory:			EQU		8D30
RoomID_Head_1st:		EQU		8A40
RoomID_Heels_1st:		EQU		8940

.Sub_Check_Victory_Room:
	015E 2A 0E 01       LD HL,(current_Room_ID)								; get current_Room_ID
	0161 01 30 8D       LD BC,RoomID_Victory								; #8D30 is the Victory room ID (U=8,V=D,Z=3)
	0164 AF             XOR A												; A = 0
	0165 ED 42          SBC HL,BC											; test the difference "room_ID - victory_room_ID"
	0167 C9             RET													; If in victory room then Z=1 (NZ=0) else (ie. not in victory room) Z=0 (NZ=1)

;; -----------------------------------------------------------------------------------------------------------
;; If we are in Victory room, play the victory music, fire canon balls
;; and flash the "Freedom" text...
;; If not in Victory room then leave with Z reset.
;; Note: The room #8D3 (Victory room; which is also defined by room #8E3)
;; defines 6 Cannon Balls Objects of type "#3C" in ObjDefns:
;;    sprite = SPR_BALL, function = OBJFN_CANNONBALL (ObjFnCannonFire)
;; As long as one of these exist, the function ObjFnCannonFire will reset
;; delay_CannonBall to #60, thus preventing going to Game_over at addr #0176.
;; When all 6 Cannon Balls have been processed by Do_Objects, then the
;; delay_CannonBall will be able to go to 0 and thus jump to Game_over
.Victory_Room:
	0168 CD 5E 01       CALL Sub_Check_Victory_Room							; get Z flag : Z set : Victory room, Z reset : other room
	016B C0             RET NZ												; if not in Victory Room then RET, else:
	016C 32 14 01       LD (SwopChara_Pressed),A							; reset SwopChara_Pressed = No swopping allowed (Note: A was set to 0 at addr 0164 in Sub_Check_Victory_Room)
	016F 3D             DEC A												; A = FF
	0170 32 12 01       LD (Current_Direction),A							; update Current_Direction (FF = No movement)
	0173 21 28 4C       LD HL,delay_CannonBall								; point delay_CannonBall
	0176 35             DEC (HL)											; count down delay value before we trigger fire a cannon ball
	0177 7E             LD A,(HL)											; get (HL)=delay_CannonBall; Note that delay_CannonBall value is reset back to #60 when a CannonBall is fired (see ObjFnCannonFire)
	0178 3C             INC A												; A = prev(HL) ; if delay_CannonBall was FF (FF+1=0) then Z is set
	0179 CA 19 01       JP Z,Game_over										; if Z set, then delay_CannonBall was FF (-1) so goto Game_over (only possible when all 6 Cannon Balls in the objects link list have been processed), else:
victory_song:
	017C 06 C1          LD B,Sound_ID_Tada									; prepare Sound_Id #C1 = "Tada!" song
	017E FE 30          CP 30												; compare delay with #30 (if < #30 Carry set, if = #30 Z set)
	0180 F5             PUSH AF												; save delay in (HL)+1 (prev delay value)
	0181 CC 91 0D       CALL Z,Play_Sound	 								; Play Sound_ID is in B = #C1 "Tada!"
victory_message:
	0184 F1             POP AF												; restore prev_(HL)
	0185 E6 01          AND 01												; test bit[0] (parity) of prev_(HL), set Z if == 0 (Even)
	0187 3E C9          LD A,String_ID_Freedom								; String ID #C9 = DoubleSize+Pos(12,22)+Rainbow+"FREEDOM"
	0189 CC C2 4A       CALL Z,Print_String									; if value prev(HL) was Even (every second frame) then Print_String (since "FREEDOM" % 3 != 0, the colors will change every time!)
	018C C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Moving to a new room: Update the current UVZ room location based on
;; the value in "access_new_room_code":
;;    0 = stay same room
;;   1=Down (U-1), 2=Right (V-1), 3=Up (U+1), 4=Left (V+1)
;;   5->8 = Below (Z+1), 6->#0E = Above (Z-1)
;;   7 = teleport (new UVZ)
.Go_to_room:
	018D 21 0F 01       LD HL,current_Room_ID + 1							; point on current_Room_ID high byte : UV (010F = 010E+1)
	0190 3A 58 46       LD A,(access_new_room_code)							; get access_new_room_code
	0193 3D             DEC A												; realign values on 0 (Code 1: value 0, Code2, value 1, etc)
	0194 FE 06          CP 06												; if access_new_room_code was:
	0196 28 27          JR Z,Teleport_to_new_room							; ... #07 then Teleport_to_new_room
	0198 30 1F          JR NC,Long_move_to_new_room							; else if was > #07 (or 0) then Goto Long_move_to_new_room, else:
	019A FE 04          CP 04												; if access_new_room_code was:
	019C 38 04          JR C,move_to_nextdoor_room							; ... 1 to 4, then (normal move) goto move_to_nextdoor_room, else (5:Below or 6:Above)
	019E 87             ADD A,A												; These 2 lines convert Code 5 (Below) into value #A ...
	019F EE 02          XOR 02												; ... and (flip bit1) Code 6 into value 8
	01A1 2B             DEC HL												; for Above/Below point on current_Room_ID low byte (010E)
move_to_nextdoor_room:
	;; bit[1]=0 for 0 (Code1=Down), 1 (Code2=Right), 8 (Code6=Above)  		; C=-1 (new coord = coord - 1)
	;; bit[1]=1 for 2 (Code3=Up),   3 (Code4=Left), #A (Code5=Below)  		; C=+1 (new coord = coord + 1)
	01A2 0E 01          LD C,01												; prepare return value C=1
	01A4 CB 4F          BIT 1,A												; test bit 1
	01A6 20 02          JR NZ,got_increment									; if bit[1] = 1 then C=1, else
	01A8 0E FF          LD C,FF												; C=-1
got_increment:																; at this point we have + or - 1 in C, now mod the appropriate coordinate to do the expected move
	01AA 1F             RRA													; bit0 goes in Carry
	01AB 38 07          JR C,move_to_RL_room								; if '1' then (Right/Left) move_to_RL_room, else:
move_to_UD_BA_room:															; Modify U or Z coords
	;; A = 0 (code1 or code2), 1 (Code3 or 4), 4 (Code6) or 5 (Code5)
	;; (HL) = room ID high byte (4b U and 4b V) if normal move
	;; (HL) = room ID low byte (4b Z and 4b d/c) if Above or Below
	01AD ED 6F          RLD													; A = high nibble of (HL), (HL) = (low nibble(HL) << 4) | low nibble old A
	;; Now A = U of room ID; (HL) = 4b V + 4b if normal move
	;; Or  A = Z of room ID; (HL) = 4b dont care + 4b if Above or Below
	01AF 81             ADD A,C												; coord in A +/- 1
	01B0 ED 67          RRD													; put back new room ID value in current_Room_ID
	01B2 18 05          JR Long_move_to_new_room							; go new room

move_to_RL_room:															; Modify V coord
	01B4 ED 67          RRD													; get V in A
	01B6 81             ADD A,C												; +/- 1
	01B7 ED 6F          RLD													; put back new room ID value in current_Room_ID
.Long_move_to_new_room:														; go to new room
	01B9 31 00 01       LD SP,Stack											; update Stack pointer
	01BC C3 37 01       JP Enter_New_Room

;; -----------------------------------------------------------------------------------------------------------
;; This will look which room ID is on the other side of a Teleporter
;; and go to it by updating the current roomID and Enter_New_Room
.Teleport_to_new_room:
	01BF CD 6A 34       CALL Teleport_swap_room								; find room at the other end of the teleport
	01C2 18 F5          JR Long_move_to_new_room							; "Energy!"

;; -----------------------------------------------------------------------------------------------------------
;; Controls the frame rate (FPS) by syncing with a number of VSYNC.
;; Frame_counter is updated in the Interrupt Handler and it
;; waits that it goes to 0 and sets it back to 4.
.WaitFrame_Delay:
	01C4 3A 16 01       LD A,(Frame_counter)								; Frame_counter
	01C7 A7             AND A												; test if 0
	01C8 20 FA          JR NZ,WaitFrame_Delay								; jump WaitFrame_Delay if not 0 (Wait; note: this value is modified in the Interrupt_Handler)
	01CA 3E 04          LD A,04												; else (finished waiting) update Frame_counter to 4
	01CC 32 16 01       LD (Frame_counter),A								; Frame_counter (controls the FPS)
	01CF C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Check if 'ESC' has been pressed for pause, and if so pause the game.
;; Then wait any key and resume game.
.Check_Pause:
	01D0 CD 2F 0B       CALL Keyboard_scanning_ESC							; test ESC key pressed
	01D3 C0             RET NZ												; if not then RET, else:
	01D4 06 C0          LD B,Sound_ID_Silence								; Sound id #C0 = Silence (pause)
	01D6 CD 91 0D       CALL Play_Sound										; Quiet all sounds
	01D9 CD 36 0A       CALL Wait_anykey_released							; key debounce
	01DC 3E AC          LD A,String_ID_Paused								; String ID #AC = Paused Game message
	01DE CD C2 4A       CALL Print_String	 								; Display overlay pause message
pause_loop:
	01E1 CD 3C 0A       CALL Test_Enter_Shift_keys							; output : Carry=1 : no key pressed, else Carry=0 and C=0:Enter, C=1:Shift, C=2:other
	01E4 38 FB          JR C,pause_loop										; if no key the Wait (loop pause_loop), else (a key was pressed)
	01E6 0D             DEC C												; now C=-1:Enter, C=0:Shift, C=1:other
	01E7 CA 19 01       JP Z,Game_over										; if Z set (Shift key = Finish) then goto Game_over, else:
leave_pause:
	01EA CD 36 0A       CALL Wait_anykey_released							; key debounce
	01ED CD 92 23       CALL Update_Screen_Periph							; Update color scheme and periphery (why?)
	;; Redraw only the part over the pause message
	01F0 21 50 4C       LD HL,4C50											; X extent #4C=76; #50=80 ; H contains start, L end, in double-pixels
pause_message_draw_over_loop:
	01F3 E5             PUSH HL
	01F4 11 88 60       LD DE,6088											; Y extent #60=96; #88=136
	01F7 CD EE 1C       CALL Draw_View
	01FA E1             POP HL												; restore X extent
	01FB 7D             LD A,L
	01FC 67             LD H,A
	01FD C6 14          ADD A,14											; move next block
	01FF 6F             LD L,A												; H=L, L=L+20
	0200 FE B5          CP B5												; if L < #B5 (181) then loop (else we are off screen)
	0202 38 EF          JR C,pause_message_draw_over_loop					; pause_message_draw_over_loop, else RET
	0204 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Depending on the Sensitivity settings (Sensitivity Menu) self-modifying
;; the code to use either the Routine_High_sensitivity or the
;; Routine_Low_sensitivity. This only has an impact when pressing two keys
;; to move diagonally.
.Sub_Update_Sensitivity:													; A = sensitivity ; (self-modifying code at #0232):
	0205 21 3C 02       LD HL,Routine_High_sensitivity						; HL = addr of Routine_High_sensitivity
	0208 A7             AND A												; Update Z with selected sensitivity menu item (0 = High, 1 = Low)
	0209 28 03          JR Z,us_skip										; if High sensitivity goto 020E to use the addr of Routine_High_sensitivity
	020B 21 49 02       LD HL,Routine_Low_sensitivity						; else take addr value of Routine_Low_sensitivity
us_skip:
	020E 22 32 02       LD (smc_sens_routine+1),HL							; if High sensisivity, put addr of Routine_High_sensitivity in #0232, else if Low, put #0249 (addr of Routine_Low_sensitivity)
	0211 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This will scan the keyboard and get the user inputs
;; The value A from Get_user_inputs is:
;;		bit7:Carry, Fire, Swop, Left, Right, Down, Up, bit0: Jump (active low)
.Check_User_Input:
	0212 CD 01 0B       CALL Get_user_inputs								; get user inputs in A
	0215 CB 7F          BIT 7,A												; was key corresponding to CarryObject feature pressed?
	0217 21 13 01       LD HL,special_key_pressed							; points on CarryObject_Pressed (index 0)
	021A CD 62 02       CALL Update_key_pro_curr_idx						; update CarryObject_Pressed from the key pressed in A
	021D CB 6F          BIT 5,A												; or was it the Swop key?
	021F CD 61 02       CALL Update_key_pro_next_idx						; if needed update SwopChara_Pressed (index 1)
	0222 CB 77          BIT 6,A												; or was if the FireDonuts key?
	0224 CD 61 02       CALL Update_key_pro_next_idx						; if needed update FireDonuts_Pressed (index 2)
	0227 4F             LD C,A												; Currently bits are in order : Carry,Fire,Swop,Left,Right,Down,Up,Jump
	0228 1F             RRA													; put the "Left,Right,Down,Up" bitmap in bits [3:0]
	0229 CD 0F 44       CALL Get_dir_code_LRDU_bitmap						; validate the resulting direction from the LRUD (Left/Right/Up/Down) user input
	022C FE FF          CP FF												; check vs "no move"
	022E 28 2C          JR Z,No_Key_pressed									; if nothing pressed (C=FF) goto No_Key_pressed; will RET
	0230 1F             RRA													; get in Carry the lsb of the direction code that will indicate if we go in diagonal (if 1)
smc_sens_routine:
	0231 DA 49 02       JP C,Routine_Low_sensitivity						; If going in diagonal : do the Routine_High_sensitivity or Routine_Low_sensitivity ; will RET
	;;0232 DATAWORD 49 02													; by default : Routine_Low_sensitivity	(0249)
	0234 79             LD A,C												; (else one direction only): save key state : Carry,Fire,Swop,Left,Right,Down,Up,Jump
	0235 32 11 01       LD (Last_Direction),A								; update Last_Direction
	0238 32 12 01       LD (Current_Direction),A							; update Current_Direction
	023B C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Runs if HIGH Sensitivity is choosen in the menu (value set in smc_sens_routine)
;; If moving diagonally, set the a direction each time (the other one in the pair creating the diag)
;; Input: C has the "Carry,Fire,Swop,Left,Right,Down,Up,Jump" state (active low)
.Routine_High_sensitivity:
	023C 3A 11 01       LD A,(Last_Direction)								; get Last_Direction
	023F A9             XOR C
	0240 2F             CPL													; invert all bits of A
	0241 A9             XOR C
	0242 E6 FE          AND FE												; ignore jump
	0244 A9             XOR C												; apart from jump, we have "A XNOR C" here
	0245 32 12 01       LD (Current_Direction),A							; update Current_Direction
	0248 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Runs if LOW Sensitivity is choosen in the menu (value set in smc_sens_routine)
;; if moving diagonaly, keep the old direction (the same one in the pair creating the diag)
;; Input: C has the "Carry,Fire,Swop,Left,Right,Down,Up,Jump" state (active low)
.Routine_Low_sensitivity:
	0249 3A 11 01       LD A,(Last_Direction)								; get Last_Direction
	024C A9             XOR C
	024D E6 FE          AND FE												; ignore Jump
	024F A9             XOR C
	0250 47             LD B,A
	0251 B1             OR C
	0252 B8             CP B												; compare A OR C with A
	0253 28 03          JR Z,rls_1											; skip to rls_1 if it did not change, else:
	0255 78             LD A,B
	0256 EE FE          XOR FE												; invert old A
rls_1:
	0258 32 12 01       LD (Current_Direction),A							; update Current_Direction
	025B C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Nothing pressed, update Current_Direction with FF
;; Input: C has the "Carry,Fire,Swop,Left,Right,Down,Up,Jump" state
;;        (active low) which is therfore "FF" if it reached here.
.No_Key_pressed:
	025C 79             LD A,C												; is "FF"
	025D 32 12 01       LD (Current_Direction),A							; refresh Current_Direction
	0260 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Provide 2 functions to update the variables in special_key_pressed array:
;; CarryObject_Pressed (index 0),  SwopChara_Pressed (index 1),
;; and FireDonuts_Pressed (index 2)
;;   * Update_key_pro_next_idx will first increment the index in HL
::   * Update_key_pro_curr_idx will use the current index in HL
;; Input : Z set = key pressed; Z reset = no key pressed
;; 		a 1 in bit[1] means "key currently pressed"
;; 		a 1 in bit[0] means "key recently pressed" (not yet processed)
;; 		bit[2] is a copy of bit0 done when ???? TODO ????
.Update_key_pro_next_idx:
	0261 23             INC HL												; next index
.Update_key_pro_curr_idx:
	0262 CB 86          RES 0,(HL)											; (HL) bit[0] reset
	0264 28 03          JR Z,reg_key_feature_1								; if key pressed then jump to reg_key_feature_1, else:
	0266 CB 8E          RES 1,(HL)											; (HL) bit[1] reset
	0268 C9             RET													; no key pressed, both bits 1 and 0 are reset

reg_key_feature_1:
	0269 CB 4E          BIT 1,(HL)											; test bit[1]:
	026B C0             RET NZ												; already registered so Return (bit[0] was reset)
	026C CB CE          SET 1,(HL)											; else set ...
	026E CB C6          SET 0,(HL)											; ... both bits
	0270 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Play the #C4 "Nope" sound
.Play_Sound_NoCanDo:														; Sound played when we can't swop
	0271 06 C4          LD B,Sound_ID_Nope									; Sound ID #C4 : "Nope!" (can't swop, can't fire, can't pickup, can't drop)
	0273 C3 91 0D       JP Play_Sound										; will RET

;; -----------------------------------------------------------------------------------------------------------
;; Provides 2 functions
;;   - Check_Swop : Check if can swop, and if possible, swop
;;   - Switch_Character : swop (no checks)
;; If the swop key pressed and not yet processed, try to swap.
;; Note: It's the verb swop (and not swap) that's used in this game.
;; Note: You cannot swop if:
;;     * the Dying anim is playing
;;     * the teleport anim is running
;;     * under a doorway
;;     * the other character has no more lives
.Check_Swop		:															; Swop pressed? if so, swop!
	0276 3A 14 01       LD A,(SwopChara_Pressed)							; get SwopChara_Pressed
	0279 1F             RRA													; shift swop key state (bit0) in Carry
	027A D0             RET NC												; leave if not being pressed, else:
	027B 3A AC 24       LD A,(Saved_Objects_List_index)						; else get Saved_Objects_List_index; can't swap if under a doorway
	027E 21 59 46       LD HL,DyingAnimFrameIndex							; point on DyingAnimFrameIndex
	0281 B6             OR (HL)												; can't swap if in the process of dying!
	0282 2A 86 24       LD HL,(Teleport_up_anim_length)						; get Teleport_up_anim_length
	0285 B4             OR H
	0286 B5             OR L												; can't swap if teleporting
	0287 20 E8          JR NZ,Play_Sound_NoCanDo							; if not 0 (teleporting) then Play_Sound_NoCanDo and will RET, else:
	0289 2A 80 24       LD HL,(Characters_lives)							; else get Characters_lives
	028C BC             CP H												; character 1 has no lives: can't swop
	028D 28 E2          JR Z,Play_Sound_NoCanDo								; if Z Play_Sound_NoCanDo ; will RET
	028F BD             CP L												; character 2 has no lives: can't swop
	0290 28 DF          JR Z,Play_Sound_NoCanDo								; if Z Play_Sound_NoCanDo ; will RET
.Switch_Character:															; else can swop!
	0292 CD 6A 03       CALL Get_Saved_direction_pointer					; get Heels select state in Carry, pointer on Saved_Dir_ptr in HL, E = selected_characters and A is "selected_characters >> 1"
	0295 ED 4B AB 24    LD BC,(character_direction)							; get character_direction in C
	0299 30 01          JR NC,swc_1											; if Heels is NOT currently used so jump swc_1
	029B 71             LD (HL),C											; else Heels selected; save character_direction in Saved_Dir_ptr (Heels)
swc_1:
	029C 23             INC HL												; now points on Saved_Dir_ptr+1 (Head)
	029D 1F             RRA													; get Head selection state in Carry
	029E 30 01          JR NC,swc_2											; if Head is NOT currently selected jump swc_2
	02A0 71             LD (HL),C											; else Head selected; save character_direction in Saved_Dir_ptr+1 (Head)
swc_2:
	02A1 21 14 01       LD HL,SwopChara_Pressed								; point on SwopChara_Pressed
	02A4 FD 21 B0 24    LD IY,Heels_variables								; IY points on Heels variables
	02A8 7B             LD A,E												; get back selected_characters from E
	02A9 FE 03          CP 03												; Check if both are selected?
	02AB 28 4F          JR Z,Swop_Head_or_Heels								; Z = yes then Swop_Head_or_Heels, else:
	02AD 3A 85 24       LD A,(both_in_same_room)							; get both_in_same_room
	02B0 A7             AND A												; test if both in same room
	02B1 28 49          JR Z,Swop_Head_or_Heels								; not in same room -> Swop_Head_or_Heels; will RET
	;; at this point Head and Heels are in the same room, and currently
	;; only one of them is selected, so test if Head is on the top of
	;; Heels and aligned and, if so, merge both characters.
	;; Else switch to the other character.
try_merge:																	; else (same room)
	02B3 FD 7E 05       LD A,(IY+O_U)										; get Heels U coordinate
	02B6 3C             INC A												; +1 (because of parallax?)
	02B7 FD 96 17       SUB (IY+Head_offset+O_U)							; sub Head's U coordinate (#17=#12+#05, the +#12 is to point on Heads_variables)
	02BA FE 03          CP 03												; diffU >= 3, too far, just switch
	02BC 30 3E          JR NC,Swop_Head_or_Heels							; if not close in U, then Swop_Head_or_Heels; will RET
	02BE 4F             LD C,A												; save Heels U+1 in C
	02BF FD 7E 06       LD A,(IY+O_V)										; get Heels V coordinate
	02C2 3C             INC A												; +1 (because of parallax?)
	02C3 FD 96 18       SUB (IY+Head_offset+O_V)							; get Head V coordinate (#18=#12+#06, the +#12 is to point on Heads_variables)
	02C6 FE 03          CP 03												; diffV >= 3, too far, just switch
	02C8 30 32          JR NC,Swop_Head_or_Heels							; if apart V wise then Swop_Head_or_Heels; will RET
	02CA 47             LD B,A												; save Heels V+1 in B
	02CB FD 7E 07       LD A,(IY+O_Z)										; get Heels Z coordinate
	02CE D6 06          SUB 06												; substract one "character height"
	02D0 FD BE 19       CP (IY+Head_offset+O_Z)								; get Head Z coordinate (#19=#12+#07, the +#12 is to point on Heads_variables)
	02D3 20 27          JR NZ,Swop_Head_or_Heels							; if Head not exactly on Heels then Swop_Head_or_Heels; will RET
merge_head_on_heels:														; if all tests passed, then align if needed and merge
	02D5 1E FF          LD E,FF												; E=-1
	02D7 CB 18          RR B												; Heels V+1 bit 0 in Carry
	02D9 38 06          JR C,swop_3											; if Carry = 0, V aligned, else:
	02DB CB 18          RR B												; Heels V+1 bit 1 in Carry
	02DD 3F             CCF													; invert Carry
	02DE CD 20 03       CALL Sub_Get_displacement							; Update displacement in E
swop_3:
	02E1 CB 19          RR C												; Heels U+1 bit 0 in Carry
	02E3 38 07          JR C,swop_4											; if Carry = 0, U aligned, else:
	02E5 CB 19          RR C												; Heels U+1 bit 1 in Carry
	02E7 CD 20 03       CALL Sub_Get_displacement							; Update displacement in E
	02EA 18 04          JR swop_5											; jump swop_5
swop_4:																		; else
	02EC CB 03          RLC E												; aligned in U, so put no movement into the next two bits of E.
	02EE CB 03          RLC E
swop_5:
	02F0 3E 03          LD A,03												; both characters selected!
	02F2 1C             INC E												; test if E was FF
	02F3 28 12          JR Z,do_swop										; if 0 (was FF = U and V aligned), do_swop, else:
not_aligned:
	02F5 1D             DEC E												; get value of E back
	;; If not aligned, put the movement into Head's movement flag,
    ;; and clear the flag that says we've seen the swap button be pressed,
    ;; so we'll have another go next time.
	02F6 FD 73 1E       LD (IY+Head_offset+0C),E							; #1E=#12+#0C (the +#12 is to point on Heads_variables); ??? displacement if merged???
	02F9 CB 8E          RES 1,(HL)											; unselect swop key
	02FB C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Switch Head or Heels
;; HL = pointer on SwopChara_Pressed
;; Note that bit2 stores which of Head or Heels will be selected next
;;    time we swop; (cycle "Heels, Both, Head, Both").
.Swop_Head_or_Heels:
	02FC 3E 04          LD A,04												; bit2 set so a Xor will invert the bit
	02FE AE             XOR (HL)											; flip bit2 of SwopChara_Pressed (indicating next char to swop to)
	02FF 77             LD (HL),A											; save new value
	0300 E6 04          AND 04												; get NEW value of bit2 (inverted vs old)
	0302 3E 02          LD A,02												; prepare Head
	0304 28 01          JR Z,do_swop										; if new bit2 is 0 (old was 1), will use 2b10 (Head)
	0306 3D             DEC A												; else (bit2 is 1 (old was 0) will use 2b01 (Heels)
.do_swop:
	0307 32 84 24       LD (selected_characters),A							; update selected_characters
	030A CD 2F 03       CALL Sub_Set_Character_Flags
	030D CD 6A 03       CALL Get_Saved_direction_pointer					; HL = Saved_Dir_ptr; Carry set if using Heels, reset for Head
	0310 38 01          JR C,swop_8											; if Heels, skip
	0312 23             INC HL												; else (Head) point on Saved_Dir_ptr+1
swop_8:
	0313 7E             LD A,(HL)											; get saved facing direction for current character
	0314 32 AB 24       LD (character_direction),A							; update character_direction
	;; If both characters are on the same screen, we just redraw the
    ;; screen periphery (HUD). If they're not, we do restore all the state.
	0317 3A 85 24       LD A,(both_in_same_room)							; get both_in_same_room
	031A A7             AND A												; test
	031B C2 9C 45       JP NZ,Draw_Screen_Periphery							; in same room, only draw periphery; will RET
	031E 18 64          JR Restore_Character_flags							; else Restore_Character_flags; will RET

;; -----------------------------------------------------------------------------------------------------------
;; This is used to align Head and Heels when trying to merge them.
;; This will Shift the value in E by 2bits left and place
;; the Carry value in bit1 and the NOT(Carry) in bit 0. (Carry=0 : +1; Carry=1 : +2)
;; E will be updated wil a displacement. TODO ????
.Sub_Get_displacement:
	0320 F5             PUSH AF												; Save Carry state
	0321 CB 13          RL E												; E shifted left; Place Carry in bit0
	0323 F1             POP AF												; Recover Carry state
	0324 3F             CCF													; Invert it
	0325 CB 13          RL E												; E shifted left; Place Invert-Carry in bit0
	0327 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Set the current character flags.
;; This provides 2 functions:
;; * Set_Character_Flags
;; * Sub_Set_Character_Flags, expects IY on Heels variables,
;; 			and expects selected_characters in A
.Set_Character_Flags:
	0328 FD 21 B0 24    LD IY,Heels_variables								; init IY pointer on Heels variables
	032C 3A 84 24       LD A,(selected_characters)							; get selected_characters
.Sub_Set_Character_Flags:													; At this point IY must be a pointer on Heels variables and A = selected_characters
	032F FD 36 0A 00    LD (IY+O_FUNC),00									; Clear Heels O_FUNC (0A)
	0333 FD CB 04 9E    RES 3,(IY+O_FLAGS)									; Clear the 'tall' flag on Heels; OFLAGS (04)
	0337 CB 47          BIT 0,A												; test Heels active
	0339 20 04          JR NZ,sscf_skip										; if Heels selected, sscf_skip
	033B FD 36 0A 01    LD (IY+O_FUNC),01									; else set Heels O_FUNC to 1
sscf_skip:
	033F FD 36 1C 00    LD (IY+Head_offset+O_FUNC),00						; reset Head's O_FUNC; #1C=#12+O_FUNC;
	0343 FD CB 16 9E    RES 3,(IY+Head_offset+O_FLAGS)						; Clear the 'tall' flag on Head; O_FLAGS (04) ; #16 = Heads_variable+04 O_FLAGS
	0347 CB 4F          BIT 1,A												; test Head active
	0349 20 04          JR NZ,sscf_sk2										; if Head selected, sscf_sk2
	034B FD 36 1C 01    LD (IY+Head_offset+O_FUNC),01						; else set Head O_FUNC to 1 ; #1C : Heads_variable+O_FUNC (0A)
sscf_sk2
	034F FD CB 1B 8E    RES 1,(IY+Head_offset+O_SPRFLAGS) 					; Clear double-height flag on Head ; #1B=#12+#09 ; sprite flags
	0353 FE 03          CP 03												; both selected?
	0355 C0             RET NZ												; no, then RET, else both selected:
	0356 FD CB 04 DE    SET 3,(IY+O_FLAGS)									; Set the 'tall' flag on Heels ; O_FLAGS (04)
	035A FD CB 1B CE    SET 1,(IY+Head_offset+O_SPRFLAGS)					; and the double-height flag on Head. #1B = Heads_variable+09 ; sprite flags
	035E C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This compare the current Character's room to the other
;; Charaters's room.
;; Output: Z is set if they are in the same room
.Do_We_Share_Room:															; Z set if a shared room
	035F 2A 0E 01       LD HL,(current_Room_ID)								; get current_Room_ID
	0362 ED 5B 10 BB    LD DE,(Other_Character_state)						; at this point, the first word is room ID
	0366 A7             AND A												; reset flags, especially the Carry
	0367 ED 52          SBC HL,DE											; compare room IDs,
	0369 C9             RET													; Z set if in same room

;; -----------------------------------------------------------------------------------------------------------
;; Get the pointer on Saved_Dir_ptr in HL and selected_characters in E.
;; Output: E = selected_characters; and A = E >> 1
;;		Carry set = Heels selected, Carry reset = Heels not selected
;;		HL pointer on the saved facing direction for the characters
;;        (ie. pointer on Saved_Dir_ptr)
.Get_Saved_direction_pointer:
	036A 3A 84 24       LD A,(selected_characters)							; get selected_character
	036D 21 17 01       LD HL,Saved_Dir_ptr									; point on Saved_Dir_ptr where we store the facing direction of the characters
	0370 5F             LD E,A												; save A in E
	0371 1F             RRA													; Carry is set if Hells selected, reset if not Heels
	0372 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; The following provides functions to Save and Restore  the state of
;; the characters:
;; * Save_array (everything is saved as one block in Other_Character_state) (used after Dying and as Init):
;;      Save current character room, phase and direction (4 bytes)
;;		Save ObjListIdx (#1D bytes)
;;		Save ????TODO??? (#19 bytes)
;;		Save Objects (#3F0 bytes)
;;		Save Other character variables (#12 bytes)
;; * Restore_array (restored from Other_Character_state block) (used when entering a room):
;;		Restore everything listed in Save_array above at their original location
;;		clear_character_objects
;; * Restore_Character_flags (used when swopping but not in the same room)
;;		Swap everything listed in Save_array with what is in Other_Character_state
;;		Restore current character obj pointer from Other_Character_state (#12)
;;		Save other character variables into Other_Character_state
;;		clear_character_objects
;;		FinishRestore
.Save_array:
	0373 AF             XOR A												; A=0 "Save Mode"; Carry = 0
	0374 18 06          JR copy_Character_array

.Restore_array:
	0376 3E FF          LD A,FF												; A=-1 "Restore Mode"
	0378 21 D8 03       LD HL,clear_character_objects						; HL = addr clear_character_objects
	037B E5             PUSH HL												; push it on stack for next RET
.copy_Character_array:
	037C 21 28 04       LD HL,Ldir_copy										; pointer on Ldir_copy
	037F 11 BE 03       LD DE,Sub_Copy_Character_data						; pointer on Sub_Copy_Character_data
	0382 18 0B          JR copy_array

.Restore_Character_flags:													; when swopping but not in the same room
	0384 AF             XOR A
	0385 21 57 23       LD HL,FinishRestore									; Set the function to call after.
	0388 E5             PUSH HL												; push on stack (for RET)
	0389 21 1E 04       LD HL,Swap_DE_and_HL_cont_xBC						; points on Swap_DE_and_HL_cont_xBC
	038C 11 C6 03       LD DE,Sub_Copy_characters_arrays					; points on Sub_Copy_characters_arrays
	;; it'll now flow into copy_array
.copy_array:
	038F D5             PUSH DE												; DE on Stack (for next RET)
	0390 22 1C 04       LD (smc_copy_func+1),HL								; HL=#0428 (Ldir_copy = copy (HL) to (DE)) ou #041E (Swap_DE_and_HL_cont_xBC) self mod code.
	0393 CD E7 03       CALL Get_other_character_var_HL						; HL = pointer on NOT selected character's variables
	0396 22 C3 03       LD (arg_copy_character_variables),HL				; self modifying code : Heels_variables or Head_variables
	0399 A7             AND A												; test A
	039A 21 10 BB       LD HL,Other_Character_state
	039D 20 01          JR NZ,copy_array_direction							; exchange DE and HL (A=0) ot not (A=-1)
	039F EB             EX DE,HL											; if A=0 ("Save Mode") : DE<-->HL
copy_array_direction:
	03A0 08             EX AF,AF
	03A1 CD F4 03       CALL Copy_Data										; copy (4 + #1D + #19 + #3F0) bytes to or from Other_Character_state
	03A4 DATAWORD 04 00														; Argument 1: length $0004
	03A6 DATAWORD 0E 01														; Argument 2: current_Room_ID, Do_Objects_Phase, Last_Direction and Curr_Direction
	03A8 CD F4 03       CALL Copy_Data
	03AB DATAWORD 1D 00														; Argument 1: length $001D
	03AD DATAWORD A2 39 													; Argument 2: ObjListIdx (39A2)
	03AF CD F4 03       CALL Copy_Data
	03B2 DATAWORD 19 00 													; Argument 1: length $0019
	03B4 DATAWORD 92 24														; Argument 2: ???? (2492)
	03B6 CD F4 03       CALL Copy_Data
	03B9 DATAWORD F0 03														; Argument 1: length ObjectsLen (#03F0)
	03BB DATAWORD 40 6A														; Argument 2: Objects (6A40)
	03BD C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Runs Copy_Data on a character object.
.Sub_Copy_Character_data:
	03BE CD F4 03       CALL Copy_Data										; call Copy_Data
arg_copy_character_size:
	03C1 DATAWORD 12 00 													; Argument 1: size of the array #12 (18) bytes
arg_copy_character_variables:
	03C3 DATAWORD B0 24														; Argument 2: self modifying code, word at #03C3 is updated at line #0396, can be #24B0 (Heels_variables) or 24C2 (Head_variables)
	03C5 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Input: DE = pointer on initial source of data (#12 bytes variables array)
;; Then what this does is:
;; Copy the source into the currently selected variables array;
;; Then copy the Other character's vars into the initial source.
;; Finally it erase the ObjectLists array.
.Sub_Copy_characters_arrays:
	03C6 D5             PUSH DE
	03C7 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	03CA EB             EX DE,HL											; swap DE (now dest variables array) and HL (now source)
	03CB 01 12 00       LD BC,0012											; length of the array #12 = 18 bytes
	03CE C5             PUSH BC
	03CF ED B0          LDIR												; repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	03D1 CD E7 03       CALL Get_other_character_var_HL						; HL = pointer on NOT selected character's variables
	03D4 C1             POP BC												; BC = #12
	03D5 D1             POP DE												; DE =  what was source
	03D6 ED B0          LDIR												; repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
clear_character_objects:
	03D8 2A BD 39       LD HL,(Saved_Object_Destination)					; get Saved_Object_Destination
	03DB 22 A3 39       LD (Object_Destination),HL							; update Object_Destination
	03DE 21 AD 39       LD HL,ObjectLists + 1*4								; erase from #39AD (ObjectLists + 1*4)
	03E1 01 08 00       LD BC,0008											; for 8 bytes
	03E4 C3 67 24       JP Erase_forward_Block_RAM							; Continue on Erase_forward_Block_RAM (will have a RET)

;; -----------------------------------------------------------------------------------------------------------
;; Returns a HL pointer on the Character's variable that is **NOT**
;; currently selected
.Get_other_character_var_HL:
	03E7 21 84 24       LD HL,selected_characters							; points on selected_characters
	03EA CB 46          BIT 0,(HL)											; test Heels
	03EC 21 B0 24       LD HL,Heels_variables								; and point on Heels' variables
	03EF C8             RET Z												; if current NOT Heels, then return its var pointer
	03F0 21 C2 24       LD HL,Head_variables								; else it is Heels, so return a pointer on Head's variables
	03F3 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.Copy_Data:
	03F4 DD E1          POP IX												; All this gets the first DATAWORD argument: (IX is the addr of Arg1)
	03F6 DD 4E 00       LD C,(IX+00)										; ... In the code, Arg1 is placed after the "CALL Copy_Data".
	03F9 DD 23          INC IX												; ... Now, the supposed returned PC addr (addr just after the CALL)...
	03FB DD 46 00       LD B,(IX+00)										; ... was put on the Stack by the "CALL", but here it is in fact Argument 1, not instructions to RET to)...
	03FE DD 23          INC IX												; ... The value we get from it is the length to copy, put in BC.
	0400 08             EX AF,AF											; restore mode (A = 0: "Save"; A=-1 : "Restore")
	0401 A7             AND A												; test if copy_mode = 0
	0402 28 0A          JR Z,copy_Data_1									; if 0 "Save Mode" jump Copy_Data_1, else:
	0404 DD 5E 00       LD E,(IX+00)										; if copy_mode != 0 ("Restore") then
	0407 DD 23          INC IX
	0409 DD 56 00       LD D,(IX+00)										; get the second argument in DE
	040C 18 08          JR copy_Data_end									; and continue at copy_Data_end
copy_Data_1:
	040E DD 6E 00       LD L,(IX+00)										; but if copy_mode == 0 ("Save"):
	0411 DD 23          INC IX												; gets the second argument in HL
	0413 DD 66 00       LD H,(IX+00)
copy_Data_end:
	0416 DD 23          INC IX												; IX = pointers after Arg2, which is the real return address (PC after next RET addr)
	0418 08             EX AF,AF
	0419 DD E5          PUSH IX												; prepare return PC addr on stack (that the addr after Argument 2 DATAWORD).
	;; Continue to the currently-selected copy function, which may
	;; be either LDIR, or Swap_DE_and_HL_cont_xBC
smc_copy_func:
	041B C3 28 04       JP Ldir_copy										; self modifying code the addr at #041C changes in line #0390 ; default = #0428 (Ldir_copy)
	;;041C DATAWORD 28 04													; #0428 (Ldir_copy) by default; but could also be Swap_DE_and_HL_cont_xBC

;; -----------------------------------------------------------------------------------------------------------
;; Exchange (DE) and (HL); BC--; DE++; HL++ until BC = 0
;; Need HL and DE pointing on the arrays we want to swap; BC = the length.
.Swap_DE_and_HL_cont_xBC:
	041E 1A             LD A,(DE)											; temp = (DE)
	041F ED A0          LDI													; do once : LD (DE),(HL); DE++, HL++, BC--
	0421 2B             DEC HL												; note "DEC ss" (ss being a double reg) does NOT impact flags
	0422 77             LD (HL),A											; (HL) = temp
	0423 23             INC HL												; note "INC ss" (ss being a double reg) does NOT impact flags
	0424 EA 1E 04       JP PO,Swap_DE_and_HL_cont_xBC						; loop until BC reaches 0 (the OVerflow flag bit comes from LDI, because the DEC ss, LD and INC ss did not change the flags)
	0427 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Just a LDIR copy! (DE) <- (HL)
;; HL: begining of source array, DE: start of destination array; BC = length
.Ldir_copy:
	0428 ED B0          LDIR												; repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	042A C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; In sync with the Do_Objects_Phase, process the next object in the
;; linked list (CallObjFn : call object function) and point on next Object.
;; The phase mechanism allows an object to not get processed for one frame.
.Do_Objects:
	042B 3A 10 01       LD A,(Do_Objects_Phase)								; get Do_Objects_Phase
	042E EE 80          XOR 80												; toggle b7
	0430 32 10 01       LD (Do_Objects_Phase),A								; update Do_Objects_Phase
	0433 CD 51 25       CALL CharThing
	0436 2A AB 39       LD HL,(ObjectLists+2)								; get object pointer
	0439 18 1D          JR Sub_Do_Objects_entry

doob_loop:
	043B E5             PUSH HL												; save current object pointer
	043C 7E             LD A,(HL)
	043D 23             INC HL
	043E 66             LD H,(HL)
	043F 6F             LD L,A												; get next object pointer in HL from (ObjectLists+2)
	0440 E3             EX (SP),HL											; exchange object pointers (curr and next (next is now on the stack))
	0441 EB             EX DE,HL											; put current pointer in DE
	0442 21 0A 00       LD HL,O_FUNC										; O_FUNC = offset 000A in TmpObj_variables
	0445 19             ADD HL,DE											; HL = current + 10 (byte that has the phase ???)
	0446 3A 10 01       LD A,(Do_Objects_Phase)								; get Do_Objects_Phase
	0449 AE             XOR (HL)											; test bit7
	044A FE 80          CP 80
	044C 38 09          JR C,doob_0											; Skip if top bit doesn't match Phase
	044E 7E             LD A,(HL)											; else...
	044F EE 80          XOR 80
	0451 77             LD (HL),A											; ...flip top bit - will now mismatch Phase
	0452 E6 7F          AND 7F												; test other bits = Object Function ID
	0454 C4 64 37       CALL NZ,CallObjFn 									; if any other bits set, CallObjFn; DE is the current object pointer
doob_0:
	0457 E1             POP HL												; get next pointer from stack
Sub_Do_Objects_entry:
	0458 7C             LD A,H
	0459 B5             OR L												; test if HL = 0
	045A 20 DF          JR NZ,doob_loop										; loop until null pointer.
	045C C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Get door type from room data door value.
;; On CPC we have 3 types of doors (Note: on ZX-Spectrum all worlds use the 0 type door).
;;   0 is used for Prison,BlackTooth,Market and BookWorld
;;   1 is used for the Moon Base
;;   2 is used for Safari
;;  "3" is used (when decoding Room data) for Egyptus and Penitentiary
;;      but type 3 is redirected to 2. (so Egyptus and Penitentiary
;;      actually use the same door than Safari)
;; Input: A = Room data door type (0 to 3)
;; Output: A = Door sprite type to actually use (0, 1, 2 and 2 again)
.ToDoorId:
	045D FE 03          CP 03												; if A < 3 return A (0,1,2 cases)
	045F D8             RET C												; < 3 ret
	0460 3D             DEC A												; else return A-1 (note only "3" is the other case, so it returns 2)
	0461 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This will 1) Move a big block of loaded data 2) initialize some
;; Tables 3) set the interrupts/RST and 4) initialize the CRT (mode, colors, etc.).
.Init_table_and_crtc:
	0462 F3             DI													; Disable Interrupts
move_loaded_data_section:
	0463 11 97 B8       LD DE,B897											; destination of the last byte of the destination array
	0466 21 BF AD       LD HL,ADBF											; Move block from 6600-ADBF to 70D8-B897
	0469 01 C0 47       LD BC,47C0											; length #47C0 bytes
	046C ED B8          LDDR												; repeats LD (DE), (HL); DE--, HL--, BC-- until BC==0
erase_buffer_6800:
	046E 21 00 68       LD HL,6800											; array from #6800
	0471 01 00 01       LD BC,0100											; length 256 bytes
	0474 CD 67 24       CALL Erase_forward_Block_RAM						; Erase from #6800 to #68FF
inth_and_rst:
	0477 3E C3          LD A,C3												; A = #C3 (will be a JP instruction)
	0479 21 BC 04       LD HL,Interrupt_Handler								; Interrupt jump addr = #04BC
	047C 32 38 00       LD (0038),A											; override the RST7 interrupt handler...
	047F 22 39 00       LD (0039),HL										; ...with the routine Interrupt_Handler
	0482 21 00 01       LD HL,Entry											; override the RST0 Reset with...
	0485 32 00 00       LD (0000),A											; ...with a....
	0488 22 01 00       LD (0001),HL										; ...Jump at Entry
	048B ED 56          IM 1												; Interrupt Mode 1 = exec a RST7 (RST #38) when Int se produit
	048D CD EB 04       CALL Init_table
init_CTRC_and_screen:
	0490 01 8D 7F       LD BC,7F8D											; Gate Array Access:
	0493 ED 49          OUT (C),C											; Video Mode 1, Reset INT counter, Lower and upper ROM disabled
	0495 21 AB 04       LD HL,array_CRTC_init_values
	0498 01 00 BC       LD BC,BC00											; BC00 CRTC Reg Index 0
init_CRTC_loop:
	049B ED 49          OUT (C),C											; Select reg
	049D 7E             LD A,(HL)											; get reg value
	049E 04             INC B												; BD00 : CRTC Data Out
	049F ED 79          OUT (C),A											; set reg value
	04A1 05             DEC B												; BC00 CRTC Reg Index
	04A2 23             INC HL												; point on next value
	04A3 0C             INC C												; next Reg
	04A4 79             LD A,C
	04A5 FE 10          CP 10												; finished init 16 values?
	04A7 20 F2          JR NZ,init_CRTC_loop								; loop until finished, then:
	04A9 FB             EI													; Enable interrupts
	04AA C9             RET

;; -----------------------------------------------------------------------------------------------------------
array_CRTC_init_values:
	04AB DATABYTE 3F             		; CRTC reg 0 value : Width of the screen, in characters. Should always be 63 (#3F) (64 characters). 1 character == 1μs
	04AC DATABYTE 28 					; CRTC reg 1 value : Displayed char value, 40 (#28) is the default!
	04AD DATABYTE 2E					; CRTC reg 2 value : 46; When to start the HSync signal.
	04AE DATABYTE 8E					; CRTC reg 3 value : 142 (128+14); HSync pulse width in characters
	04AF DATABYTE 26					; CRTC reg 4 value : 38; Height of the screen, in characters
	04B0 DATABYTE 00					; CRTC reg 5 value : 0; Measured in scanlines
	04B1 DATABYTE 19					; CRTC reg 6 value : 25; Height of displayed screen in characters
	04B2 DATABYTE 21					; CRTC reg 7 value : 33 Note: default is 30; hen to start the VSync signal, in characters.
	04B3 DATABYTE 00					; CRTC reg 8 value : 0 = No interlace
	04B4 DATABYTE 07					; CRTC reg 9 value : 7; Maximum scan line address
	04B5 DATABYTE 0F					; CRTC reg 10 value : Cursor Start Raster (0 is the default)
	04B6 DATABYTE 0F					; CRTC reg 11 value : Cursor End Raster (0 is the default)
	04B7 DATABYTE 30					; CRTC reg 12 value : 48 (#30) Display Start Address (High)
	04B8 DATABYTE 00					; CRTC reg 13 value : Display Start Address (Low) (0 is the default)
	04B9 DATABYTE 30					; CRTC reg 14 value : Cursor Address (High) (0 is the default)
	04BA DATABYTE 00 					; CRTC reg 15 value : Cursor Address (Low)

;; -----------------------------------------------------------------------------------------------------------
VSYNC_wait_value:
	04BB DATABYTE 06

;; -----------------------------------------------------------------------------------------------------------
;; The interrupt is only run every VSYNC_wait_value VSYNCs
.Interrupt_Handler:
	04BC F5             PUSH AF
	04BD C5             PUSH BC												; Save all reg
	04BE E5             PUSH HL
	04BF 21 BB 04       LD HL,VSYNC_wait_value								; point on VSYNC_wait_value
	04C2 06 F5          LD B,F5												; PortB
	04C4 ED 48          IN C,(C)											; Read PortB (VSYNC_active is at bit 0)
	04C6 CB 19          RR C												; Put bit0 of C in Carry (9-bit Rigth-Rotation, Carry goes in b7 and oldb0 goes in Carry) ; b0 or PortB = CRT interrupt VSYNC active (1) inactive (0)
	04C8 38 03          JR C,ih_0											; jump if VSYNC active
	04CA 35             DEC (HL)											; VSYNC_wait_value--
	04CB 20 19          JR NZ,exit_int_handler			 					; jump exit_int_handler if VSYNC_wait_value != 0 else:
ih_0:
	04CD D5             PUSH DE
	04CE 36 06          LD (HL),06											; reset VSYNC_wait_value to 6
	04D0 DD E5          PUSH IX
	04D2 FD E5          PUSH IY
	04D4 CD B0 0B       CALL sub_IntH_play_update							; run actual interrupt code (music)
	04D7 FD E1          POP IY
	04D9 DD E1          POP IX
	04DB 3A 16 01       LD A,(Frame_counter)								; test Frame_counter
	04DE A7             AND A
	04DF 28 04          JR Z,ih_1											; jump if A=0 to Skip_Write_Frame
	04E1 3D             DEC A												; else update
	04E2 32 16 01       LD (Frame_counter),A								; Frame_counter
ih_1:
	04E5 D1             POP DE
exit_int_handler:
	04E6 E1             POP HL
	04E7 C1             POP BC												; restore state
	04E8 F1             POP AF
	04E9 FB             EI													; Enable Int
	04EA C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This initialize a table for the blit routines from 6600 to 66FF:
;;    6600 : 00 10 20 30 ... E0 F0
;;    6610 : 01 11 21 31 ... E1 F1
;;    6620 : 02 12 22 32 ... E2 F2
;;     ...
;;    66E0 : 0E 1E 2E 3E ... EE EF
;;    66F0 : 0F 1F 2F 3F ... EF FF
.Init_table:
	04EB 21 00 66       LD HL,6600											; HL = #6600
init_fill_loop:
	04EE 7D             LD A,L												; A = 0
	04EF 0F             RRCA												; 8b rotation to the right of A, old b0 goes in Carry and in b7
	04F0 0F             RRCA
	04F1 0F             RRCA
	04F2 0F             RRCA
	04F3 77             LD (HL),A
	04F4 2C             INC L												; 256 times
	04F5 20 F7          JR NZ,init_fill_loop
	04F7 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Draws the screen (in black) box per box. Hides the room drawing process.
;;
;; Draws screen in black with an X extent from 24 (#30/2 = 48/2 = 24)
;; to 208 (#40 + 6*24 = 208 < 209 (#D1)), Y extent from #40 to maxY.
.DrawBlacked:
	04F8 3E 08          LD A,08												; set color scheme to 8 (all Black)
	04FA CD 2C 05       CALL Set_colors
	04FD 21 40 30       LD HL,3040											; X extent (min=#30, first block up to #40, 16 pix, 4 bytes per block);
	0500 11 57 40       LD DE,4057											; Y extent (min=#40, first block up to #57, 23 lines per block)
dbl_1:
	0503 E5             PUSH HL
	0504 D5             PUSH DE
	0505 CD DE 1C       CALL DrawXSafe 										; X extent known to be in range.
	0508 D1             POP DE
	0509 E1             POP HL
	050A 65             LD H,L												; get X for next block
	050B 7D             LD A,L
	050C C6 18          ADD A,18											; First window is 16 pix (#40-#30) wide, subsequent are 24 pix (#18).
	050E 6F             LD L,A
	050F FE D1          CP D1												; #D1 = 209 pix ; Loop across the visible core of the screen.
	0511 38 F0          JR C,dbl_1
	0513 21 40 30       LD HL,3040											; return to left to the screen : initial X extent
	0516 53             LD D,E
	0517 7B             LD A,E												; increment Y for next box down
	0518 C6 2A          ADD A,2A											; First window is 17 (#57-#40), subsequent are #2A=42.
	051A 5F             LD E,A												; Loop all the way to row 255!
	051B 30 E6          JR NC,dbl_1
	051D C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This reconfigure the value of PEN 3 only from the color Scheme numer in A
;; Note : Apparently, this is #_NOT_USED_# !
Set_pen3_only:
	051E CD 4A 05       CALL Get_color_scheme_value							; update HL on the first color in the current color scheme
	0521 23             INC HL
	0522 23             INC HL												; HL+3 = pick the last of the 4 colors in the scheme
	0523 23             INC HL
	0524 01 03 7F       LD BC,7F03											; select pen 3
	0527 1E 01          LD E,01												; only 1 pen to setup
	0529 C3 3D 05       JP program_Gate_array_colors						; program_Gate_array_colors

;; -----------------------------------------------------------------------------------------------------------
;; Reconfigure the CRTC to setup the color Scheme, from the color Scheme
;; number in A.
;; 		Color Scheme 00 : Black, Blue, Red, Pastel_yellow
;; 		Color Scheme 01 : Black, Red, Mauve, Pastel_yellow
;; 		Color Scheme 02 : Black, Magenta, DarkGreen, Pastel_yellow
;; 		Color Scheme 03 : Black, Grey, Purple, Pastel_yellow
;; 		Color Scheme 04 : Black, DarkGreen, Red, White
;; 		Color Scheme 05 : Black, Red, DarkGreen, White
;; 		Color Scheme 06 : Black, DarkCyan, Orange, White
;; 		Color Scheme 07 : Black, Red, Blue, Pastel_yellow
;; 		Color Scheme 08 : Black, Black, Black, Black (Screen Off)
;; 		Color Scheme 09 : Grey, DarkBlue, DarkRed, Yellow
;; 		Color Scheme 0A : DarkRed, Yellow, Cyan, Pink
.Set_colors:
	052C CD 4A 05       CALL Get_color_scheme_value							; HL = pointer on color Scheme data
	052F 01 10 7F       LD BC,7F10											; Gate array BORDER select
	0532 1E 01          LD E,01												; number of colors to update (1 border)
	0534 CD 3D 05       CALL program_Gate_array_colors						; program_Gate_array_colors
	0537 2B             DEC HL												; reuse last color (Border color), for pen 0
	0538 1E 04          LD E,04												; need to set 4 pens (0 to 3)
	053A 01 00 7F       LD BC,7F00											; Select pen 0
program_Gate_array_colors:
	053D ED 49          OUT (C),C											; Tell Gate array which pen we want to setup
	053F 0C             INC C												; prepare for next pen
	0540 7E             LD A,(HL)											; get current color
	0541 F6 40          OR 40												; convert HW color to firmware color
	0543 ED 79          OUT (C),A											; write color value for current pen in GareArray
	0545 23             INC HL												; next data
	0546 1D             DEC E												; nb_pens--
	0547 20 F4          JR NZ,program_Gate_array_colors						; loop until we have done the 4 pens
	0549 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This converts the color Scheme number in A to the pointer in HL
;; on the Color Scheme data.
.Get_color_scheme_value:
	054A 87             ADD A,A
	054B 87             ADD A,A												; A*4 ;
	054C 11 54 05       LD DE,array_Color_Schemes							; pointer on array_Color_Schemes
	054F 6F             LD L,A
	0550 26 00          LD H,00												; HL = A (index in array_Color_Schemes is color Scheme * 4)
	0552 19             ADD HL,DE											; HL points on the 4 bytes defining the colors in the scheme
	0553 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Table for the Color Scheme 4 colors
;; (Index = color Scheme number * 4)
array_Color_Schemes:
	0554 DATABYTE 14 15 0C 03					; Color Scheme 00 : Black, Blue, Red, Pastel_yellow
	0558 DATABYTE 14 0C 1D 03					; Color Scheme 01 : Black, Red, Mauve, Pastel_yellow (used in one before last room for exemple)
	055C DATABYTE 14 18 16 03					; Color Scheme 02 : Black, Magenta, DarkGreen, Pastel_yellow
	0560 DATABYTE 14 00 05 03					; Color Scheme 03 : Black, Grey, Purple, Pastel_yellow
	0564 DATABYTE 14 16 0C 0B					; Color Scheme 04 : Black, DarkGreen, Red, White
	0568 DATABYTE 14 0C 16 0B					; Color Scheme 05 : Black, Red, DarkGreen, White
	056C DATABYTE 14 06 0E 0B					; Color Scheme 06 : Black, DarkCyan, Orange, White (Exemple : screen showing the worlds/crowns ("The Blacktooth Empire") or the "Salute you" screen); note DarkCyan is a vert-de-gris kinda color
	0570 DATABYTE 14 0C 15 03					; Color Scheme 07 : Black, Red, Blue, Pastel_yellow (This is probably the one for Room 1)
	0574 DATABYTE 14 14 14 14					; Color Scheme 08 : Black, Black, Black, Black (Screen Off)
	0578 DATABYTE 00 04 1C 0A					; Color Scheme 09 : Grey, DarkBlue, DarkRed, Yellow (Exemple: Game, Controls, Sound and Sensitivity menues)
	057C DATABYTE 1C 0A 13 07					; Color Scheme 0A : DarkRed, Yellow, Cyan, Pink (Exemple: Main menu)

;; -----------------------------------------------------------------------------------------------------------
;; Look-up the char ID in A (note: this value already had a minus #20)
;; and make DE point to the char symbol data.
;; For exemple: A=#11 (char ID #11 => char code ("ASCII") #35) will
;; point DE on the symbol data at #B6B8 (charID #11 : "5")
;;   B630 charID #00 : Space
;;   B638 charID #01 (char code #21) : menu selected arrows left part
;;   B640 charID #02 (char code #22) : menu selected arrows right part
;;   B648 charID #03 (char code #23) : menu unselected arrows left part
;;   B650 charID #04 (char code #24) : menu unselected arrows right part
;;   B658 charID #05 (char code #25) : speed lightning icon
;;   B660 charID #06 (char code #26) : spring icon
;;   B668 charID #07 (char code #27) : shield icon
;;   B670 charID #08 : comma
;;   B678 charID #09 : Big Block
;;   B680 charID #0A : Small block
;;   B688 charID #0B : "/"
;;   B690 charID #0C (char code #30) : "0"
;;	...
;;   B6D8 charID #15 (char code #39) : "9"
;;   B6E0 charID #16 : ":"
;;   B6E8 charID #17 : ";"
;;   B6F0 charID #18 : "@"
;;   B6F8 charID #19 (char code #41) : "A"
;;	...
;;   B7C0 charID #32 (char code #5A) : "Z"
;;   B7C8 charID #33 : "["
;;   B7D0 charID #34 : "\"
;;   B7D8 charID #35 : "]"
;;   B7E0 charID #36 : Up arrow
;;   B7E8 charID #37 : Down arrow
;;   B7F0 charID #38 : Right arrow
;;   B7F8 charID #39 : Left arrow
;; -----------------------------------------------------------------------------------------------------------
;; To understand the value manipulation and comparison, use this "graph":
;; spc         icons                              "0""1""2""3""4""5""6""7""8""9"                     "A""B""C""D" ...
;; 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 ... ID
;; 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 ... A = ID - #20
;; C  C  C  C  C  C  C  C  Z																							CP 08
;;                         4  5  6  7  8  9  A  B  C  D  E  F  10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 ... new A = A - #04
;;                         C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  Z								CP 18
;;                                                                                     14 15 16 17 18 19 1A 1B 1C ... new A = A - #04
;; -----------------------------------------------------------------------------------------------------------
;; Convert the CharCode - #20 to Symbol data address in DE
.Char_code_to_Addr:
	0580 FE 08          CP 08												; comp with 8 ("charcode - #20" compared with #08)
	0582 38 08          JR C,cc2a_0											; jump if charcode < ID#28 (icons) else:
	0584 D6 04          SUB 04                  							; newA =  entryA-4 (for characters like numbers, convert char code into charID, eg. "1" #31->id#0D)
	0586 FE 18          CP 18												; comp #18
	0588 38 02          JR C,cc2a_0											; jump if charcode < ID#3C else:
	058A D6 04          SUB 04												; newA -= 4 (for characters like letters, convert char code into charID, eg. "A" #41->id#19)
cc2a_0:
	058C 87             ADD A,A
	058D 87             ADD A,A												; A*4
	058E 6F             LD L,A
	058F 26 00          LD H,00
	0591 29             ADD HL,HL											; *2, char addr offset in HL
	0592 11 30 B6       LD DE,Char_symbol_data								; base addr for char data : Char_symbol_data
	0595 19             ADD HL,DE											; base+offset
	0596 EB             EX DE,HL                							; put the addr of the character symbol in DE
	0597 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Provides 2 functions:
;; 	* Clear_mem_array_at_6700: This will be implicitely CALLed by
;; 			the RET of the blit subroutines (blit_sub_subroutine_1 to 6)
;;			It erase the sprite buffer.
;;	* Clear_mem_array_256bytes: This will erase a memory block from the
;;			addr value in HL (Starts at HL, HL++ and until Lmax = #FF)
.Clear_mem_array_at_6700:
	0598 21 00 67       LD HL,6700											; init buffer addr
.Clear_mem_array_256bytes:
	059B AF             XOR A												; erase value = #00
cma_loop:
	059C 77             LD (HL),A
	059D 2C             INC L
	059E 77             LD (HL),A
	059F 2C             INC L
	05A0 77             LD (HL),A											; erase 4 consecutive bytes
	05A1 2C             INC L
	05A2 77             LD (HL),A
	05A3 2C             INC L
	05A4 20 F6          JR NZ,cma_loop										; L overflowed back to 4? No, then loop.
	05A6 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; BlitScreen copies from ViewBuff to the screen coordinates of
;; ViewYExtent and ViewXExtent. The X extent can be from 1 up to 6 bytes
;; (4 pix per bytes, 24 double pixels).
;; The "Extent" are Max,Min values.
;; At the end, the selected blit subroutine (having been pushed on the stack)
;; is implicitely CALLed by the RET (and so is the Erase function).
;;
;; ViewBuff is expected to be a 6 bytes wide, and the Y origin can
;; be adjusted by overwriting BlitYOffset. It is usually Y_START, but
;; is set to 0 during Draw_Sprite. The X origin is always fixed at 0x30
;; in double-width pixels.
.Blit_screen:
	05A7 2A 98 1C       LD HL,(ViewXExtent)									; get x pos for the sprite ViewXExtent
	05AA 7C             LD A,H
	05AB D6 30          SUB 30												; minus X origin
	05AD 4F             LD C,A												; topleft X
	05AE 7D             LD A,L												; minX
	05AF 94             SUB H												; maxX - minX = X width
	05B0 1F             RRA
	05B1 1F             RRA													; divided by 4 (4 pix per bytes in Mode 1)
	05B2 E6 07          AND 07					 							; Width = ((XHigh) - (XLow)) / 4
	05B4 3D             DEC A												; index in table = Width-1 : which blit subroutine (1 to 6)
	05B5 87             ADD A,A												; *2 = word aligned (to get the addr in table)
	05B6 5F             LD E,A
	05B7 16 00          LD D,00												; DE is the offset in the Sub_routines_table to get the addr of the blit subroutine to call
	05B9 21 D9 05       LD HL,Sub_routines_table
	05BC 19             ADD HL,DE											; HL points on the subroutine addr pointer
	05BD 11 98 05       LD DE,Clear_mem_array_at_6700						; The addr of the Clear_mem_array_6700_256bytes routine
	05C0 D5             PUSH DE												; is put on the stack for next RET so that next ret will branch on it
	05C1 5E             LD E,(HL)
	05C2 23             INC HL
	05C3 56             LD D,(HL)											; DE now has the selected blit subroutine addr
	05C4 D5             PUSH DE												; Push that address on the Stack so next RET will return to it (so next RET will call the blit subroutine, RET and call the erase 6700 and RET!)
	05C5 2A 9A 1C       LD HL,(ViewYExtent)									; get height extent (min and max Y) from ViewYExtent
	05C8 7D             LD A,L												; minY
	05C9 94             SUB H												; Height: (YHigh) - (YLow)
	05CA 08             EX AF,AF											; save minY
	05CB 7C             LD A,H												; maxY
smc_BlitYOffset_value:
	05CC D6	40			SUB 40												; minus origin ; value #40 by default, Draw_Sprite will self-modified code to change (and restore) that value
	;;05CD DATABYTE 40														; target of self-modifying code; default 40; modified by Draw_Sprite
	05CE 47             LD B,A												; topleft Y
	05CF CD 4B 08       CALL Get_screen_mem_addr							; Screen address (from topleft point YX in BC) is now in DE
	05D2 08             EX AF,AF											; restore minY
	05D3 06 66          LD B,66												; use the BC = #6600+X table index as input of the selected blit_sub_subroutine_1 to 6 that will be called at RET
	05D5 21 00 67       LD HL,6700											; use the HL = Buffer at #6700 as input for the selected blit_sub_subroutine_1 to 6 that will be called at RET
	05D8 C9             RET													; This RET will CALL the selected blit subroutine pushed on the Stack!

;; -----------------------------------------------------------------------------------------------------------
;; THis table will return the pointer address for the blit routine to
;; be used, with index = N-1; N being the byte width of the sprite.
.Sub_routines_table:
	05D9 DATAWORD E5 05     												; address of blit_sub_subroutine_1 (05E5)
	05DB DATAWORD 1E 06     												; address of blit_sub_subroutine_2 (061E)
	05DD DATAWORD 69 06														; address of blit_sub_subroutine_3 (0669)
	05DF DATAWORD C6 06														; address of blit_sub_subroutine_4 (06C6)
	05E1 DATAWORD 35 07														; address of blit_sub_subroutine_5 (0735)
	05E3 DATAWORD B6 07														; address of blit_sub_subroutine_6 (07B6)

;; -----------------------------------------------------------------------------------------------------------
;; All these (6 functions) provide Sprite Bliting functions.
;; They are implicitely CALLed by the final RET of Blit_screen.
;; The "blit_sub_subroutine_1 to 6" copies an N-byte-wide image
;; (in the buffer at HL) to the screen.
;; They use the table initialized at 6600-66FF and a buffer at 6700-67FF.
;; Input: HL = image location; DE = screen location, size in lines in B.
;; Note : HL buffer must be 6 bytes wide.
;; The RET will implicitely CALL the Clear_mem_array_at_6700 (that has
;; been pushed on the Stack)
.blit_sub_subroutine_1:
	05E5 08             EX AF,AF
	05E6 4E             LD C,(HL)											; get C from 6700 buffer
	05E7 24             INC H
	05E8 0A             LD A,(BC)											; get the index in 6600 table from BC = table + X
	05E9 AE             XOR (HL)
	05EA E6 0F          AND 0F
	05EC AE             XOR (HL)
	05ED 12             LD (DE),A
	05EE 4E             LD C,(HL)
	05EF 0A             LD A,(BC)
	05F0 25             DEC H
	05F1 AE             XOR (HL)
	05F2 E6 F0          AND F0
	05F4 AE             XOR (HL)
	05F5 1C             INC E
	05F6 12             LD (DE),A
	05F7 2C             INC L
	05F8 2C             INC L
	05F9 2C             INC L
	05FA 2C             INC L
	05FB 2C             INC L
	05FC 2C             INC L
	05FD 01 FF FF       LD BC,FFFF											; -1
	0600 EB             EX DE,HL
	0601 09             ADD HL,BC
	0602 EB             EX DE,HL
	0603 06 66          LD B,66												; Table values at #6600 + X (X in C)
	0605 7A             LD A,D
	0606 C6 08          ADD A,08
	0608 57             LD D,A
	0609 38 05          JR C,blit_ss_1
	060B 08             EX AF,AF
	060C 3D             DEC A
	060D 20 D6          JR NZ,blit_sub_subroutine_1
	060F C9             RET

blit_ss_1:
	0610 7B             LD A,E
	0611 C6 50          ADD A,50
	0613 5F             LD E,A
	0614 8A             ADC A,D
	0615 93             SUB E
	0616 D6 40          SUB 40
	0618 57             LD D,A
	0619 08             EX AF,AF
	061A 3D             DEC A
	061B 20 C8          JR NZ,blit_sub_subroutine_1
	061D C9             RET

.blit_sub_subroutine_2:
	061E 08             EX AF,AF
	061F 4E             LD C,(HL)
	0620 24             INC H
	0621 0A             LD A,(BC)
	0622 AE             XOR (HL)
	0623 E6 0F          AND 0F
	0625 AE             XOR (HL)
	0626 12             LD (DE),A
	0627 4E             LD C,(HL)
	0628 0A             LD A,(BC)
	0629 25             DEC H
	062A AE             XOR (HL)
	062B E6 F0          AND F0
	062D AE             XOR (HL)
	062E 1C             INC E
	062F 12             LD (DE),A
	0630 2C             INC L
	0631 13             INC DE
	0632 4E             LD C,(HL)
	0633 24             INC H
	0634 0A             LD A,(BC)
	0635 AE             XOR (HL)
	0636 E6 0F          AND 0F
	0638 AE             XOR (HL)
	0639 12             LD (DE),A
	063A 4E             LD C,(HL)
	063B 0A             LD A,(BC)
	063C 25             DEC H
	063D AE             XOR (HL)
	063E E6 F0          AND F0
	0640 AE             XOR (HL)
	0641 1C             INC E
	0642 12             LD (DE),A
	0643 2C             INC L
	0644 2C             INC L
	0645 2C             INC L
	0646 2C             INC L
	0647 2C             INC L
	0648 01 FD FF       LD BC,FFFD
	064B EB             EX DE,HL
	064C 09             ADD HL,BC
	064D EB             EX DE,HL
	064E 06 66          LD B,66												; Table values at #6600 + C
	0650 7A             LD A,D
	0651 C6 08          ADD A,08
	0653 57             LD D,A
	0654 38 05          JR C,blit_ss_2
	0656 08             EX AF,AF
	0657 3D             DEC A
	0658 20 C4          JR NZ,blit_sub_subroutine_2
	065A C9             RET

blit_ss_2:
	065B 7B             LD A,E
	065C C6 50          ADD A,50
	065E 5F             LD E,A
	065F 8A             ADC A,D
	0660 93             SUB E
	0661 D6 40          SUB 40
	0663 57             LD D,A
	0664 08             EX AF,AF
	0665 3D             DEC A
	0666 20 B6          JR NZ,blit_sub_subroutine_2
	0668 C9             RET

.blit_sub_subroutine_3:
	0669 08             EX AF,AF
	066A 4E             LD C,(HL)
	066B 24             INC H
	066C 0A             LD A,(BC)
	066D AE             XOR (HL)
	066E E6 0F          AND 0F
	0670 AE             XOR (HL)
	0671 12             LD (DE),A
	0672 4E             LD C,(HL)
	0673 0A             LD A,(BC)
	0674 25             DEC H
	0675 AE             XOR (HL)
	0676 E6 F0          AND F0
	0678 AE             XOR (HL)
	0679 1C             INC E
	067A 12             LD (DE),A
	067B 2C             INC L
	067C 13             INC DE
	067D 4E             LD C,(HL)
	067E 24             INC H
	067F 0A             LD A,(BC)
	0680 AE             XOR (HL)
	0681 E6 0F          AND 0F
	0683 AE             XOR (HL)
	0684 12             LD (DE),A
	0685 4E             LD C,(HL)
	0686 0A             LD A,(BC)
	0687 25             DEC H
	0688 AE             XOR (HL)
	0689 E6 F0          AND F0
	068B AE             XOR (HL)
	068C 1C             INC E
	068D 12             LD (DE),A
	068E 2C             INC L
	068F 13             INC DE
	0690 4E             LD C,(HL)
	0691 24             INC H
	0692 0A             LD A,(BC)
	0693 AE             XOR (HL)
	0694 E6 0F          AND 0F
	0696 AE             XOR (HL)
	0697 12             LD (DE),A
	0698 4E             LD C,(HL)
	0699 0A             LD A,(BC)
	069A 25             DEC H
	069B AE             XOR (HL)
	069C E6 F0          AND F0
	069E AE             XOR (HL)
	069F 1C             INC E
	06A0 12             LD (DE),A
	06A1 2C             INC L
	06A2 2C             INC L
	06A3 2C             INC L
	06A4 2C             INC L
	06A5 01 FB FF       LD BC,FFFB
	06A8 EB             EX DE,HL
	06A9 09             ADD HL,BC
	06AA EB             EX DE,HL
	06AB 06 66          LD B,66												; Table values at #6600 + C
	06AD 7A             LD A,D
	06AE C6 08          ADD A,08
	06B0 57             LD D,A
	06B1 38 05          JR C,blit_ss_3
	06B3 08             EX AF,AF
	06B4 3D             DEC A
	06B5 20 B2          JR NZ,blit_sub_subroutine_3
	06B7 C9             RET

blit_ss_3:
	06B8 7B             LD A,E
	06B9 C6 50          ADD A,50
	06BB 5F             LD E,A
	06BC 8A             ADC A,D
	06BD 93             SUB E
	06BE D6 40          SUB 40
	06C0 57             LD D,A
	06C1 08             EX AF,AF
	06C2 3D             DEC A
	06C3 20 A4          JR NZ,blit_sub_subroutine_3
	06C5 C9             RET

.blit_sub_subroutine_4:
	06C6 08             EX AF,AF
	06C7 4E             LD C,(HL)
	06C8 24             INC H
	06C9 0A             LD A,(BC)
	06CA AE             XOR (HL)
	06CB E6 0F          AND 0F
	06CD AE             XOR (HL)
	06CE 12             LD (DE),A
	06CF 4E             LD C,(HL)
	06D0 0A             LD A,(BC)
	06D1 25             DEC H
	06D2 AE             XOR (HL)
	06D3 E6 F0          AND F0
	06D5 AE             XOR (HL)
	06D6 1C             INC E
	06D7 12             LD (DE),A
	06D8 2C             INC L
	06D9 13             INC DE
	06DA 4E             LD C,(HL)
	06DB 24             INC H
	06DC 0A             LD A,(BC)
	06DD AE             XOR (HL)
	06DE E6 0F          AND 0F
	06E0 AE             XOR (HL)
	06E1 12             LD (DE),A
	06E2 4E             LD C,(HL)
	06E3 0A             LD A,(BC)
	06E4 25             DEC H
	06E5 AE             XOR (HL)
	06E6 E6 F0          AND F0
	06E8 AE             XOR (HL)
	06E9 1C             INC E
	06EA 12             LD (DE),A
	06EB 2C             INC L
	06EC 13             INC DE
	06ED 4E             LD C,(HL)
	06EE 24             INC H
	06EF 0A             LD A,(BC)
	06F0 AE             XOR (HL)
	06F1 E6 0F          AND 0F
	06F3 AE             XOR (HL)
	06F4 12             LD (DE),A
	06F5 4E             LD C,(HL)
	06F6 0A             LD A,(BC)
	06F7 25             DEC H
	06F8 AE             XOR (HL)
	06F9 E6 F0          AND F0
	06FB AE             XOR (HL)
	06FC 1C             INC E
	06FD 12             LD (DE),A
	06FE 2C             INC L
	06FF 13             INC DE
	0700 4E             LD C,(HL)
	0701 24             INC H
	0702 0A             LD A,(BC)
	0703 AE             XOR (HL)
	0704 E6 0F          AND 0F
	0706 AE             XOR (HL)
	0707 12             LD (DE),A
	0708 4E             LD C,(HL)
	0709 0A             LD A,(BC)
	070A 25             DEC H
	070B AE             XOR (HL)
	070C E6 F0          AND F0
	070E AE             XOR (HL)
	070F 1C             INC E
	0710 12             LD (DE),A
	0711 2C             INC L
	0712 2C             INC L
	0713 2C             INC L
	0714 01 F9 FF       LD BC,FFF9
	0717 EB             EX DE,HL
	0718 09             ADD HL,BC
	0719 EB             EX DE,HL
	071A 06 66          LD B,66												; Table values at #6600 + C
	071C 7A             LD A,D
	071D C6 08          ADD A,08
	071F 57             LD D,A
	0720 38 05          JR C,blit_ss_4
	0722 08             EX AF,AF
	0723 3D             DEC A
	0724 20 A0          JR NZ,blit_sub_subroutine_4
	0726 C9             RET

blit_ss_4:
	0727 7B             LD A,E
	0728 C6 50          ADD A,50
	072A 5F             LD E,A
	072B 8A             ADC A,D
	072C 93             SUB E
	072D D6 40          SUB 40
	072F 57             LD D,A
	0730 08             EX AF,AF
	0731 3D             DEC A
	0732 20 92          JR NZ,blit_sub_subroutine_4
	0734 C9             RET

.blit_sub_subroutine_5:
	0735 08             EX AF,AF
	0736 4E             LD C,(HL)
	0737 24             INC H
	0738 0A             LD A,(BC)
	0739 AE             XOR (HL)
	073A E6 0F          AND 0F
	073C AE             XOR (HL)
	073D 12             LD (DE),A
	073E 4E             LD C,(HL)
	073F 0A             LD A,(BC)
	0740 25             DEC H
	0741 AE             XOR (HL)
	0742 E6 F0          AND F0
	0744 AE             XOR (HL)
	0745 1C             INC E
	0746 12             LD (DE),A
	0747 2C             INC L
	0748 13             INC DE
	0749 4E             LD C,(HL)
	074A 24             INC H
	074B 0A             LD A,(BC)
	074C AE             XOR (HL)
	074D E6 0F          AND 0F
	074F AE             XOR (HL)
	0750 12             LD (DE),A
	0751 4E             LD C,(HL)
	0752 0A             LD A,(BC)
	0753 25             DEC H
	0754 AE             XOR (HL)
	0755 E6 F0          AND F0
	0757 AE             XOR (HL)
	0758 1C             INC E
	0759 12             LD (DE),A
	075A 2C             INC L
	075B 13             INC DE
	075C 4E             LD C,(HL)
	075D 24             INC H
	075E 0A             LD A,(BC)
	075F AE             XOR (HL)
	0760 E6 0F          AND 0F
	0762 AE             XOR (HL)
	0763 12             LD (DE),A
	0764 4E             LD C,(HL)
	0765 0A             LD A,(BC)
	0766 25             DEC H
	0767 AE             XOR (HL)
	0768 E6 F0          AND F0
	076A AE             XOR (HL)
	076B 1C             INC E
	076C 12             LD (DE),A
	076D 2C             INC L
	076E 13             INC DE
	076F 4E             LD C,(HL)
	0770 24             INC H
	0771 0A             LD A,(BC)
	0772 AE             XOR (HL)
	0773 E6 0F          AND 0F
	0775 AE             XOR (HL)
	0776 12             LD (DE),A
	0777 4E             LD C,(HL)
	0778 0A             LD A,(BC)
	0779 25             DEC H
	077A AE             XOR (HL)
	077B E6 F0          AND F0
	077D AE             XOR (HL)
	077E 1C             INC E
	077F 12             LD (DE),A
	0780 2C             INC L
	0781 13             INC DE
	0782 4E             LD C,(HL)
	0783 24             INC H
	0784 0A             LD A,(BC)
	0785 AE             XOR (HL)
	0786 E6 0F          AND 0F
	0788 AE             XOR (HL)
	0789 12             LD (DE),A
	078A 4E             LD C,(HL)
	078B 0A             LD A,(BC)
	078C 25             DEC H
	078D AE             XOR (HL)
	078E E6 F0          AND F0
	0790 AE             XOR (HL)
	0791 1C             INC E
	0792 12             LD (DE),A
	0793 2C             INC L
	0794 2C             INC L
	0795 01 F7 FF       LD BC,FFF7
	0798 EB             EX DE,HL
	0799 09             ADD HL,BC
	079A EB             EX DE,HL
	079B 06 66          LD B,66												; Table values at #6600 + C
	079D 7A             LD A,D
	079E C6 08          ADD A,08
	07A0 57             LD D,A
	07A1 38 05          JR C,blit_ss_5
	07A3 08             EX AF,AF
	07A4 3D             DEC A
	07A5 20 8E          JR NZ,blit_sub_subroutine_5
	07A7 C9             RET

blit_ss_5:
	07A8 7B             LD A,E
	07A9 C6 50          ADD A,50
	07AB 5F             LD E,A
	07AC 8A             ADC A,D
	07AD 93             SUB E
	07AE D6 40          SUB 40
	07B0 57             LD D,A
	07B1 08             EX AF,AF
	07B2 3D             DEC A
	07B3 20 80          JR NZ,blit_sub_subroutine_5
	07B5 C9             RET

.blit_sub_subroutine_6:
	07B6 08             EX AF,AF
	07B7 4E             LD C,(HL)
	07B8 24             INC H
	07B9 0A             LD A,(BC)
	07BA AE             XOR (HL)
	07BB E6 0F          AND 0F
	07BD AE             XOR (HL)
	07BE 12             LD (DE),A
	07BF 4E             LD C,(HL)
	07C0 0A             LD A,(BC)
	07C1 25             DEC H
	07C2 AE             XOR (HL)
	07C3 E6 F0          AND F0
	07C5 AE             XOR (HL)
	07C6 1C             INC E
	07C7 12             LD (DE),A
	07C8 2C             INC L
	07C9 13             INC DE
	07CA 4E             LD C,(HL)
	07CB 24             INC H
	07CC 0A             LD A,(BC)
	07CD AE             XOR (HL)
	07CE E6 0F          AND 0F
	07D0 AE             XOR (HL)
	07D1 12             LD (DE),A
	07D2 4E             LD C,(HL)
	07D3 0A             LD A,(BC)
	07D4 25             DEC H
	07D5 AE             XOR (HL)
	07D6 E6 F0          AND F0
	07D8 AE             XOR (HL)
	07D9 1C             INC E
	07DA 12             LD (DE),A
	07DB 2C             INC L
	07DC 13             INC DE
	07DD 4E             LD C,(HL)
	07DE 24             INC H
	07DF 0A             LD A,(BC)
	07E0 AE             XOR (HL)
	07E1 E6 0F          AND 0F
	07E3 AE             XOR (HL)
	07E4 12             LD (DE),A
	07E5 4E             LD C,(HL)
	07E6 0A             LD A,(BC)
	07E7 25             DEC H
	07E8 AE             XOR (HL)
	07E9 E6 F0          AND F0
	07EB AE             XOR (HL)
	07EC 1C             INC E
	07ED 12             LD (DE),A
	07EE 2C             INC L
	07EF 13             INC DE
	07F0 4E             LD C,(HL)
	07F1 24             INC H
	07F2 0A             LD A,(BC)
	07F3 AE             XOR (HL)
	07F4 E6 0F          AND 0F
	07F6 AE             XOR (HL)
	07F7 12             LD (DE),A
	07F8 4E             LD C,(HL)
	07F9 0A             LD A,(BC)
	07FA 25             DEC H
	07FB AE             XOR (HL)
	07FC E6 F0          AND F0
	07FE AE             XOR (HL)
	07FF 1C             INC E
	0800 12             LD (DE),A
	0801 2C             INC L
	0802 13             INC DE
	0803 4E             LD C,(HL)
	0804 24             INC H
	0805 0A             LD A,(BC)
	0806 AE             XOR (HL)
	0807 E6 0F          AND 0F
	0809 AE             XOR (HL)
	080A 12             LD (DE),A
	080B 4E             LD C,(HL)
	080C 0A             LD A,(BC)
	080D 25             DEC H
	080E AE             XOR (HL)
	080F E6 F0          AND F0
	0811 AE             XOR (HL)
	0812 1C             INC E
	0813 12             LD (DE),A
	0814 2C             INC L
	0815 13             INC DE
	0816 4E             LD C,(HL)
	0817 24             INC H
	0818 0A             LD A,(BC)
	0819 AE             XOR (HL)
	081A E6 0F          AND 0F
	081C AE             XOR (HL)
	081D 12             LD (DE),A
	081E 4E             LD C,(HL)
	081F 0A             LD A,(BC)
	0820 25             DEC H
	0821 AE             XOR (HL)
	0822 E6 F0          AND F0
	0824 AE             XOR (HL)
	0825 1C             INC E
	0826 12             LD (DE),A
	0827 2C             INC L
	0828 01 F5 FF       LD BC,FFF5
	082B EB             EX DE,HL
	082C 09             ADD HL,BC
	082D EB             EX DE,HL
	082E 06 66          LD B,66												; Table values at #6600 + C
	0830 7A             LD A,D
	0831 C6 08          ADD A,08
	0833 57             LD D,A
	0834 38 06          JR C,blit_ss_6
	0836 08             EX AF,AF
	0837 3D             DEC A
	0838 C2 B6 07       JP NZ,blit_sub_subroutine_6							; loop if NZ todo_subroutine_6
	083B C9             RET

blit_ss_6:
	083C 7B             LD A,E
	083D C6 50          ADD A,50
	083F 5F             LD E,A
	0840 8A             ADC A,D
	0841 93             SUB E
	0842 D6 40          SUB 40
	0844 57             LD D,A												; DE = DE + 50 - 4000
	0845 08             EX AF,AF
	0846 3D             DEC A
	0847 C2 B6 07       JP NZ,blit_sub_subroutine_6							; loop if NZ todo_subroutine_6
	084A C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This is the CPC screen mem address calculation from the pixel we target.
;; Input: B = y (line),
;;        C = x single-pixel coordinate (in mode 1 real x is double that value).
;; Note: top left coord is (0,0) at addr #C000. Mode 1 ppb (pix per byte) is 4
;; This will calculate the Output in DE:
;; 		DE = address = 0xC000 + ((y / 8) * 80) + ((y % 8) * #0800) + (x / ppb)
.Get_screen_mem_addr:
	084B 78             LD A,B												; A = y coord = line number
	084C E6 F8          AND F8												; A= (y / 8) * 8
	084E 5F             LD E,A												; tmp=A*1
	084F 0F             RRCA												; A div by 2
	0850 0F             RRCA												; A div by 4 (A * 0.25)
	0851 83             ADD A,E												; A*1.25 ((A * 1) + (A * 0.25))
	0852 87             ADD A,A												; A*2.5; overflow in Carry
	0853 CB 10          RL B												; (y%128)*2+carry  (BC = (y%128) * #0200 + x)
	0855 87             ADD A,A												; A*5; overflow in Carry
	0856 CB 10          RL B												; (y%64)*4+carry  (BC = (y%64) * #0200 + x)
	0858 87             ADD A,A												; A*10 = (y / 8) * 80; overflow in Carry
	0859 CB 10          RL B												; (y%32)*8+carry  (BC = (y%32) * #0800 + x)
	085B CB 39          SRL C												; C=x/2  (BC = (y%32) * #0800 + x/2)
	085D 81             ADD A,C												; Then, all this...
	085E 5F             LD E,A
	085F 88             ADC A,B												; ...does...
	0860 93             SUB E
	0861 F6 C0          OR C0
	0863 57             LD D,A												; ... DE = C000 + BC + A
	0864 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Wipe screen with the spirals/snake effect
.Draw_wipe_and_Clear_Screen:
	0865 1E 03          LD E,03
dwcs_0:
	0867 21 00 C0       LD HL,C000											; screen address
	086A 01 00 40       LD BC,4000											; screen length
	086D 55             LD D,L												; DE=3
dwcs_1:
	086E 7E             LD A,(HL)
	086F 1F             RRA
	0870 E6 77          AND 77
	0872 CB 1A          RR D
	0874 30 02          JR NC,dwcs_2
	0876 F6 08          OR 08
dwcs_2:
	0878 CB 5A          BIT 3,D
	087A 28 02          JR Z,dwcs_3
	087C F6 80          OR 80
dwcs_3:
	087E 56             LD D,(HL)
	087F A2             AND D
	0880 77             LD (HL),A
	0881 23             INC HL
	0882 0B             DEC BC
	0883 78             LD A,B
	0884 B1             OR C
	0885 20 E7          JR NZ,dwcs_1
	0887 51             LD D,C
	0888 01 00 40       LD BC,4000
dwcs_4:
	088B 2B             DEC HL
	088C 7E             LD A,(HL)
	088D 17             RLA
	088E E6 EE          AND EE
	0890 CB 12          RL D
	0892 30 02          JR NC,dwcs_5
	0894 F6 10          OR 10
dwcs_5:
	0896 CB 62          BIT 4,D
	0898 28 02          JR Z,dwcs_6
	089A F6 01          OR 01
dwcs_6:
	089C 56             LD D,(HL)
	089D A2             AND D
	089E 77             LD (HL),A
	089F 0B             DEC BC
	08A0 78             LD A,B
	08A1 B1             OR C
	08A2 20 E7          JR NZ,dwcs_4
	08A4 1D             DEC E
	08A5 20 C0          JR NZ,dwcs_0
clr_screen:																	; Finally clear the screen
	08A7 21 00 C0       LD HL,C000											; screen addr
	08AA 01 00 40       LD BC,4000											; screen length : Wipe screen
	08AD C3 67 24       JP Erase_forward_Block_RAM							; Erase_forward_Block_RAM will have a RET

;; -----------------------------------------------------------------------------------------------------------
;; Draw a sprite (or char Symbol), with attributes in A (color style).
;; Source in DE, dest coords in BC, size in HL (H height, L width)
;; Attribute "color style" in A (1 = shadow mode, 3 = color mode)
;; (X measured in double-pixels, centered on $80)
;; Top of screen is Y = 0, for once.
.Draw_Sprite:
	08B0 D5             PUSH DE												; DE has the char symbol pointer or sprite source
	08B1 F5             PUSH AF												; A have the attribute (color style) number
	08B2 3E F8          LD A,F8												; -8 ??
	08B4 32 CD 05       LD (smc_BlitYOffset_value+1),A						; update the val in "SUB val" (BlitYoffset+1) at #05CC in Blit_Screen ; self mod code
	08B7 50             LD D,B
	08B8 78             LD A,B												; Y
	08B9 84             ADD A,H												; Y + height
	08BA 5F             LD E,A												; DE is now Y,Y+height = YExtent
	08BB ED 53 9A 1C    LD (ViewYExtent),DE									; update ViewYExtent
	08BF 79             LD A,C
	08C0 41             LD B,C
	08C1 85             ADD A,L												; same for XExtent
	08C2 4F             LD C,A
	08C3 ED 43 98 1C    LD (ViewXExtent),BC									; update ViewXExtent
	08C7 7D             LD A,L												; Width
	08C8 0F             RRCA
	08C9 0F             RRCA												; div 4 (4 pix per byte)
	08CA E6 07          AND 07
	08CC 4F             LD C,A												; number of bytes
	08CD F1             POP AF												; get back attribute (color style) number
	08CE 11 00 67       LD DE,6700											; DE point on sprite buffer
	08D1 FE 03          CP 03												; is it 3 (color mode)? (no:Carry set, yes:Carry reset)
	08D3 3F             CCF													; inverts Carry flag (not 3: Carry reset; Pen3: Carry set)
	08D4 38 05          JR C,drwspr_1										; if 3, then jump drwspr_1, else:
	08D6 FE 01          CP 01												; is attribute (color style) = 1? (attr 0: NZ,Carry, attr 1: Z,NC, attr 2: NZ,NC)
	08D8 20 01          JR NZ,drwspr_1										; not attr 1, jump drwspr_1, else attribute (color style) is 1 = "Shadow" mode:
	08DA 14             INC D												; if shadow mode, use buffer = 6800
drwspr_1:
	08DB 7C             LD A,H												; height
	08DC 08             EX AF,AF											; get flags, save height
	08DD 21 00 68       LD HL,6800											; clear 256 bytes buffer from #6800
	08E0 CD 9B 05       CALL Clear_mem_array_256bytes
	08E3 08             EX AF,AF											; save flags, get height
	08E4 EB             EX DE,HL											; DE<->HL
	08E5 D1             POP DE												; get sprite/symbol source (addr)
drwspr_2:
	08E6 08             EX AF,AF
	08E7 41             LD B,C												; nb of bytes in X direction
drwspr_3:
	08E8 1A             LD A,(DE)											; get byte of data
	08E9 77             LD (HL),A											; draw it to buffer
	08EA 08             EX AF,AF
	08EB 30 05          JR NC,drwspr_4
	08ED 24             INC H
	08EE 08             EX AF,AF
	08EF 77             LD (HL),A
	08F0 08             EX AF,AF
	08F1 25             DEC H
drwspr_4:
	08F2 08             EX AF,AF
	08F3 2C             INC L
	08F4 13             INC DE
	08F5 10 F1          DJNZ drwspr_3
	08F7 3E 06          LD A,06						 						; ViewBuff is 6 bytes wide...
	08F9 91             SUB C
	08FA 85             ADD A,L
	08FB 6F             LD L,A
	08FC 08             EX AF,AF
	08FD 3D             DEC A
	08FE 20 E6          JR NZ,drwspr_2
	0900 CD A7 05       CALL Blit_screen									; Blit the sprite in the buffer
	0903 3E 40          LD A,40												; original Y_START
	0905 32 CD 05       LD (smc_BlitYOffset_value+1),A						; restore the val in "SUB val" (BlitYoffset+1) at #05CC in Blit_Screen
	0908 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Some more strings (keyboard related)
.String_Table_2:
	0909 DATABYTE FF   								; Delimiter (ID #E0)
	090A STRING 52 45 54 55 52 4E             		; String "RETURN"
	0910 DATABYTE FF   								; Delimiter (ID #E1)
	0911 DATABYTE 83								; Pointer on String ID #83
	0912 STRING 4C 4F 43 4B							; String "LOCK"
	0916 DATABYTE FF   								; Delimiter (ID #E2)
	0917 DATABYTE 83								; Pointer on String ID #83
	0918 STRING 45 53 43							; String "ESC"
	091B DATABYTE FF   								; Delimiter (ID #E3)
	091C DATABYTE 83								; Pointer on String ID #83
	091D STRING 54 41 42							; String "TAB"
	0920 DATABYTE FF   								; Delimiter (ID #E4)
	0921 DATABYTE 83								; Pointer on String ID #83
	0922 STRING 44 45 4C							; String "DEL"
	0925 DATABYTE FF   								; Delimiter (ID #E5)
	0926 DATABYTE 83								; Pointer on String ID #83
	0927 STRING 43 54 52 4C							; String "CTRL"
	092B DATABYTE FF   								; Delimiter (ID #E6)
	092C DATABYTE 83								; Pointer on String ID #83
	092D STRING 43 4F 50 59							; String "COPY"
	0931 DATABYTE FF   								; Delimiter (ID #E7)
	0932 DATABYTE 83								; Pointer on String ID #83
	0933 STRING 43 4C 52							; String "CLR"
	0936 DATABYTE FF   								; Delimiter (ID #E8)
	0937 DATABYTE 81								; Pointer on String ID #81
	0938 STRING 4A 4F 59							; String "JOY"
	093B DATABYTE FF   								; Delimiter (ID #E9)
	093C DATABYTE E8								; Pointer on String ID #E8 ("|JOY")
	093D STRING 46									; String "F"
	093E DATABYTE FF   								; Delimiter (ID #EA)
	093F DATABYTE E8								; Pointer on String ID #E8 ("|JOY")
	0940 STRING 55									; String "U"
	0941 DATABYTE FF   								; Delimiter (ID #EB)
	0942 DATABYTE E8								; Pointer on String ID #E8 ("|JOY")
	0943 STRING 44									; String "D"
	0944 DATABYTE FF   								; Delimiter (ID #EC)
	0945 DATABYTE E8								; Pointer on String ID #E8 ("|JOY")
	0946 STRING 52									; String "R"
	0947 DATABYTE FF   								; Delimiter (ID #ED)
	0948 DATABYTE E8								; Pointer on String ID #E8 ("|JOY")
	0949 STRING 4C									; String "L"
	094A DATABYTE FF   								; Delimiter (ID #EE)
	094B DATABYTE 83								; Pointer on String ID #83
	094C STRING 53 50 41 43 45						; String "SPACE"
	0951 DATABYTE FF      							; Delimiter (ID #EF)

;; -----------------------------------------------------------------------------------------------------------
;; Reminder: ASCII table:
;;      0 1 2 3 4 5 6 7 8 9 A B C D E F
;; 20 :' '! " # $ % & ' ( ) * + , - . /
;; 30 : 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
;; 40 : @ A B C D E F G H I J K L M N O
;; 50 : P Q R S T U V W X Y Z [ \ ] updw
;; 60 : RtLfb c d e f g h i j k l m n o
;; 70 : p q r s t u v w x y z { | ] ~
;;
;; Keyboard Matrix
;; Bit# 								Line
;;	 		0 			1 			2 		3 	4 	5 		6 				7 	8 			9
;; 7		f.			f0			Ctrl	>,	<.	Space	V				X	Z			Del
;; 6		Enter		f2			`\		?/	M	N		B				C	CapsLock	Unused
;; 5		f3			f1			Shift	*:	K	J		F  / Joy1Fire1	D	A			Joy0Fire1
;; 4		f6			f5			f4 		+;	L	H		G  / Joy1Fire2	S	Tab			Joy0Fire2
;; 3		f9			f8			}]		P	I	Y		T  / Joy1Right	W	Q			Joy0Right
;; 2		CursorDown	f7			Return	|@	O	U		R  / Joy1Left	E	Esc			Joy0Left
;; 1		CursorRight	Copy		{[		=-	)9	'7		%5 / Joy1Down	#3	"2			Joy0Down
;; 0		CursorUp	CursorLeft	Clr		Â£^	_0	(8		&6 / Joy1Up		$4	!1			Joy0Up

;; -----------------------------------------------------------------------------------------------------------
;; This table will be used to convert a keyboard key code
;; (scan line * 8 + bitnb) to a printable char or string.
;; These are therefore listed in the keyboard scan order: line0 to line9 and bit 0 to 7
.Char_Set:		              					;     bit:  0    1    2   3     4   5    6    7
	0952 DATABYTE 5E 60 5F 39 36 33 8C 2E		; (line 0) "Up", "Right", "Down", "9", "6", "3", "|RETURN", "."
	095A DATABYTE 61 E6 37 38 35 31 32 30		; (line 1) "Left", "COPY", "7", "8", "5", "1", "2", 0"
	0962 DATABYTE E7 5B 8C 5D 34 8D 5C E5		; (line 2) "CLR", "[", "|RETURN", "]", "4", "|SHIFT", "\", "CTRL"
	096A DATABYTE 5E 2D 40 50 3B 3A 2F 2E		; (line 3) "^", "-", "@", "P", ";", ":", "/", ","
	0972 DATABYTE 30 39 4F 49 4C 4B 4D 2C		; (line 4) "0", "9", "O", "I", "L", "K", "M", "."
	097A DATABYTE 38 37 55 59 48 4A 4E EE		; (line 5) "8", "7", "U", "Y", "H", "J", "N", "SPACE"
	0982 DATABYTE 36 35 52 54 47 46 42 56		; (line 6) "6", "5", "R", "T", "G", "F", "B", "V"
	098A DATABYTE 34 33 45 57 53 44 43 58		; (line 7) "4", "3", "E", "W", "S", "D", "C", "X"
	0992 DATABYTE 31 32 E2 51 E2 41 E1 5A		; (line 8) "1", "2", ESC, "Q", TAB, "A", LOCK, "Z"
	099A DATABYTE EA EB ED EC E9 E9 58 E4		; (line 9) JOYU, JOYD, JOYL, JOYR, JOYF, JOYF, (unused), DEL

;; -----------------------------------------------------------------------------------------------------------
;; These are the map codes for the keyboard (CPC 6128) when scanning the
;; keyloard lines, in order to check it the wanted  key is pressed or not
;; For exemple, if, while scanning the keyboard lines, at line1, bit0,
;; (current offset = 1*8 + 0 = 8 (9th value)) the value returned by the
;; AY-3 is "FE", the matching (reg OR map) will result in "FE" (ie. non-FF)
;; indicating that the "Left" arrow key is being pressed. (active low)
.Array_Key_map:
	;;           LftRgtDwnUp_JmpCryFirSwp		;          Left  Rgt   Down  Up   Jump  Carry  Fire  Swop
	09A2 DATABYTE FF FD FB FE FF 1F EF F7		; line 0 : ___ , RGT , DWN , UP  , ___ , RET3., F6 ,  F9
	09AA DATABYTE FE FF FF FF FD 1F EF F3		; line 1 : Left, ___ , ___ , ___ , Copy, F120,  F5 , F7F8
	09B2 DATABYTE FF FF FF FF FF FF EF FF		; line 2 : ___ , ___ , ___ , ___ , ___ , ___ ,  F4 , ___
	09BA DATABYTE FF FF FF FF FF FF FF FF		; line 3 : nothing
	09C2 DATABYTE FF FF FF FF FF FF FF FF		; line 4 : nothing
	09CA DATABYTE FF FF FF FF 7F 7F FF FF		; line 5 : ___ , ___ , ___ , ___ , SPC , SPC , ___ , ___
	09D2 DATABYTE FF FF FF FF FF FF FF FF		; line 6 : nothing
	09DA DATABYTE FF FF FF FF FF FF FF FF		; line 7 : nothing
	09E2 DATABYTE FF FF FF FF FF FF FF FF		; line 8 : nothing
	09EA DATABYTE FB F7 FD FE EF FF FF FF		; line 9 : JoyL, JoyR, JoyD, JoyU, JoF2, ___ , ___ , ___

;; -----------------------------------------------------------------------------------------------------------
;; Scan the keyboard;
;; Output: A = 0: a key was pressed;
;;         A != 0: no key pressed;
;; If a key has been pressed, the key map index is in B
;; (B[7:3] = line_number ; B[2:0] = active_bit_number)
.Scan_keyboard:
	09F2 21 C0 6F       LD HL,6FC0											; buffer for scanned keys
	09F5 CD 3F 0B       CALL Keyboard_scanning_setup						; init key board scanning
	09F8 0E 40          LD C,40												; Select keyboard line scanning 0 (BC=F740)
scan_loop_1:
	09FA 06 F6          LD B,F6												; Setup PSG (Keyboard feature) for Read reg (BC=F640)
	09FC ED 49          OUT (C),C
	09FE 06 F4          LD B,F4												; BC=F4xx
	0A00 ED 78          IN A,(C)											; ead line status (Read keyboard line 0)
	0A02 3C             INC A
	0A03 20 0E          JR NZ,find_key_pressed								; if was not FF (something was pressed then find_key_pressed), else:
	0A05 23             INC HL												; next line
	0A06 0C             INC C												; next key
	0A07 79             LD A,C
	0A08 E6 0F          AND 0F
	0A0A FE 0A          CP 0A												; have we reached last keyboard line?
	0A0C 38 EC          JR C,scan_loop_1									; no: scan_loop_1, else :
	0A0E CD 54 0B       CALL Keyboard_scanning_ending						; end keyboard scanning
	0A11 3C             INC A												; Return with A != 0 : nothing pressed
	0A12 C9             RET

find_key_pressed:
	0A13 3D             DEC A												; restore real line scan value (INC A done at 0A02)
	0A14 01 7F FF       LD BC,FF7F          								; this will produce B=0 and C=FE
fkp_1:
	0A17 CB 01          RLC C
	0A19 04             INC B
	0A1A 1F             RRA
	0A1B 38 FA          JR C,fkp_1											; test every bit until we find an unset one, B will gave the bit number
	0A1D 7D             LD A,L												; L = line number + #C0
	0A1E D6 C0          SUB C0												; A=line number
	0A20 87             ADD A,A
	0A21 87             ADD A,A
	0A22 87             ADD A,A												; line number << 3 (*8)
	0A23 80             ADD A,B												; A[7:3] = line_number ; A[2:0] = active_bit_number = index in key map table
	0A24 47             LD B,A												; store value in B
	0A25 D9             EXX
	0A26 CD 54 0B       CALL Keyboard_scanning_ending						; end keyboard scanning
	0A29 D9             EXX
	0A2A AF             XOR A												; Return with A = 0 : something pressed (value in B)
	0A2B C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Given a Char_Set key code index in B, get the printable character for it in A.
;; eg. B = #26 will return A = #4D ("M", keyboard scan line 4, bit 6)
.GetCharStrId:
	0A2C 78             LD A,B
	0A2D C6 52          ADD A,52											; Char_Set & $00FF
	0A2F 6F             LD L,A
	0A30 CE 09          ADC A,09											; (Char_Set & #FF00) >> 8 + char offset in B
	0A32 95             SUB L
	0A33 67             LD H,A
	0A34 7E             LD A,(HL)											; get printable code in A
	0A35 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Check if a key has been pressed and released.
.Wait_anykey_released:
	0A36 CD F2 09       CALL Scan_keyboard									; A = 0: a key was pressed; A != 0: no key pressed;
	0A39 28 FB          JR Z,Wait_anykey_released							; loop Wait_anykey_released if a key is still pressed
	0A3B C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Test if Enter of Shift has been pressed
;; Output: Carry=1 (and NZ): no key pressed, A=non-0
;;    else Carry=0 (and Z) and C=0: Enter, C=1: Shift, C=2: other, A=0
.Test_Enter_Shift_keys:
	0A3C CD F2 09       CALL Scan_keyboard 									; returns A=0 if a key is pressed and also B[7:3] = line_number ; B[2:0] = active_bit_number, hence B = keymap index
	0A3F 37             SCF													; Set Carry flag
	0A40 C0             RET NZ												; RET if nothing pressed (Carry=1)
	0A41 78             LD A,B												; key map index ((scanline*8)+bitnb)
	0A42 0E 00          LD C,00												; prepare output value C=0
	0A44 FE 12          CP 12												; test if line=B[7:3]=2 and bitnb=B[2:0]=2, in other words the "Enter/Return" key
	0A46 C8             RET Z												; if "Enter/Return" key pressed, exit with BC=xx00, Carry=0
	0A47 0C             INC C												; output value: C=1
	0A48 FE 15          CP 15												; test if line=B[7:3]=2 and bitnb=B[2:0]=5, in other word the "Shift" key
	0A4A C8             RET Z												; else if "Shift" key pressed, exit with BC=xx01, Carry=0
	0A4B 0C             INC C												; output value: C=2
	0A4C AF             XOR A												; A=0, Carry = 0
	0A4D C9             RET													; else (any other key) return with A=0 and BC=xx02

;; -----------------------------------------------------------------------------------------------------------
;; Input: A = key map index we want to point ((line * 8) + bitnb)
;; Output: HL : the address of the key map data for the wanted key
.Get_Key_Map_Addr:
	0A4E 11 A2 09       LD DE,Array_Key_map									; point on Array_Key_map
	0A51 6F             LD L,A
	0A52 26 00          LD H,00												; HL = A , offset in the table
	0A54 19             ADD HL,DE											; HL = DE + A : add offset in A, HL points on wanted key in Array_Key_map
	0A55 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Used by the "Controls" Menu to list all assigned keys.
.ListControls:
	0A56 CD 4E 0A       CALL Get_Key_Map_Addr
	0A59 0E 00          LD C,00
lc_3:
	0A5B 7E             LD A,(HL)
	0A5C 06 FF          LD B,FF
lc_0:
	0A5E FE FF          CP FF
	0A60 28 16          JR Z,lc_2
lc_1:
	0A62 04             INC B
	0A63 37             SCF
	0A64 1F             RRA
	0A65 38 FB          JR C,lc_1
	0A67 E5             PUSH HL
	0A68 F5             PUSH AF
	0A69 79             LD A,C
	0A6A 80             ADD A,B
	0A6B C5             PUSH BC
	0A6C 47             LD B,A
	0A6D CD 2C 0A       CALL GetCharStrId
	0A70 CD EC 0A       CALL PrintCharAttr2									; clear the end of line
	0A73 C1             POP BC
	0A74 F1             POP AF
	0A75 E1             POP HL
	0A76 18 E6          JR lc_0

lc_2:
	0A78 11 08 00       LD DE,0008
	0A7B 19             ADD HL,DE
	0A7C 79             LD A,C
	0A7D C6 08          ADD A,08
	0A7F 4F             LD C,A
	0A80 FE 50          CP 50
	0A82 38 D7          JR C,lc_3
	0A84 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Used by the "Controls" Menu to Edit the assigned keys.
.Edit_control:
	0A85 CD 4E 0A       CALL Get_Key_Map_Addr
	0A88 E5             PUSH HL
	0A89 CD 36 0A       CALL Wait_anykey_released
	0A8C 21 C0 6F       LD HL,6FC0											; buffer to erase
	0A8F 1E FF          LD E,FF												; erase value = #FF
	0A91 01 0A 00       LD BC,000A											; 10 values
	0A94 CD 69 24       CALL Erase_block_val_in_E
ec_wait:
	0A97 CD F2 09       CALL Scan_keyboard 									; (returns A=0 if a key is pressed; also BC=F740)
	0A9A 20 FB          JR NZ,ec_wait
	0A9C 78             LD A,B
	0A9D FE 12          CP 12
	0A9F 28 23          JR Z,ec_1
ec_0:
	0AA1 79             LD A,C
	0AA2 A6             AND (HL)
	0AA3 BE             CP (HL)
	0AA4 77             LD (HL),A
	0AA5 28 F0          JR Z,ec_wait
	0AA7 CD 2C 0A       CALL GetCharStrId
	0AAA CD EC 0A       CALL PrintCharAttr2									; clear end of line
	0AAD 2A BE 4A       LD HL,(Char_cursor_pixel_position)
	0AB0 E5             PUSH HL
	0AB1 3E A5          LD A,A5												; String_ID A5 "Press Enter to finish"
	0AB3 CD C2 4A       CALL Print_String
	0AB6 CD 36 0A       CALL Wait_anykey_released
	0AB9 E1             POP HL
	0ABA 22 BE 4A       LD (Char_cursor_pixel_position),HL
	0ABD 3E C0          LD A,C0
	0ABF 95             SUB L
	0AC0 FE 14          CP 14
	0AC2 30 D3          JR NC,ec_wait
ec_1:
	0AC4 D9             EXX
	0AC5 21 C0 6F       LD HL,6FC0											; buffer?
	0AC8 3E FF          LD A,FF
	0ACA 06 0A          LD B,0A												; 10 scan lines??
ec_1_loop:
	0ACC BE             CP (HL)
	0ACD 23             INC HL
	0ACE 20 07          JR NZ,ec_2
	0AD0 10 FA          DJNZ ec_1_loop
	0AD2 D9             EXX
	0AD3 3E 12          LD A,12
	0AD5 18 CA          JR ec_0

ec_2:
	0AD7 E1             POP HL
	0AD8 01 08 00       LD BC,0008
	0ADB 3E 0A          LD A,0A
	0ADD 11 C0 6F       LD DE,6FC0 											; buffer
ec_3:
	0AE0 08             EX AF,AF
	0AE1 1A             LD A,(DE)
	0AE2 77             LD (HL),A
	0AE3 13             INC DE
	0AE4 09             ADD HL,BC
	0AE5 08             EX AF,AF
	0AE6 3D             DEC A
	0AE7 20 F7          JR NZ,ec_3
	0AE9 C3 36 0A       JP Wait_anykey_released

;; -----------------------------------------------------------------------------------------------------------
;; This is used on the "Select the keys" Menu;
;; Note that some of the keys have an attribute attached to them
;;     (eg. Char Id #8C = "|RETURN").
;; But most keys do not have an attribute attached, so this function
;; will attached a color attribute.
;;   #83 (yellow on that page) for the arrows, the numbers, the dot.
;;        (ie. all keyboard scanline 0 & 1, plus the "4" on scanline 2)
;;   #82 (darkblue) for anything else (again, except if they have an
;;       attribute attached)
;; Input: B = Key scan code index in Char_Set array
;;        A = corresponding printable Character
;; Output: None
.PrintCharAttr2:
	0AEC F5             PUSH AF												; save printable character
	0AED 78             LD A,B												; get key code
	0AEE FE 14          CP 14												; compare it with #14 (key code for "4" on keyboard scan line 2)
	0AF0 28 06          JR Z,pca2_1											; if keycode = #14 goto pca2_1 (use color attribute #83), else:
	0AF2 FE 10          CP 10												; compare A >= #10 (scan lines 2 and above)
	0AF4 3E 82          LD A,82												; default attribute #82
	0AF6 30 02          JR NC,pca2_2										; if A >= #10 goto pca2_2 (use attribute color #82 for anything on scan lines 2 and above), else:
pca2_1:																		; scan lines 0 and 1 (arrows, numbers (except "4"), ".")
	0AF8 3E 83          LD A,83												; use color attribute #83
pca2_2:
	0AFA CD C2 4A       CALL Print_String									; Apply the color attribute
	0AFD F1             POP AF												; get back the printable character and print it
	0AFE C3 C2 4A       JP Print_String										; Print; will RET

;; -----------------------------------------------------------------------------------------------------------
;; Read user inputs, scan the keyboard and returns A so that
;; from MSb to LSb (active low bits):
;; 		bit7:Carry, Fire, Swop, Left, Right, Down, Up, bit0: Jump
.Get_user_inputs:
	0B01 CD 3F 0B       CALL Keyboard_scanning_setup						; setup "PSG" for keyboard scanning
	0B04 0E 40          LD C,40												; keyboard scan line 0
	0B06 3E FF          LD A,FF												; init map code A=FF
	0B08 21 A2 09       LD HL,Array_Key_map									; point on Array_Key_map array
	0B0B 08             EX AF,AF											; save init map code
gui_0:
	0B0C 06 F6          LD B,F6												; Set PSG for Read reg BC=F640 (to read keyboard)
	0B0E ED 49          OUT (C),C
	0B10 06 F4          LD B,F4												; BC=F4xx
	0B12 ED 58          IN E,(C)											; Read PSG reg E=key scan current line
	0B14 06 08          LD B,08												; need to test each bits in current line
gui_1:
	0B16 7E             LD A,(HL)											; get current keymap code
	0B17 B3             OR E												; if from reg read, a bit is 0: corresponding key pressed, else (not pressed) it"ll fill in the expected key code to "turn it off"
	0B18 FE FF          CP FF												; result is #FF : Result has been fully filled with 1s (nothing pressed)
	0B1A 3F             CCF													; Invert Carry bit (Carry set if nothing pressed, Carry reset if something pressed)
	0B1B CB 12          RL D												; rotate D Left and put Carry bit in D lowest bit
	0B1D 23             INC HL												; next keymap value
	0B1E 10 F6          DJNZ gui_1											; loop all 8 bits
	0B20 08             EX AF,AF											; restore A (collecting all the keys pressed)
	0B21 A2             AND D												; each bit of D will represent a function (up, down ...) active low; accumulate all the keys found.
	0B22 08             EX AF,AF											; save A
	0B23 0C             INC C												; next line
	0B24 79             LD A,C
	0B25 FE 4A          CP 4A												; until last line (#40 (scan line 0) + #0A (lastline+1))
	0B27 38 E3          JR C,gui_0											; loop next line
	0B29 08             EX AF,AF											; restore A : from MSb to LSb : Left, Right, Down, Up, Jump, Carry, Fire, Swop
	0B2A 0F             RRCA                    							; bits are not in the order we want (they are in key scan order)
	0B2B 0F             RRCA												; so rotate them 3x until we have:
	0B2C 0F             RRCA												; from MSb to LSb : Carry, Fire, Swop, Left, Right, Down, Up, Jump (active low)
	0B2D 18 25          JR Keyboard_scanning_ending							; end the keyboard scanning

;; -----------------------------------------------------------------------------------------------------------
;; Test if the "ESC" key has been pressed
;; Note : Line 8 bit 2 = "ESC" key
:: Output: A = 0 if "ESC" pressed; not-0 : "ESC" is not pressed.
.Keyboard_scanning_ESC:
	0B2F CD 3F 0B       CALL Keyboard_scanning_setup						; Setup keyboard scanning
	0B32 01 48 F6       LD BC,F648											; PortC, Read PSG reg, keyboard write, line select 8
	0B35 ED 49          OUT (C),C
	0B37 06 F4          LD B,F4												; PortA, Read keyboard Data
	0B39 ED 78          IN A,(C)											; Read Keyboard line value
	0B3B E6 04          AND 04												; test bit 2 of line 8; if 0 = Pressed else not pressed
	0B3D 18 15          JR Keyboard_scanning_ending							; End keyboard scanning

;; -----------------------------------------------------------------------------------------------------------
;; This will setup the PSG for keyboard scanning
.Keyboard_scanning_setup:
	0B3F F3             DI													; Disable Interrupt during keyboard scanning
	0B40 01 0E F4       LD BC,F40E											; select PSG reg14 (Keyboard Reg)
	0B43 ED 49          OUT (C),C
	0B45 01 00 F6       LD BC,F600											; prepare PSG Control (Keyboard feature)
	0B48 3E C0          LD A,C0												; line 0 + #C0
	0B4A ED 79          OUT (C),A											; PSG control : reg select (reg value on portA = reg14)
	0B4C ED 49          OUT (C),C											; Validate
	0B4E 04             INC B				 								; Port Control BC=F700
	0B4F 3E 92          LD A,92												; Port A in, Port C out
	0B51 ED 79          OUT (C),A											; Write config to PSG
	0B53 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This will end the keyboard scanning in the PSG
.Keyboard_scanning_ending:
	0B54 01 82 F7       LD BC,F782											; PortA (PSG DATA) as Output
	0B57 ED 49          OUT (C),C
	0B59 01 00 F6       LD BC,F600											; PSG inactive
	0B5C ED 49          OUT (C),C
	0B5E FB             EI													; Enable Interrupts
	0B5F C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This will configure all 11 "Sound related" register in the AY-3 (PSG)
;; The data must be placed in the AY_Registers array
.Write_AY3_Registers:
	0B60 21 A2 10       LD HL,AY_Registers
	0B63 16 00          LD D,00												; reg number
wa3r_1:
	0B65 5E             LD E,(HL)											; reg data
	0B66 23             INC HL												; point on next data
	0B67 CD 71 0B       CALL SubF_Write_AY3Reg
	0B6A 14             INC D												; next reg
	0B6B 7A             LD A,D
	0B6C FE 0B          CP 0B												; Last one?
	0B6E 20 F5          JR NZ,wa3r_1										; no: loop, else RET
	0B70 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Sub function for Write_AY3_Registers (write one AY-3 reg)
;; Input: D = reg number, E = value
.SubF_Write_AY3Reg:
	0B71 06 F4          LD B,F4												; prepare PSG Data
	0B73 ED 51          OUT (C),D											; reg number in D  (F4dd)
	0B75 01 00 F6       LD BC,F600											; prepare PSG Control
	0B78 3E C0          LD A,C0												; PSG Reg select
	0B7A ED 79          OUT (C),A											; control byte = reg select (F6C0)
	0B7C ED 49          OUT (C),C											; PSG Control (F600)
	0B7E 3E 80          LD A,80												; PSG reg Write
	0B80 06 F4          LD B,F4												; prepare PSG Data
	0B82 ED 59          OUT (C),E											; data in E  (F4ee)
	0B84 06 F6          LD B,F6												; prepare PSG Control
	0B86 ED 79          OUT (C),A											; control byte=reg write (F680)
	0B88 ED 49          OUT (C),C											; PSG Control (F600)
	0B8A C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This table will define the period value for the lowest octave
;; (octave 1, with the "standard A440 octave being 4).
;; The other octaves values are calculated from these base values
.Notes_periodes_Lowest_Octave:
	0B8B DATAWORD EE 0E 					; #0EEE=3822  Do octave=1 num=0    	32.7Hz (lowest Bass note on CPC)
    0B8D DATAWORD 18 0E						; #0E18=3608  Do#   oct=1 num=1    	34.6
	0B8F DATAWORD 4D 0D						; #0D4D=3405  Re    oct=1 num=2    	36.7
	0B91 DATAWORD 8E 0C						; #0C8E=3214  Re#   oct=1 num=3    	38.9
	0B93 DATAWORD DA 0B						; #0BDA=3034  Mi    oct=1 num=4    	41.2
	0B95 DATAWORD 2F 0B						; #0B2F=2863  Fa    oct=1 num=5    	43.6
	0B97 DATAWORD 8F 0A						; #0A8F=2703  Fa#   oct=1 num=6    	46.2
	0B99 DATAWORD F7 09						; #09F7=2551  Sol   oct=1 num=7    	49
	0B9B DATAWORD 68 09						; #0968=2408  Sol#  oct=1 num=8    	51.9
	0B9D DATAWORD E1 08						; #08E1=2273  La    oct=1 num=9    	55
	0B9F DATAWORD 61 08						; #0861=2145  La#   oct=1 num=0xA	58.3
	0BA1 DATAWORD E9 07						; #07E9=2025  Si    oct=1 num=0xB	61.7
	0BA3 DATAWORD 77 07						; #0777=1911  Do    oct=2 num=0xC	65.4

;; -----------------------------------------------------------------------------------------------------------
;; Check if (Voice0) Sound is enable (bit7=0; disable if 1)
;; If enabled, then play Theme song.
.Play_HoH_Tune:
	0BA5 3A 50 10       LD A,(Sound_Voice0_status)							; Get Sound_enable value for Voice0
	0BA8 FE 80          CP 80												; is sound enabled? bit7 active low
	0BAA C8             RET Z												; No, then leave; else play
	0BAB 06 C3          LD B,C3												; Sound_ID #C3 = HeadOverHeels main theme
	0BAD C3 91 0D       JP Play_Sound										; will RET

;; -----------------------------------------------------------------------------------------------------------
;; This will play some music by INTerrupts
.sub_IntH_play_update:
	0BB0 3A 54 10       LD A,(Sound_channels_enable)						; b7 = Sound_enable ; Sound Volume level/amount
	0BB3 17             RLA													; put b7 in Carry (Sound_Enable)
	0BB4 D0             RET NC												; if Sound not enabled, then leave
	0BB5 CD 53 0C       CALL Sound_Update
	0BB8 AF             XOR A												; set voice 0
	0BB9 32 53 10       LD (Current_sound_voice_number),A					; update current voice number
	0BBC 3E 3F          LD A,3F												; Disable all voices in mixer
	0BBE 32 A9 10       LD (AY_Registers+AY_MIXER),A						; reg7 is AY3_Mixer_control
	0BC1 21 53 10       LD HL,Current_sound_voice_number					; point on Current sound voice number
loop_play_tune:
	0BC4 46             LD B,(HL)											; B = voice number
	0BC5 CD 69 0C       CALL Get_sound_en_B_voice							; if the voice in B enabled?
	0BC8 38 53          JR C,play_tune_voice_skip							; if voice NOT enabled (Carry set), skip voice (play_tune_voice_skip), else:
	0BCA CD 9B 0E       CALL Get_current_Voice_data_in_HL
	0BCD E5             PUSH HL												; put data pointer...
	0BCE DD E1          POP IX												; ... in IX = Voice data array (19 bytes)
	0BD0 CB 6E          BIT 5,(HL)											; test bit5 of the first data
	0BD2 20 49          JR NZ,play_tune_voice_skip							; if bit5 not set, then skip (play_tune_voice_skip)
	0BD4 FD 21 A2 10    LD IY,AY_Registers									; IY points on AY_Registers
	0BD8 5F             LD E,A												; DE = current voice number (0, 1 or 2)
	0BD9 16 00          LD D,00
	0BDB D5             PUSH DE												; store current voice number
	0BDC CB 23          SLA E												; E*2
	0BDE FD 19          ADD IY,DE											; IY = AY_Registers pointer + offset by voice_number*2 (pitch regs)
	0BE0 21 AA 10       LD HL,AY_Registers+AY_A_VOL							; HL = reg8, Channel_A_Volume
	0BE3 D1             POP DE												; restore current voice number
	0BE4 19             ADD HL,DE											; HL now point on Channel_A_Volume, B or C depending on voice number
	;; IX : Voice_channel_<N>_data
	;; IY : AY_Registers + Channel offset (0, 1 ro 2)
	0BE5 DD 7E 08       LD A,(IX+SND_FINE)									; get fine pitch value from data array for curr channel A+offset (Channel Tone Frequency Low 8bits)
	0BE8 FD 77 00       LD (IY+AY_A_FINE),A									; set fine pitch value in reg array
	0BEB DD 7E 09       LD A,(IX+SND_COARSE)								; get coarse pitch value from data array (Channel Tone Frequency High 4bits)
	0BEE FD 77 01       LD (IY+AY_A_COARSE),A								; set coarse pitch value in reg array
	0BF1 42             LD B,D												; B = current voice number
	0BF2 DD 5E 01       LD E,(IX+SND_VOL_PTR_L)
	0BF5 DD 56 02       LD D,(IX+SND_VOL_PTR_H)								; DE = array[2] and [1] = volume array pointer
	0BF8 EB             EX DE,HL											; and put it in HL
	0BF9 DD 4E 03       LD C,(IX+SND_VOL_INDEX)								; get array[3] in C = volume array index
	0BFC 09             ADD HL,BC											; add it to HL
	0BFD EB             EX DE,HL											; and put it back in DE
	0BFE 1A             LD A,(DE)											; get current volume value
	0BFF E6 0F          AND 0F												; keep Bottom 4 bits only
	0C01 28 09          JR Z,lpt_1											; if value not 0 do this (else jump lpt_1)
	0C03 DD 86 0B       ADD A,(IX+SND_VOL_LEVEL)							; Add "volume addition" from array [11]
	0C06 FE 10          CP 10												; Compare A and #10
	0C08 38 02          JR C,lpt_1											; if A < #10 then:
	0C0A 3E 0F          LD A,0F												; clamp at #0F
lpt_1:
	0C0C 77             LD (HL),A											; write new value of volume into AYregister Channel_A_Volume, B or C depending on voice number
	0C0D 3A 53 10       LD A,(Current_sound_voice_number)					; get Current sound voice number
only_this_voice_bitmask:
	0C10 47             LD B,A
	0C11 04             INC B												; B now is the bit number corresponding to the current voice number (B=#01 means 1st bit therefore bit0)
	0C12 3E FF          LD A,FF												; set the init mask
	0C14 A7             AND A												; this clears the Carry
otvb_loop:
	0C15 17             RLA													; this will move a 0 bit at the location depending on the value in B (B=#01:A=#FE (bit 0 reset); B=#02:A=#FD (bit1 reset), etc.)
	0C16 10 FD          DJNZ otvb_loop										; loop B times
activate_current_voice:														; mask in A enable (active low) the current channel in the mixer
	0C18 21 A9 10       LD HL,AY_Registers+AY_MIXER							; reg7 is AY3_Mixer_control
	0C1B A6             AND (HL)											; Notes are active_low, so read and activate current voice (mask in A)
	0C1C 77             LD (HL),A											; and update mixer reg7 value
.play_tune_voice_skip:
	0C1D 21 53 10       LD HL,Current_sound_voice_number					; point on Current sound voice number
	0C20 3E 02          LD A,02
	0C22 BE             CP (HL)												; test if current voice is 2 (3rd one)
	0C23 CA 29 0C       JP Z,continue_tune									; Finish the 3 voices? if yes goto continue_tune
	0C26 34             INC (HL)											; next voice
	0C27 18 9B          JR loop_play_tune 									; (loop the 3 channels)

continue_tune:
	0C29 21 61 10       LD HL,Voice_channel_0_data							; points on current voice data array (19-bytes)
	0C2C 3E 08          LD A,08												; get value in current channel status flag reg ...
	0C2E AE             XOR (HL)											; and invert bit[3] for test
	0C2F E6 28          AND 28												; keep bits [5] and [3]; if voice0 first byte has "#20", write Sound state
	0C31 C2 60 0B       JP NZ,Write_AY3_Registers							; if flag bits [5] and [3] were not 0 and 0, Write_AY3_Registers, will RET, else:
	; else noise
	0C34 3A 54 10       LD A,(Sound_channels_enable)						; get Sound volume/amount
	0C37 1F             RRA													; bit0 goes in Carry
	0C38 DA 60 0B       JP C,Write_AY3_Registers							; if bit0 was 1, then Write_AY3_Registers (write sound state), will RET, else:
	0C3B 21 A8 10       LD HL,AY_Registers+AY_NOISE							; reg6 is AY3_Noise reg (5bits)
	0C3E FD 21 9A 10    LD IY,Voice_Noise_data								; IY = Voice_Noise_data (noise)
	0C42 FD 7E 07       LD A,(IY+07)										; get noise channel data IY[7]
	0C45 77             LD (HL),A											; update noise data in reg array
	0C46 23             INC HL												; point on next reg
	0C47 FD 7E 00       LD A,(IY+00)										; get noise channel data IY[0]
	0C4A E6 01          AND 01												; keep value of bit0
	0C4C B6             OR (HL)												; ????TODO if bit0 was set then copy value in HL and set b0 ?????
	0C4D E6 F7          AND F7												; enable noise Channel A gen (keep the other bits as they are)
	0C4F 77             LD (HL),A											; update reg value
	0C50 C3 60 0B       JP Write_AY3_Registers								; will RET

;; -----------------------------------------------------------------------------------------------------------
;; Run through all 3 voices. If a voice is enabled, call UpdateVoice.
.Sound_Update:
	0C53 AF             XOR A												; reset voice number to 0
	0C54 32 53 10       LD (Current_sound_voice_number),A					; update Current sound voice number
sound_Update_next_voice:
	0C57 47             LD B,A												; voice we want to check in B
	0C58 CD 69 0C       CALL Get_sound_en_B_voice							; voice in B enabled?
	0C5B D4 71 0C       CALL NC,Update_Voice								; Carry reset = voice enabled do Update_Voice, Carry set, do nothing
	0C5E 21 53 10       LD HL,Current_sound_voice_number					; point on Current sound voice number
	0C61 7E             LD A,(HL)											; A = current voice
	0C62 FE 02          CP 02												; is it 2 (last one)
	0C64 C8             RET Z												; if reached voiced 2 then RET
	0C65 3C             INC A												; else do it for next voice number
	0C66 77             LD (HL),A											; update Current_sound_voice_number
	0C67 18 EE          JR sound_Update_next_voice							; loop

;; -----------------------------------------------------------------------------------------------------------
;; Read the Nth bit from Sound_channels_enable into the Carry flag.
;; Bit is active low (enables if 0)
;; Input: B bit number we want to read from Sound_channels_enable.
;; Output: Carry value for that bit
.Get_sound_en_B_voice:
	0C69 3A 54 10       LD A,(Sound_channels_enable)						; A = Sound_enable, Sound volume/amount
	0C6C 04             INC B												; B is now bit_number current voice + 1, beacause to get bit nb 2 in Carry, we need to rotate right 3 times
gsebcv_loop:
	0C6D 0F             RRCA												; loop until the chosen voice...
	0C6E 10 FD          DJNZ gsebcv_loop									; ...Sound_Enable bit is in Carry flag
	0C70 C9             RET													; if Carry = reset then current voice enable, else if Carry set, voice disabled

;; -----------------------------------------------------------------------------------------------------------
.Update_Voice:
	0C71 21 53 10       LD HL,Current_sound_voice_number					point on Current sound voice number
	0C74 6E             LD L,(HL)
	0C75 11 5B 10       LD DE,curr_Voice_data_addr
	0C78 26 00          LD H,00												(H)L = current voice number
	0C7A 29             ADD HL,HL											*2
	0C7B 19             ADD HL,DE											add voice_num*2 offset to curr_Voice_data_addr
	0C7C 22 4E 10       LD (curr_Voice_data_pointer),HL						store curr_Voice_data_addr+voice_offset in curr_Voice_data_pointer (104E)
	0C7F 5E             LD E,(HL)
	0C80 23             INC HL
	0C81 56             LD D,(HL)											DE = data offset
	0C82 D5             PUSH DE
	0C83 DD E1          POP IX												and store it in IX
	0C85 CD 9B 0E       CALL Get_current_Voice_data_in_HL					add voice number * #13 as needed
	0C88 E5             PUSH HL
	0C89 FD E1          POP IY												Voice_channel<n>_data pointer in IY
	0C8B CB 4E          BIT 1,(HL)
	0C8D C2 33 0E       JP NZ,Sub_update_voice
	0C90 FD 35 0D       DEC (IY+SND_NOTE_DURATION)
	0C93 20 13          JR NZ,uvoi_1
	0C95 CD 74 0E       CALL Sound_Parse_data
	0C98 FD CB 00 5E    BIT 3,(IY+SND_FLAGS)
	0C9C C8             RET Z
	0C9D FD 21 9A 10    LD IY,Voice_Noise_data								(noise)
	0CA1 AF             XOR A
	0CA2 FD 77 03       LD (IY+03),A
	0CA5 C3 2A 0D       JP Func_0D2A

uvoi_1:
	0CA8 FD 35 04       DEC (IY+SND_CURR_FX_SLICE)							dec value in array [4] (its init value is in [5]
	0CAB CC 46 0D       CALL Z,Func_Sound_0D46
	0CAE FD 6E 08       LD L,(IY+SND_FINE)									read note period low byte
	0CB1 FD 66 09       LD H,(IY+SND_COARSE)								read note period high byte
	0CB4 FD CB 00 7E    BIT 7,(IY+SND_FLAGS)								test status flag bit7
	0CB8 28 2B          JR Z,sub_uvoi_2										if 0 jump sub_uvoi_2, else
	0CBA 3E 01          LD A,01
	0CBC FD CB 0C 7E    BIT 7,(IY+SND_EFFECT_TARGET)						test array [#C] bit 7
	0CC0 28 02          JR Z,uvoi_2											if 0 jump sub_uvoi_2 with A=1, else
	0CC2 3E FF          LD A,FF												-1
uvoi_2:
	0CC4 FD 86 0F       ADD A,(IY+SND_DELTA_COARSE)
	0CC7 FD 77 0F       LD (IY+SND_DELTA_COARSE),A							decrease the sound delta pitch high byte value in array[#F] (for bend or vibrato effect?)
	0CCA 47             LD B,A
	0CCB FD 7E 0C       LD A,(IY+SND_EFFECT_TARGET)							target value
	0CCE B8             CP B
	0CCF 20 07          JR NZ,uvoi_3
	0CD1 ED 44          NEG													A*(-1) (invert sign)
	0CD3 FD 77 0C       LD (IY+SND_EFFECT_TARGET),A							update
	0CD6 ED 44          NEG													A*(-1) (invert sign)
uvoi_3:
	0CD8 FD 5E 0E       LD E,(IY+SND_DELTA_FINE)							delta pitch low byte (sound) for effects (bend/vibrato)
	0CDB 16 00          LD D,00
	0CDD 07             RLCA
	0CDE 38 04          JR C,sub_uvoi_1
	0CE0 ED 52          SBC HL,DE
	0CE2 18 01          JR sub_uvoi_2

sub_uvoi_1:
	0CE4 19             ADD HL,DE											update sound pitch with delta pitch
sub_uvoi_2:
	0CE5 FD 7E 00       LD A,(IY+SND_FLAGS)									get status flag
	0CE8 E6 50          AND 50												look at bits 6 and 4
	0CEA FE 40          CP 40
	0CEC 20 29          JR NZ,sub_uvoi_3									if bits 6 and 4 were not resp. 1 and 0, jump (sound), else (noise)
	0CEE FD 5E 11       LD E,(IY+NOISE_DELTA_FINE)
	0CF1 FD 56 12       LD D,(IY+NOISE_DELTA_COARSE)						get noise delta pitch (for effects, bend/vibrato)
	0CF4 19             ADD HL,DE
	0CF5 54             LD D,H
	0CF6 5D             LD E,L
	0CF7 FD 4E 06       LD C,(IY+NOISE_FINE)
	0CFA FD 46 07       LD B,(IY+NOISE_COARSE)								and update noise pitch from it
	0CFD AF             XOR A
	0CFE ED 42          SBC HL,BC
	0D00 17             RLA
	0D01 FD AE 00       XOR (IY+SND_FLAGS)
	0D04 E6 01          AND 01
	0D06 EB             EX DE,HL
	0D07 20 0E          JR NZ,sub_uvoi_3
	0D09 FD CB 00 E6    SET 4,(IY+SND_FLAGS)
	0D0D AF             XOR A
	0D0E FD 77 0F       LD (IY+SND_DELTA_COARSE),A							sound delta pitch high byte = 0
	0D11 FD 6E 06       LD L,(IY+NOISE_FINE)
	0D14 FD 66 07       LD H,(IY+NOISE_COARSE)								HL = noise pitch
sub_uvoi_3:
	0D17 FD 75 08       LD (IY+SND_FINE),L
	0D1A FD 74 09       LD (IY+SND_COARSE),H								update note period
	0D1D FD CB 00 5E    BIT 3,(IY+SND_FLAGS)								test bit 3 of status flag
	0D21 C8             RET Z												leave if 0
	0D22 FD 21 9A 10    LD IY,Voice_Noise_data								else (noise array)
	0D26 FD 35 04       DEC (IY+SND_CURR_FX_SLICE)							decrease current effect delta index
	0D29 C0             RET NZ												ret if not 0, else:
.Func_0D2A:
	0D2A CD 46 0D       CALL Func_Sound_0D46
	0D2D A7             AND A
	0D2E 20 04          JR NZ,f_0a2a_1
	0D30 FD B6 03       OR (IY+SND_VOL_INDEX)								current index in volume array
	0D33 C0             RET NZ
f_0a2a_1:
	0D34 7E             LD A,(HL)
	0D35 E6 0F          AND 0F
	0D37 FD CB 00 7E    BIT 7,(IY+SND_FLAGS)								test bit7 of status flag
	0D3B 28 02          JR Z,f_0a2a_2
	0D3D ED 44          NEG													invert A sign (*(-1))
f_0a2a_2
	0D3F FD 86 06       ADD A,(IY+NOISE_FINE)								update noise pitch
	0D42 FD 77 07       LD (IY+NOISE_COARSE),A
	0D45 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.Func_Sound_0D46:
	0D46 FD 6E 01       LD L,(IY+SND_VOL_PTR_L)
	0D49 FD 66 02       LD H,(IY+SND_VOL_PTR_H)								HL = volume array pointer
	0D4C FD 5E 03       LD E,(IY+SND_VOL_INDEX)
	0D4F AF             XOR A
	0D50 57             LD D,A												DE = index in that array
	0D51 19             ADD HL,DE											point on the value at that index
	0D52 CB 7E          BIT 7,(HL)											test bit7 of the value
	0D54 20 1D          JR NZ,f_0d46_2										jump if bit7=1, else (bit7=0):
	0D56 CB 76          BIT 6,(HL)											test bit6
	0D58 28 13          JR Z,f_0d46_1										jump f_0d46_1 if 0, else:
	0D5A FD CB 00 56    BIT 2,(IY+SND_FLAGS)								test previous status flag bit2 state
	0D5E FD CB 00 D6    SET 2,(IY+SND_FLAGS)								and set it
	0D62 28 0C          JR Z,f_0d46_3										jump f_0d46_3 if was previously 0 else
	0D64 FD CB 00 96    RES 2,(IY+SND_FLAGS)								reset it
	0D68 FD 77 03       LD (IY+SND_VOL_INDEX),A								reset index value to 0
	0D6B 18 03          JR f_0d46_3											jump f_0d46_3

f_0d46_1:
	0D6D FD 34 03       INC (IY+SND_VOL_INDEX)								increase index in volume array
f_0d46_3:
	0D70 FD 7E 05       LD A,(IY+SND_NB_FX_SLICES)							get init value for (pitch effects? bend/vibrato)
f_0d46_2:
	0D73 FD 77 04       LD (IY+SND_CURR_FX_SLICE),A							update value for (pitch effects? bend/vibrato)
	0D76 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Disable_current_voice : Disable current sound voice
;; Disable_sound_bit : Disable sound voice, number in B
.Disable_current_voice:
	0D77 21 50 10       LD HL,Sound_Voice0_status							; point on Sound_enable (Sound_Interrupt_data table)
	0D7A 3A 53 10       LD A,(Current_sound_voice_number)					; get Current sound voice number
	0D7D 5F             LD E,A
	0D7E 16 00          LD D,00
	0D80 19             ADD HL,DE											; HL + offset voicenum
	0D81 36 FF          LD (HL),FF											; put FF (disable)
	0D83 47             LD B,A
.Disable_sound_bit:															; Convert voice number to corresponding bit number
	0D84 04             INC B												; B = bit num for voice
	0D85 21 54 10       LD HL,Sound_channels_enable							; pointer on Sound_enable ; HL = addr on Sound volume/amount
	0D88 AF             XOR A												; A = 0
	0D89 37             SCF													; Set Carry
dsb_loop:
	0D8A 17             RLA													; Carry in b0 ; (b7 in carry)
	0D8B 10 FD          DJNZ dsb_loop										; until voice number
	0D8D 47             LD B,A
	0D8E B6             OR (HL)												; "Or" the mask into SndEnable.
	0D8F 77             LD (HL),A											; update Sound_enable
	0D90 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.Play_Sound:																; B contains the sound Id to play.
	0D91 78             LD A,B												now A hold the Sound ID
	0D92 E6 3F          AND 3F												; Mask off 0x3F, and if value is 0x3F, (re)make it 0xFF.
	0D94 FE 3F          CP 3F												; 0x0?, 0x4?, 0x8? and 0xC? became 0x00 to 0x08
	0D96 20 02          JR NZ,play_sound_1									if sound ID [5:0] = #3F then make ID=#FF else goto play_Sound_1
	0D98 3E FF          LD A,FF
play_sound_1:
	0D9A 4F             LD C,A												C = 0 to 8 or #FF
	0D9B 78             LD A,B												get back Sound_ID and Put bits [7:6] ...
	0D9C 07             RLCA
	0D9D 07             RLCA
	0D9E E6 03          AND 03												... in bits [1:0], clearing the other bits
	0DA0 47             LD B,A
	0DA1 FE 03          CP 03												Sound_ID was 0xC<?> ?
	0DA3 28 46          JR Z,Play_Sound_group_3								if it was, then jump Play_Sound_group_3, else:
	0DA5 21 50 10       LD HL,Sound_Voice0_status							point on Sound_enable (Sound_Interrupt_data table)
	0DA8 58             LD E,B												B = voice num?
	0DA9 16 00          LD D,00												DE = voice num or ???? Sound group 0 (0x00-0x08), 1 (0x40-0x48) or 2 (0x80-0x88) as offset
	0DAB 19             ADD HL,DE											Sound_Voice0_status+offset (0,1,2)
	0DAC 7E             LD A,(HL)
	0DAD B9             CP C												C = 0 to 8 or #FF
	0DAE C8             RET Z
	0DAF FE 80          CP 80
	0DB1 C8             RET Z
	0DB2 71             LD (HL),C
	0DB3 79             LD A,C
	0DB4 3C             INC A
	0DB5 28 CD          JR Z,Disable_sound_bit
	0DB7 21 4C 12       LD HL,Sound_Groups									pointer on Sound_Groups
	0DBA CB 23          SLA E
	0DBC 19             ADD HL,DE
	0DBD 7E             LD A,(HL)
	0DBE 23             INC HL
	0DBF 66             LD H,(HL)
	0DC0 6F             LD L,A
	0DC1 59             LD E,C
	0DC2 CB 23          SLA E
	0DC4 19             ADD HL,DE
	0DC5 7E             LD A,(HL)
	0DC6 23             INC HL
	0DC7 66             LD H,(HL)
	0DC8 6F             LD L,A
	0DC9 E5             PUSH HL
	0DCA 21 55 10       LD HL,Channels_voice_data_ptr						Pointer to voice data Channel0
	0DCD 58             LD E,B
	0DCE CB 23          SLA E
	0DD0 19             ADD HL,DE
	0DD1 E5             PUSH HL
	0DD2 78             LD A,B
	0DD3 CD 9E 0E       CALL Get_Voice_data_in_HL
	0DD6 54             LD D,H
	0DD7 5D             LD E,L
	0DD8 47             LD B,A
	0DD9 CD 84 0D       CALL Disable_sound_bit
	0DDC 78             LD A,B
	0DDD E1             POP HL
	0DDE C1             POP BC
	0DDF 71             LD (HL),C
	0DE0 23             INC HL
	0DE1 70             LD (HL),B
	0DE2 EB             EX DE,HL
	0DE3 CB CE          SET 1,(HL)
	0DE5 21 54 10       LD HL,Sound_channels_enable							HL = addr on Sound volume/amount
	0DE8 AE             XOR (HL)
	0DE9 77             LD (HL),A
	0DEA C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; HQ sound : 3-voice sounds
.Play_Sound_group_3:
	0DEB 26 00          LD H,00
	0DED 69             LD L,C												HL=sound num in 0xC<num> group
	0DEE 29             ADD HL,HL											*2
	0DEF 54             LD D,H
	0DF0 5D             LD E,L												DE=HL
	0DF1 29             ADD HL,HL											*4
	0DF2 19             ADD HL,DE											; HL = C * 6 (offset of 6 bytes = 3 * DATAWORDs)
	0DF3 11 11 11       LD DE,Sound_High_table								Sound_High_table
	0DF6 19             ADD HL,DE											; Set HL to Sound_High_table + C * 6
	;; Read voice data pointer for next voice, push that and
    ;; updated Sound_High_table pointer.
	0DF7 3E 03          LD A,03												; For each voice...
psid_3_loop:
	0DF9 5E             LD E,(HL)
	0DFA 23             INC HL
	0DFB 56             LD D,(HL)
	0DFC 23             INC HL												get next DATAWORD in DE
	0DFD D5             PUSH DE
	0DFE E5             PUSH HL
	;; Get voice into HL.
	0DFF 3D             DEC A
	0E00 CD 9E 0E       CALL Get_Voice_data_in_HL
	;; Bring Sound_High_table pointer back into DE, push voice pointer.
	0E03 D1             POP DE
	0E04 E5             PUSH HL
	;; HST pointer back in HL
	0E05 EB             EX DE,HL
	0E06 A7             AND A
	0E07 20 F0          JR NZ,psid_3_loop
	;; Now we have 3 data/state pairs pushed on the stack.
    ;; Set bits [012] of SndEnable, to disable interrupt-driven
    ;; update while we modify.
	0E09 21 54 10       LD HL,Sound_channels_enable
	0E0C 3E 07          LD A,07
	0E0E B6             OR (HL)
	0E0F 77             LD (HL),A
	;; Load $80 into the 3 elements of the IntSnd array.
	0E10 21 50 10       LD HL,Sound_Voice0_status							point on Sound_enable (Sound_Interrupt_data table)
	0E13 01 80 03       LD BC,0380											write 3 times #80 from 1050 (Sound_Interrupt_data)
	0E16 78             LD A,B
psid_31:
	0E17 71             LD (HL),C
	0E18 23             INC HL
	0E19 10 FC          DJNZ psid_31
	;; At this point the Stack has 3 pairs saved in it:
	;; pointer on Voice_channel_0_data, pointer on Voice_data_C?_V2
	;; pointer on Voice_channel_1_data, pointer on Voice_data_C?_V1
	;; pointer on Voice_channel_2_data, pointer on Voice_data_C?_V0
	0E1B 21 55 10       LD HL,Channels_voice_data_ptr
psid_32:
	0E1E D1             POP DE												; pointer Voice_channel<n>_data
	0E1F C1             POP BC												; pointer Voice_data_C<s>_V<n>
	0E20 71             LD (HL),C
	0E21 23             INC HL
	0E22 70             LD (HL),B
	0E23 23             INC HL												Save Voice_data_C<s>_V<n> pointer in Channel<n>_voice_data_ptr
	; Set bit 1 in first byte of the voice structure.
	0E24 EB             EX DE,HL
	0E25 CB CE          SET 1,(HL)
	0E27 EB             EX DE,HL
	0E28 3D             DEC A
	0E29 20 F3          JR NZ,psid_32										loop for the 3 channels
	; And reset bits [012] of SndEnable, so they can be played.
	0E2B 21 54 10       LD HL,Sound_channels_enable
	0E2E 3E F8          LD A,F8
	0E30 A6             AND (HL)											reset bits [2:0] = activate 3 channels
	0E31 77             LD (HL),A											in Sound_channels_enable
	0E32 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Parse the first 2 bytes of the sound data:
;; The first byte [7:2] is the reference Note number, [1:0] the global volume level
;; where 0 is the lowest Do (octave 1, period #EEE)
;;  D0 : 110100 00 : #34|0 = num 52 : ref mi (octave 5)
;;  C3 : 110000 11 : #30|3 = num 48 : ref do (octave 5)
;;  C0 : 110000 00 : #30|0 = num 48 : ref do (octave 5)
;;  A8 : 101010 00 : #2A|0 = num 42 : ref fa# (octave 4)
;; The 2nd byte is (TODO) the volume/enveloppe: [7:4][3:0]
.Sub_update_voice:
	0E33 CD 4C 0E       CALL Get_sound_data_pointer_in_IX					; IX points on current voice data
	0E36 01 03 02       LD BC,0203											; B = 2 right shift ; C=03 mask
	0E39 CD 84 0F       CALL Read_IX_data_and_split							; read first byte and split at bit 2 (eg: #93=100100_11 gets D=#24 ; E=#03)
	0E3C FD 72 0A       LD (IY+SND_REF_NOTE),D								; reference Note number (eg. #24 = num 36 = Do octave 3)
	0E3F FD 73 0B       LD (IY+SND_VOL_LEVEL),E								; (main volume level)
	0E42 DD 23          INC IX												; next data
	0E44 CD 93 0F       CALL Slice_VolumeEnvp_Effects						; select volume/enveloppe ????
	0E47 DD 23          INC IX												; next data (first note)
	0E49 C3 74 0E       JP Sound_Parse_data									; continue parsing sound data at 3rd byte

;; -----------------------------------------------------------------------------------------------------------
;; Get the pointer on sound data in IX
.Get_sound_data_pointer_in_IX:
	0E4C 2A 4E 10       LD HL,(curr_Voice_data_pointer)						; get curr_Voice_data_pointer
	0E4F 11 FA FF       LD DE,FFFA											; -6 (from index in "curr_Voice_data_addr", points on same index in "Channels_voice_data_ptr")
	0E52 19             ADD HL,DE											; point on current voice in Channels_voice_data_ptr
	0E53 5E             LD E,(HL)
	0E54 23             INC HL
	0E55 56             LD D,(HL)											; DE now points on the current voice data; for exemple = Voice_data_C3_V2
	0E56 D5             PUSH DE
	0E57 DD E1          POP IX												; store it in IX (IX now points on current voice data)
	0E59 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; The function entry is "Sound_Parse_data"; it parses sound data from the 3rd byte
;; Sound data format from 3rd byte:
;; FF FF : disable voice
;; FF nn : envp nn?
;; FF 00 : loop from the start (2nd byte : read volume/envp)
;; byte [7:3] = note offset, [2:0] duration index (in Note_duration_array)
snd_parse_loop:
	0E5A CD 4C 0E       CALL Get_sound_data_pointer_in_IX					; Get the pointer on current sound data in IX
	0E5D DD 23          INC IX												; points on next sound data (volume/envp)
	0E5F 18 0E          JR snd_parse_vol_envp								; jump snd_parse_vol_envp

snd_parse_FF:																; if data byte was FF
	0E61 DD 23          INC IX												; point next sound data byte
	0E63 DD BE 00       CP (IX+00)											; test if byte is 00 (after a previous FF)
	0E66 28 F2          JR Z,snd_parse_loop									; if so, jump snd_parse_loop and restart from the begining, else:
	0E68 3D             DEC A												; A back to FF
	0E69 DD BE 00       CP (IX+00)											; test if FF (after a previous FF)
	0E6C CA 77 0D       JP Z,Disable_current_voice							; if so, goto Disable_current_voice (finished)
snd_parse_vol_envp:
	0E6F CD 93 0F       CALL Slice_VolumeEnvp_Effects						; FF <nn> (nn ni 00 ni FF) : enveloppe?
	0E72 DD 23          INC IX												; point next sound data
.Sound_Parse_data:
	0E74 FD CB 00 A6    RES 4,(IY+SND_FLAGS)								; reset status flag bit4
	0E78 DD 7E 00       LD A,(IX+00)										; get sound data
	0E7B 3C             INC A												; test A=FF
	0E7C CA 61 0E       JP Z,snd_parse_FF									; if A was FF jump snd_parse_FF, else:
	;; get 3rd byte note offset (from ref) and duration
	0E7F 01 07 03       LD BC,0307											; B=3 right shifts; #07=mask for bits [2:0] : split at bit 3
	0E82 CD 84 0F       CALL Read_IX_data_and_split							; get data and split in 2 (at bit 3)
	0E85 4A             LD C,D												; C = D = note offset from ref note; E = note_duration_index
	0E86 21 B0 10       LD HL,Note_duration_array
	0E89 16 00          LD D,00
	0E8B 19             ADD HL,DE											; HL + note_duration_index
	0E8C 7E             LD A,(HL)											; A = duration_value
	0E8D FD 77 0D       LD (IY+SND_NOTE_DURATION),A							; write duration value in array[#0D]
	0E90 AF             XOR A												; A = 0
	0E91 B9             CP C												; test if C = 0 (note offset = 0 so curr note = ref note)
	0E92 20 17          JR NZ,Calc_Note_Ref_plus_Offset						; no, then Calc_Note_Ref_plus_Offset (will do Sound_Prepare_Next_Note), else:
	0E94 FD CB 00 EE    SET 5,(IY+SND_FLAGS)								; else set status flag bit 5
	0E98 C3 70 0F       JP Sound_Prepare_Next_Note							; Sound_Prepare_Next_Note ; will RET

;; -----------------------------------------------------------------------------------------------------------
;; Provides 2 functions:
;;  * Get_current_Voice_data_in_HL
;;  * Get_Voice_data_in_HL; in this case the desired voice number must be in A
;; Output : HL points on the Voice_channel<N>_data pointer corresponding
;;          to the desired voice number
.Get_current_Voice_data_in_HL:
	0E9B 3A 53 10       LD A,(Current_sound_voice_number)					; get Current sound voice number
.Get_Voice_data_in_HL:														; Get the 19-byte structure for the voice in A (0-2), into HL.
	0E9E 21 61 10       LD HL,Voice_channel_0_data 							; points on a 3*19-byte array for channels data pointers
	0EA1 A7             AND A												; test A
	0EA2 C8             RET Z												; if A=0 then HL=Voice_channel_0_data and RET, else, A > 0:
	0EA3 11 13 00       LD DE,0013											; DE = #13 = 19, size of data array
	0EA6 47             LD B,A												; B = voice number 1 or 2
gvd_loop:
	0EA7 19             ADD HL,DE											; update HL pointer on next channel data
	0EA8 10 FD          DJNZ gvd_loop										; loop once or twice until the corresponding voice
	0EAA C9             RET													; HL points now on the pointers or Voice_channel_1_data or Voice_channel_2_data

;; -----------------------------------------------------------------------------------------------------------
;; From the reference note in SND_REF_NOTE and the offset in C
;; calculate the current desired note.
.Calc_Note_Ref_plus_Offset:
	0EAB FD CB 00 AE    RES 5,(IY+SND_FLAGS)								; reset status flag bit 5 ("got note"??)
	0EAF FD 7E 0A       LD A,(IY+SND_REF_NOTE)								; get ref Note
	0EB2 81             ADD A,C												; refNote in A + noteOffset in C --> A=note ???????
	0EB3 01 0C FF       LD BC,FF0C											; B will be 0; C=12 because 12 notes in the chromatic scale (one full octave)
;; from the note number, get in B the octave number and the note number in
;; that octave. eg. #2A = 42 ; B=int(42/12)=3 (ie. octave 4) ; A=(42%12)=6
f0eab_1:
	0EB6 04             INC B												; B is the integer division result (octave value-1)
	0EB7 91             SUB C												; modulo: sub C until value goes negative
	0EB8 30 FC          JR NC,f0eab_1
	0EBA 81             ADD A,C												; add back last C that's been sub to get result of modulo
	0EBB 87             ADD A,A												; *2 (to get a word-aligned offset)
	0EBC 5F             LD E,A
	0EBD 16 00          LD D,00												; in DE
	0EBF 21 8B 0B       LD HL,Notes_periodes_Lowest_Octave
	0EC2 19             ADD HL,DE
	0EC3 5E             LD E,(HL)
	0EC4 23             INC HL
	0EC5 56             LD D,(HL)
	0EC6 23             INC HL												; get note pitch values as if in octave 1 (fa# get #0ABF)
	0EC7 4E             LD C,(HL)
	0EC8 23             INC HL
	0EC9 7E             LD A,(HL)											; get note+semitone pitch (octave1) in A(high byte);C(lowbyte)
	0ECA 04             INC B												; now B has the value of the octave we want
	0ECB 18 08          JR f0eab_2

f0eab_2loop:
	0ECD CB 3F          SRL A												; AC/2
	0ECF CB 19          RR C                                    			; for each octaves we divide the period by 2 (in other words, mult the freq by 2)
	0ED1 CB 3A          SRL D												; DE/2
	0ED3 CB 1B          RR E
f0eab_2:
	0ED5 10 F6          DJNZ f0eab_2loop									; (loop B times) this calculate the periode of the note for the octave we want
	;; for exemple at this point, ref note #24 + noteoffset = 6, gives
	;; note #2A = Fa# oct4; Fa# in oct1 has a period of #0ABF in DE
	;; (and Sol in oct1 has a period of #09F7 in "AC")
	;; B was 3 (so 4 loops where we divide DE and "AC" by 2 resulting in
	;; DE=#0151 (period of Fa# oct4); AC=#013E (period of Sol oct4)
	0ED7 47             LD B,A												; BC now has the value of the curr_note+semitone note
	0ED8 FD 7E 00       LD A,(IY+SND_FLAGS)									; set status flags
	0EDB E6 42          AND 42												; look bits 6 and 1
	0EDD FE 40          CP 40												; test if bit6 was 1 and bit1 was 0 (was it noise or sound)
	0EDF 20 08          JR NZ,f0eab_3										; if that was NOT the case (sound) jump f0eab_3, else (noise):
	0EE1 FD 73 06       LD (IY+NOISE_FINE),E								; was a noise pitch
	0EE4 FD 72 07       LD (IY+NOISE_COARSE),D								; save note periode in array[7] (high byte) and [6] (low byte)
	0EE7 18 06          JR f0eab_4

f0eab_3:																	; else it was a sound note
	0EE9 FD 73 08       LD (IY+SND_FINE),E									; save it in array [9] and [8], note pitch
	0EEC FD 72 09       LD (IY+SND_COARSE),D
f0eab_4:
	0EEF FD CB 00 7E    BIT 7,(IY+SND_FLAGS)								; test status flag bit7
	0EF3 28 27          JR Z,f0eab_5										; if it was 0, jump f0eab_5, else:
	;; is this to add a dotted note or extra-duration OR...
	;; OR would that be to cut the note duration in pieces to apply a
	;; enveloppe or volume modification across the full note duration
	0EF5 EB             EX DE,HL											; HL = current note
	0EF6 A7             AND A												; clear Carry
	0EF7 ED 42          SBC HL,BC											; get the difference between the current_note period and its following one in the scale
	0EF9 CB 3D          SRL L
	0EFB CB 3D          SRL L												; divide it by 4
	0EFD FD 7E 10       LD A,(IY+10)										; array [#10]
	0F00 A7             AND A												; test it (Z set if 0, S bit set if bit7=1, Neg and Carry reset)
	0F01 28 12          JR Z,f0eab_6										; if 0, then jump f0eab_6, else:
	0F03 67             LD H,A												; H=array[#10] L=notegap/4
	0F04 7D             LD A,L
	0F05 FA 10 0F       JP M,f0eab_7										; jump f0eab_7 if S flag (arry[#10] bit7) is set, else (H bit7=0):
f0eab_9:
	0F08 CB 0C          RRC H												; this will multiply A by 2 depending on
	0F0A 38 08          JR C,f0eab_8										; which is the first bit of H set
	0F0C 87             ADD A,A												; x2
	0F0D 18 F9          JR f0eab_9											; loop

f0eab_10:																	; Carry=0 if we arrive here
	0F0F 1F             RRA													; A parity/bit0 in Carry and A/2
f0eab_7:
	0F10 CB 0C          RRC H												; this will divide A by 2 until we reach the first
	0F12 30 FB          JR NC,f0eab_10										; bit set in H
f0eab_8:
	0F14 6F             LD L,A												; update value in L
f0eab_6:
	0F15 FD 75 0E       LD (IY+SND_DELTA_FINE),L							; store value in array[#E] (sound delta pitch for bend/vibrato effect)
	0F18 AF             XOR A
	0F19 FD 77 0F       LD (IY+SND_DELTA_COARSE),A							; put 0 in array[#F]
f0eab_5:
	0F1C FD 7E 00       LD A,(IY+SND_FLAGS)									; read status flag reg
	0F1F CB 77          BIT 6,A												; test bit6
	0F21 28 43          JR Z,f0eab_11										; if 0, jump f0eab_11, else:
	0F23 CB 4F          BIT 1,A												; test bit 1
	0F25 28 06          JR Z,f0eab_12										; if 0, jump f0eab_12, else:
	0F27 FD CB 00 E6    SET 4,(IY+SND_FLAGS)								; set status flag bit4
	0F2B 18 39          JR f0eab_11											; jump f0eab_11

f0eab_12:
	0F2D FD 6E 06       LD L,(IY+NOISE_FINE)
	0F30 FD 66 07       LD H,(IY+NOISE_COARSE)								; HL = noise note periode
	0F33 FD 5E 08       LD E,(IY+SND_FINE)
	0F36 FD 56 09       LD D,(IY+SND_COARSE)								; DE = sound note periode
	0F39 FD CB 00 1E    RR (IY+SND_FLAGS)									; flags shift right
	0F3D AF             XOR A												; A=0, Carry cleared
	0F3E ED 52          SBC HL,DE											; diff between noise and sound periods in HL
	0F40 FD CB 00 16    RL (IY+SND_FLAGS)									; flags shift left, but carry reset, so flag bit0 was cleared
	0F44 FD 4E 0D       LD C,(IY+SND_NOTE_DURATION)							; note duration
	0F47 1E 80          LD E,80												; put a "1" in bit7 to init
	0F49 06 08          LD B,08												; test up to 8 bits
f0eab_13:
	0F4B 7B             LD A,E												; A has a wandering "1", starting at bit7 downward
	0F4C A1             AND C												; test duration value
	0F4D 20 04          JR NZ,f0eab_14										; if found a 1 jump f0eab_14, else:
	0F4F CB 0B          RRC E												; move "1" bit to the right
	0F51 10 F8          DJNZ f0eab_13										; jump up to test next bit
f0eab_14:																	; we found the highest bit of duration set to 1, the 1 in A indicates which bit is it
	0F53 0F             RRCA												; A[0] goes in carry and A/2
	0F54 38 06          JR C,f0eab_15										; if bit0 of A was 1 jump f0eab_15, else:
	0F56 CB 2C          SRA H
	0F58 CB 1D          RR L												; divide HL (gap between noise and sound period) by 2
	0F5A 18 F7          JR f0eab_14											; until we reach the bit set in A

f0eab_15:
	0F5C FD 75 11       LD (IY+NOISE_DELTA_FINE),L
	0F5F FD 74 12       LD (IY+NOISE_DELTA_COARSE),H						; put result in array [#11] and [#12] (delta pitch for bend/vibrato effect)
	0F62 FD CB 00 A6    RES 4,(IY+SND_FLAGS)								; and reset status flag bit4
f0eab_11:
	0F66 FD 36 03 00    LD (IY+SND_VOL_INDEX),00							; init chosen volume array index
	0F6A FD 7E 05       LD A,(IY+SND_NB_FX_SLICES)							; put array[5] in ...
	0F6D FD 77 04       LD (IY+SND_CURR_FX_SLICE),A							; ... array[4]
.Sound_Prepare_Next_Note:
	0F70 FD CB 00 8E    RES 1,(IY+SND_FLAGS)								; reset status flag bit1
	0F74 DD E5          PUSH IX
	0F76 D1             POP DE												; sound data pointer in DE
	0F77 13             INC DE												; DE points on the next data for that voice
	0F78 2A 4E 10       LD HL,(curr_Voice_data_pointer)						; get which is the current curr_Voice_data_addr
	0F7B 73             LD (HL),E
	0F7C 23             INC HL
	0F7D 72             LD (HL),D											; and we save next data pointer it in the current curr_Voice_data_addr
	0F7E C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Split the byte in D in 2 nibbles, results in D and E.
;; Input: D = byte value to split											; ex:		DE=#6A
;; Output: D = high nibble value; E = low nibble value						; ex:		D=#06 ; E=#0A
.Get_nibbles_from_D_to_D_and_E:
	0F7F 01 0F 04       LD BC,040F											; B = 4 right shift, C = #0F mask)
	0F82 18 03          JR rnsplt_1											; will RET

;; -----------------------------------------------------------------------------------------------------------
;; Reads a byte of data pointed by IX and split in 2, depending on BC,
;; with B = bitnb where to split, C=bitmask.
;; Input: IX = Data pointer; B = number of right shift ; C = bitmask
;; Output D = high value; E = low value ; trucated depending on mask
;; Exemple:  (IX) data = #65 and BC=#37; then D=#0C and E=#05)
.Read_IX_data_and_split:
	0F84 DD 56 00       LD D,(IX+00)										; read the data again
rnsplt_1:
	0F87 7A             LD A,D												; put data byte to split it in A
	0F88 A1             AND C												; mask it to keep lower bits (if mask=#07, then bits [2:0] are kept)
	0F89 5F             LD E,A												; result in E
	0F8A 79             LD A,C												; A = bitmask
	0F8B 2F             CPL													; invert all bits of A, so inverted mask (if mask=#07, then invmask=#F8)
	0F8C A2             AND D												; get high part data (if invmask=#F8, then get data[7:3])
	0F8D 57             LD D,A												; put result in in D
rnsplt_loop:																; need to shift right so that the lsb bit od D is at bit0
	0F8E CB 0A          RRC D												; shift right (if B=3, then data[7:3] become data[4:0]
	0F90 10 FC          DJNZ rnsplt_loop									; loop
	0F92 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; IX : points on Data:  Voice_data_C?_V?
;; IY : points on channel sound object : Voice_channel_?_data
.Slice_VolumeEnvp_Effects:
	0F93 01 0F 04       LD BC,040F											; B = 4 right shifts; C = #0F mask which means split in two 4-bit nibbles
	0F96 CD 84 0F       CALL Read_IX_data_and_split							; Read (IX) and split : D = high nibble, E = low nibble
	0F99 3E 02          LD A,02
	0F9B FD A6 00       AND (IY+SND_FLAGS)									; only keep bit[1] from...
	0F9E FD 77 00       LD (IY+SND_FLAGS),A									; ... the status/flag byte in the Voice_channel<n>_data array
	0FA1 CB 52          BIT 2,D												; test bit 2 of high nibble in D
	0FA3 28 04          JR Z,f0fa9_1										; and effectively copy that bit (0 or 1)...
	0FA5 FD CB 00 F6    SET 6,(IY+SND_FLAGS)								; ...in the status/flags bit6, because b6 was reset before.
f0fa9_1:
	; this will check if the 2nd byte bits[5:4] are 0, then skip all this;
	; else if 1, 2 and 3, calc in A :
	; max(x;y) / min(x;y) and A bit[7] = '0' if x>=y else '1' if x<y with
	; x and y from the Voice_data_10AD, index being [5:4]-1
	0FA9 3E 03          LD A,03												; this is to look at the (IX) data bits [5:4] or high nibble in D [1:0]
	0FAB A2             AND D												; keep D[1:0] (data high nibble) only and test if value = 0
	0FAC 28 2E          JR Z,f0fdc_1										; if 0 then jump f0fdc_1, else D[1:0] is 1, 2 or 3
	0FAE D5             PUSH DE												; save DE (splited (IX) data byte (2nd byte of sound data))
	0FAF 3D             DEC A												; D[1:0] value-1 (new value can be 0, 1 or 2)
	0FB0 21 AD 10       LD HL,Voice_data_10AD								; points on ???? array
	0FB3 5F             LD E,A
	0FB4 16 00          LD D,00												; DE = A is the index in the Voice_data_10AD array
	0FB6 19             ADD HL,DE											; add offset
	0FB7 56             LD D,(HL)											; get data from this 3byte array
	0FB8 CD 7F 0F       CALL Get_nibbles_from_D_to_D_and_E					; split in 2 nibbles (eg.#81 gets D=#08 and E=#01)
	0FBB FD 73 0C       LD (IY+SND_EFFECT_TARGET),E							; store low nibble value in Voice_channel<n>_data array byte #C (12)
	0FBE 7A             LD A,D												; high nibble
	0FBF BB             CP E												; compare high nibble to low nibble
	0FC0 3E 00          LD A,00												; A = 0
	0FC2 28 10          JR Z,f0fd4_1										; if high byte was = low byte, then jump f0fd4_1
	0FC4 30 05          JR NC,f0fa9_2										; if high > low then jump f0fa9_2 (A=0, Carry=0), else:
	0FC6 7A             LD A,D
	0FC7 53             LD D,E												; swap D and E
	0FC8 5F             LD E,A
	0FC9 3E 80          LD A,80												; and set A to #80, Carry = 1
f0fa9_2:
	0FCB CB 1B          RR E												; put E parity in Carry and E/2, the previous Carry goes in E[7] (1 if we swapped high;low above)
	0FCD 38 04          JR C,f0fa9_3										; if E was Odd then jump f0fa9_3, else if Even:
	0FCF CB 0A          RRC D												; divide high by 2
	0FD1 18 F8          JR f0fa9_2											; and loop

f0fa9_3:
	0FD3 B2             OR D
	;; from the values in 10AD we seem to get at this point: A = max(D;E) / min(D;E) and A bit[7] = '0' if D>=E else '1' if D<E
	;; (can also be 0 if all this was skipped)
	;; 8|1 : D=8; E=0; A=8 		(8/1 = 8 and A bit[7] = 0 : D>=E)
	;; 4|2 : D=2; E=0; A=2 		(4/2 = 2 and A bit[7] = 0 : D>=E)
	;; 4|8 : D=2; E=#20; A=#82 	(8/4 = 2 and A bit[7] = 1 : D<E)
f0fd4_1:
	0FD4 FD 77 10       LD (IY+10),A										; store that computed A value in array[#10]
	0FD7 FD CB 00 FE    SET 7,(IY+SND_FLAGS)								; and set bit7 of the status/flags
	0FDB D1             POP DE												; restore DE (splited 2nd data byte)
f0fdc_1:
	0FDC 21 BE 10       LD HL,Voice_data_10BE								; points on 10BE array
	0FDF 16 00          LD D,00
	0FE1 19             ADD HL,DE											; add 2nd byte low nibble as an offset
	0FE2 56             LD D,(HL)											; and get corresponding data (eg. E=#05 get D=#12)
	0FE3 CD 7F 0F       CALL Get_nibbles_from_D_to_D_and_E					; and split in 2 (eg; D=#12 gives D=#01; E=#02)
	0FE6 FD 72 05       LD (IY+SND_NB_FX_SLICES),D							; Store D (is a value from 1 to 4) in both array[5] (TODO: init/max number of volume effect parts)
	0FE9 FD 72 04       LD (IY+SND_CURR_FX_SLICE),D							; ... and array[4] (TODO: Current index volume effect)
	0FEC CD 3F 10       CALL Func_Sound_103F								; choose volume array (E offset from low byte of data from Voice_data_10BE, can be from 0 to 9)
	0FEF 3A 53 10       LD A,(Current_sound_voice_number)					; get Current sound voice number
	0FF2 A7             AND A
	0FF3 20 04          JR NZ,f0ff9_1										; if not 0 skip to f0ff9_1, else
	0FF5 FD CB 00 9E    RES 3,(IY+SND_FLAGS)								; if channel 0 : reset status/flag bit3
f0ff9_1:
	0FF9 DD CB 00 7E    BIT 7,(IX+00)										; test 2nd byte of sound data bit7
	0FFD C8             RET Z												; if 0, leave, else:
	0FFE DD 23          INC IX												; point on next data
	1000 A7             AND A												; test Current sound voice number
	1001 C0             RET NZ												; if not 0, leave; else:
	1002 FD CB 00 DE    SET 3,(IY+SND_FLAGS)								; set bit3 of status/flags
	1006 FD E5          PUSH IY												; save pointer on Sound "object"
	1008 FD 21 9A 10    LD IY,Voice_Noise_data								; Noise array
	100C DD 5E 00       LD E,(IX+00)
	100F 3E C0          LD A,C0
	1011 A3             AND E
	1012 07             RLCA
	1013 FD 77 00       LD (IY+SND_FLAGS),A
	1016 3E 0F          LD A,0F
	1018 A3             AND E
	1019 5F             LD E,A
	101A 21 B8 10       LD HL,Noise_data_10B8
	101D CB 03          RLC E
	101F 16 00          LD D,00
	1021 19             ADD HL,DE
	1022 56             LD D,(HL)
	1023 CD 7F 0F       CALL Get_nibbles_from_D_to_D_and_E
	1026 FD 72 04       LD (IY+SND_CURR_FX_SLICE),D
	1029 FD 72 05       LD (IY+SND_NB_FX_SLICES),D
	102C 23             INC HL
	102D 7E             LD A,(HL)
	102E FD 77 06       LD (IY+NOISE_FINE),A
	1031 CD 3F 10       CALL Func_Sound_103F
	1034 86             ADD A,(HL)
	1035 FD 77 07       LD (IY+NOISE_COARSE),A
	1038 AF             XOR A
	1039 FD 77 03       LD (IY+SND_VOL_INDEX),A
	103C FD E1          POP IY												; get back pointer on Sound "object"
	103E C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Input: E has the offset from the data [3:0] in table at 10BE (can be 0 to 9 from the sound data)
.Func_Sound_103F:
	103F 21 CE 10       LD HL,Voice_data_10CE								; points on 10CE array
	1042 16 00          LD D,00
	1044 19             ADD HL,DE											; add E as an offset
	1045 5E             LD E,(HL)											; get the offset value from that array
	1046 19             ADD HL,DE											; and add more offset
	1047 FD 75 01       LD (IY+SND_VOL_PTR_L),L								; final value go in array[1]
	104A FD 74 02       LD (IY+SND_VOL_PTR_H),H								; and array[2] (chosen volume array pointer)
	104D C9             RET

;; -----------------------------------------------------------------------------------------------------------
.curr_Voice_data_pointer:
	104E DATAWORD 00 00

Sound_Interrupt_data:
Sound_Voice0_status:	1050 DATABYTE FF			; Voice0 : b7 = Sound_enable (active low) ; FF=nothing being played
Sound_Voice1_status:	1051 DATABYTE FF			; Voice1 : b7 = Sound_enable (active low) ; FF=nothing being played
Sound_Voice2_status:	1052 DATABYTE FF			; Voice2 : b7 = Sound_enable (active low) ; FF=nothing being played

;; -----------------------------------------------------------------------------------------------------------
Current_sound_voice_number:
	1053 DATABYTE 00														; Current voice id (0-2)
Sound_channels_enable:
	1054 DATABYTE C7           												; 11000111

.Channels_voice_data_ptr:
	1055 DATAWORD 00 00
	1057 DATAWORD 00 00
	1059 DATAWORD 00 00

.curr_Voice_data_addr:
	105B DATAWORD 00 00
	105D DATAWORD 00 00
	105F DATAWORD 00 00

;; -----------------------------------------------------------------------------------------------------------
;; Sound data format:
;;	* 1st byte: data[7:2] = reference note number ;
;;              data[1:0] = volume level (to increase general volume for channel)
;;	* 2nd byte: data[7:4] ; data[3:0]	: First volume/enveloppe/effect ????
;;		if bit[7] = 1 (noise) then read one more byte to get the envp for noise.
;;		then:
;;    		byte: data[7:3]=note offset from ref note ; data[2:0]=duration index
;;		or	byte =  FF + function:
;;					FF 00 : loop back from 2nd byte
;;					FF FF : end
;;					FF nn : new enveloppe
;;
;; note_duration_offset:  0  1  2  3  4  5  6  7
;;	    DATABYTE (hex)   01 02 04 06 08 0C 10 20
;;
;; Exemple:
;;	 D0 0E 6E 96 6E 56 FF 01 34 36 FF 0E 7C 6C 54 6E			; ID #41 = Market
;;	 47 FF FF
;;
;;	 55555555666666666666
;;	   # # #  # #  # # #
;;	 effggaabccddeffggaab		ref note = e (mi) octave 5
;;	 0123456789ABCDEF0123
;;
;;	 D0        110100 00	ref note num = #34 = 52 : reference note = mi (octave 5) ; volume level = 0 (no extra volume added to volume)
;;   0E		   0000 0111	volume / envp?
;;	 6E        01101 110	offset=#0D duration_index=blanche	note = fa (octave 6)
;;	 96        10010 110	offset=#12 duration_index=blanche	note = la# (octave 6)
;;	 6E        01101 110	offset=#0D duration_index=blanche	note = fa (octave 6)
;;	 56        01010 110	offset=#0A duration_index=blanche	note = re (octave 6)
;;	 FF 01		new volume/envp 01
;;	 34        00110 100	offset=#06 duration_index=noire		note = la# (octave 5)
;;	 36        00110 110	offset=#06 duration_index=blanche	note = la# (octave 5)
;;	 FF 0E		new volume/envp 0E
;;	 7C        01111 100	offset=#0F duration_index=noire		note = sol (octave 6)
;;	 6C        01101 100	offset=#0D duration_index=noire		note = fa (octave 6)
;;	 54        01010 100	offset=#0A duration_index=noire		note = re (octave 6)
;;	 6E        01101 110	offset=#0D duration_index=blanche	note = fa (octave 6)
;;	 47        01000 111	offset=#08 duration_index=ronde		note = do (octave 6)
;;	 FF FF		end
;; -----------------------------------------------------------------------------------------------------------

;; -----------------------------------------------------------------------------------------------------------
;; Channel data to compute the AY3 registers ; 19 bytes per voice
;;  * SND_FLAGS 							: 0x00 : flags & status
;;  * SND_VOL_PTR_L, SND_VOL_PTR_L			: 0x01-0x02: Pointer to vol array
;;  * SND_VOL_INDEX							: 0x03: current Index into vol array
;;  * SND_CURR_FX_SLICE						: 0x04: ??? current value for (maybe) in how many parts the current note duration id cut to apply effects (bend/vibrato))
;;  * SND_NB_FX_SLICES						: 0x05: ??? init value for (maybe) in how many parts the current note duration id cut to apply effects (bend/vibrato))
;;  * NOISE_FINE, NOISE_COARSE	 			: 0x06-0x07: Noise fine and coarse pitch
;;  * SND_FINE, SND_COARSE					: 0x08-0x09: Sound fine and coarse pitch
;;  * SND_REF_NOTE							: 0x0A: Reference note number (first data byte [7:2]>>2)
;;  * SND_VOL_LEVEL							: 0x0B: Volume addition (first data byte [1:0])
;;  * 										: 0x0C:
;;  * SND_NOTE_DURATION 					: 0x0D: note duration
;;  * SND_DELTA_FINE, SND_DELTA_COARSE		: 0x0E-0x0F: Sound delta pitch (fine and coarse) for bend/vibrato effects
;;  * 										: 0x10:
;;  * NOISE_DELTA_FINE, NOISE_DELTA_COARSE	: 0x11-0x12: Noise delta pitch (fine and coarse) for bend/vibrato effects
.Voice_channel_0_data:
	;;             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F 10 11 12
	1061 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
.Voice_channel_1_data:
	1074 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
.Voice_channel_2_data:
	1087 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

;; -----------------------------------------------------------------------------------------------------------
.Voice_Noise_data:															; (noise)
	109A DATABYTE 00 00 00 00 00 00 00 00									; Voice_Noise_data+0 to Voice_Noise_data+7

;; -----------------------------------------------------------------------------------------------------------
;; AY-3-8912 registers:
;; AY_A_FINE:       EQU 00 ; Channel A fine pitch    8-bit (0-255)
;; AY_A_COARSE:     EQU 01 ; Channel A coarse pitch  4-bit (0-15)
;; AY_B_FINE:       EQU 02 ; Channel B fine pitch    8-bit (0-255)
;; AY_B_COARSE:     EQU 03 ; Channel B coarse pitch  4-bit (0-15)
;; AY_C_FINE:       EQU 04 ; Channel C fine pitch    8-bit (0-255)
;; AY_C_COARSE:     EQU 05 ; Channel C coarse pitch  4-bit (0-15)
;; AY_NOISE:        EQU 06 ; Noise pitch             5-bit (0-31)
;; AY_MIXER:        EQU 07 ; Mixer                   8-bit
;; AY_A_VOL:        EQU 08 ; Channel A volume        4-bit (0-15)
;; AY_B_VOL:        EQU 09 ; Channel B volume        4-bit (0-15)
;; AY_C_VOL:        EQU 0A ; Channel C volume        4-bit (0-15)
;; -----------------------------------------------------------------------------------------------------------
;; Registers AY_<A|B|C>_<FINE&COARSE>:
;; Note freq = 440 * (2^((Octave -4) - ((10-N) / 12))
;; 			with N the note (do=1, do#=2, ... la=10, la#=11, si=12)
;;			and with "Octave" from 1 to 8, where Octave=4 is the A (A4:440Hz) reference octave (La international ; octave 4).
;; Note Tone = (Chip_Clk / 16) / freq = (1MHz / 16) / freq = 62500 / freq
;; It is the note Tone that will be programmed in the fine&coarse pitch registers.
;; eg. Tenor Middle C (C3 = do octave 3) is programmed with a Tone of 478,
;; hence producing a frequency of 62500/478 =~ 131Hz.
;; To calculate the tone from the frequency of C3 (do octave 3) :
;; 		freq = 440 * 2^((3 - 4) - ((10-1) / 12)) = 440 * 2^(-1.75) =~ 440 * 0.2973 =~ 130.8 Hz
;;      Tone = 62500 / 130.8 =~ 478   =>  0x1DE    =>   fine = 0xDE, coarse = 0x01
;; -----------------------------------------------------------------------------------------------------------
;; Register AY_NOISE:
;; For noise : Freq =  (Chip_Clk / 16) / Note_periode = (1MHz / 16) / Note_periode = 62500 / Note_periode
;; where Note_periode is the value in AY_NOISE[4:0]
;; -----------------------------------------------------------------------------------------------------------
;; Register AY_MIXER:
;; Mixer : bit0, 1, 2 = Channel A, B, C Tone : enable (if '0') / disable (if '1')
;; 		   bit3, 4, 5 = Channel A, B, C Noise : enable (if '0') / disable (if '1')
;; 		   bit6 = I/O PortA direction (not for Sounds/Noise/Music)
;; -----------------------------------------------------------------------------------------------------------
;; Registers AY_<A|B|C>_VOL:
;; 		  bits [3:0] = Amplitude (volume)
;;		  bit[4] : '0' to use the value in bits[3:0]; '1' to use the Hardware Envelope registers
;;                 (here always '0' because it does Softawre-envp)
;; -----------------------------------------------------------------------------------------------------------
;; Other AY-3 registers:
;; This game will generate Software-Envelopes (ie. it won't use the Hardware registers
;; AY_ENVP_FINE (0B), AY_ENVP_COARSE (0C) and AY_ENVP_SHAPE (0D) but instead
;; will update the pitch registers, the volume or the duration to create sounds effects
;; like bends, vibratoes, etc.).
;; The register AY_IO_PORT (0E) is used for keyboard scanning, not for Sounds.
;; -----------------------------------------------------------------------------------------------------------

;; This array store the value to be written to the AY-3 PSG
.AY_Registers:																; 11 registers
	10A2 DATABYTE 00 00 00 00 00 00 00 3F 00 00 00

;; -----------------------------------------------------------------------------------------------------------
.Voice_data_10AD:
	10AD DATABYTE 81 42 48   												; this is 3 pairs of nibbles 8;1 4;2 4;8

;; -----------------------------------------------------------------------------------------------------------
;; Notes duration:
;; 000 : 1	triple croche (1/8 noire)
;; 001 : 2	double croche (1/4 noire)
;; ___ : 3	double croche pointée (3/8 noire) NOT USED!
;; 010 : 4	croche (1/2 noire)
;; 011 : 6	croche pointée (3/4 noire)
;; 100 : 8	Noire
;; 101 : 12	noire pointée (1.5 noires)
;; 110 : 16	Blanche (2 noires)
;; ___ : 24	Blanche pointée (3 noires) NOT USED!
;; 111 : 32	Ronde (4 noires)
.Note_duration_array:														; note_durations
    ;; note_duration_offset:   0  1  2  3  4  5  6  7
	10B0 DATABYTE             01 02 04 06 08 0C 10 20

;; -----------------------------------------------------------------------------------------------------------
;; These are probably the Volume Enveloppes
.Noise_data_10B8:
	10B8 DATABYTE 12 14 10 0C 36 00           								; TODO: Noise ENV; nibbles   1;2  1;4 1;0; 0;c 3;6  0;0

.Voice_data_10BE:
	10BE DATABYTE 22 10 42 11 24 12 41 16 25 13 34 17 26 44 29 18    		; TODO: Sound envp parts and effect number ; nibbles  42: 4 volume effect parts; index 2 in volume effect pointers array

.Voice_data_10CE: ;0  1  2  3  4  5  6  7  8  9								; TODO: Sound Volume effect pointers (offset pointer to volume (enveloppe) array)
	;    #10?? :  DE D8 DF E1 E4 F0 F4 FF 102 105
	10CE DATABYTE 10 09 0F 10 12 1D 20 2A 2C 2E
Voice_data_10D8:
	10D8 DATABYTE 04 05 07 09 0A 0B											; volume enveloppes effects per parts
	10DE DATABYTE 8C
	10DF DATABYTE 0C 08
	10E1 DATABYTE 04 01 80
	10E4 DATABYTE 08 00 0C 00 07 00 04 00 02 00 01 80
	10F0 DATABYTE 0C 0A 08 45
	10F4 DATABYTE 02 00 00 04 00 00 06 00 00 09 00
	10FF DATABYTE 0C 00 40
	1102 DATABYTE 08 0A 0C
	1105 DATABYTE 0C 0B 0A 09 08 07 06 05 04 03 02 81

;; -----------------------------------------------------------------------------------------------------------
;; Sounds ID 0x, 4x, 8x are 1 channel sounds
;; Sounds ID Cx are 3 channels sounds
;; -----------------------------------------------------------------------------------------------------------
;; Sound_ID_????				EQU 00			????????
;; Sound_ID_????				EQU 01			????????
;; Sound_ID_????				EQU 02			????????
;; Sound_ID_Didididip			EQU 03			Di di di dip
;; Sound_ID_GlooGlouGLou		EQU	04 			GlooGlouGLou
;; Sound_ID_Beep				EQU 05 			Beep
;;
;; Sound_ID_Blacktooth			EQU 40			Blacktooth
;; Sound_ID_Market				EQU 41			Market
;; Sound_ID_Egyptus				EQU 42			Egyptus
;; Sound_ID_Penitentiary		EQU 43			Penitentiary
;; Sound_ID_MoonBase			EQU 44			Moon base
;; Sound_ID_BookWorld			EQU 45			BookWorld
;; Sound_ID_Safari				EQU 46			Safari
;; Sound_ID_Teleport_waiting	EQU 47 			Teleport waiting
;; Sound_ID_Donut_Firing		EQU 48 			Donut firing
;;
;; Sound_ID_Walking				EQU 80 			Walking
;; Sound_ID_Running				EQU 81 			Running
;; Sound_ID_Desc_seq			EQU 82 			(descending sequence - faster)
;; Sound_ID_Falling				EQU 83 			Fall
;; Sound_ID_Rise_seq			EQU 84 			(Repeated rising sequence)
;; Sound_ID_Higher_Blip			EQU 85 			(higher blip)
;; Sound_ID_High_Blip			EQU 86 			(high blip)
;; Sound_ID_Sweep_Tri			EQU 87 			(sweep down and up)
;; Sound_ID_Menu_Blip			EQU 88 			Menu blip
;;
;; Sound_ID_Silence				EQU C0 			Silence
;; Sound_ID_Tada				EQU C1 			"Tada!"
;; Sound_ID_Hornpipe			EQU C2 			Hornpipe
;; Sound_ID_Theme				EQU C3 			HoH theme music
;; Sound_ID_Nope				EQU C4 			"Nope!" (can't swop)
;; Sound_ID_DumDiddyDum			EQU C5 			Dum-diddy-dum
;; Sound_ID_Death				EQU C6 			Death
;; Sound_ID_Teleport_Up			EQU C7 			Teleport up
;; Sound_ID_Teleport_Down		EQU C8 			Teleport down
;;
;; -----------------------------------------------------------------------------------------------------------
;; This array return the pointers on the 3 channels data per HQ Sound ID Cx
.Sound_High_table:									; Sound_group_3 ID 0xCx
	1111 DATABYTE 4A 13 4A 13 4A 13					; Sound ID#C0 Silence		Voice_data_Silence, Voice_data_Silence, Voice_data_Silence
	1117 DATABYTE BE 13 D2 13 E7 13					; Sound ID#C1 "Tada!"		Voice_data_C1_V0, Voice_data_C1_V1, Voice_data_C1_V2
	111D DATABYTE FC 13 18 14 34 14					; Sound ID#C2 Hornpipe 		Voice_data_C2_V0, Voice_data_C2_V1, Voice_data_C2_V2
	1123 DATABYTE 91 11 F4 11 28 12					; Sound ID#C3 HoH theme 	Voice_data_C3_V0, Voice_data_C3_V1, Voice_data_C3_V2
	1129 DATABYTE 34 12 3C 12 44 12					; Sound ID#C4 "Nope!" 		Voice_data_C4_V0, Voice_data_C4_V1, Voice_data_C4_V2
	112F DATABYTE 42 14 55 14 66 14					; Sound ID#C5 Dum-diddy-dum	Voice_data_C5_V0, Voice_data_C5_V1, Voice_data_C5_V2
	1135 DATABYTE 88 11 7B 11 69 11					; Sound ID#C6 Death 		Voice_data_C6_V0, Voice_data_C6_V1, Voice_data_C6_V2
	113B DATABYTE 47 11 51 11 5E 11					; Sound ID#C7 Teleport up 	Voice_data_C7_V0, Voice_data_C7_V1, Voice_data_C7_V2
	1141 DATABYTE 77 14 81 14 8E 14					; Sound ID#C8 Teleport down Voice_data_C8_V0, Voice_data_C8_V1, Voice_data_C8_V2

;; -----------------------------------------------------------------------------------------------------------
;; Sound/Music Data for HQ music ID (C7, C6, C3, C4, 3 voices V0 to V2).
.Voice_data_C7_V0:															; Sound ID #C7 Voice 0 Teleport up
	1147 DATABYTE A0 7C 30 3E FF 7B 5E FE FF FF
.Voice_data_C7_V1:															; Sound ID #C7 Voice 1 Teleport up
	1151 DATABYTE B8 7C 31 3E FF 7B 5E CE FF 52 AE FF FF
.Voice_data_C7_V2:															; Sound ID #C7 Voice 2 Teleport up
	115E DATABYTE C3 7C 30 3E FF FB 44 5E CE FF FF
.Voice_data_C6_V2:															; Sound ID #C6 Voice 2 Death
	1169 DATABYTE 93 00 95 6A 62 6A 7D 6D FF 82 C0 15 FF 03 8D 96 FF FF
.Voice_data_C6_V1:															; Sound ID #C6 Voice 1 Death
	117B DATABYTE 90 23 F5 CA C2 CA DD CD 05 5D 6E FF FF
.Voice_data_C6_V0:															; Sound ID #C6 Voice 0 Death
	1188 DATABYTE 60 03 07 06 05 A5 B6 FF FF
.Voice_data_C3_V0:															; Sound ID #C3 Voice 0 HoH theme
	1191 DATABYTE 90 41 31 91 95 97 84 94 FF 22 96 06 CE 06 FF 41
	11A1 DATABYTE 51 B1 B5 B7 A4 B4 FF 22 B6 06 CE 06 FF 41 59 B9
	11B1 DATABYTE BD BF AC BC FF 22 BE 06 F6 06 FF 41 31 91 95 97
	11C1 DATABYTE 84 94 FF 22 96 06 CE 06 FF 41 CA CD CF BC CC FF
	11D1 DATABYTE 22 CE 06 EE 06 FF 41 C9 F1 F3 03 C9 F1 F3 03 07
	11E1 DATABYTE C9 F1 F3 03 FF 55 F2 CA EA DA B2 CA BA 92 B2 A4
	11F1 DATABYTE 6A FF 00
.Voice_data_C3_V1:															; Sound ID #C3 Voice 1 HoH theme
	11F4 DATABYTE 62 08 36 56 6E 7E 86 7E 6E 56 36 56 6E 7E 86 7E
	1204 DATABYTE 6E 56 5E 7E 96 A6 AE A6 96 7E 36 56 6E 7E 86 7E
	1214 DATABYTE 6E 56 6E 8E A6 B6 BE B6 A6 8E 96 7E 6E 56 6E 7E
	1224 DATABYTE 86 8E FF 00
.Voice_data_C3_V2:															; Sound ID #C3 Voice 2 HoH theme
	1228 DATABYTE 93 05 34 94 54 B4 6C CC 7C DC FF 00
.Voice_data_C4_V0:															; Sound ID #C4 Voice 0 "Nope!"
	1234 DATABYTE 60 51 32 B5 55 32 FF FF
.Voice_data_C4_V1:															; Sound ID #C4 Voice 1 "Nope!"
	123C DATABYTE C0 51 92 CD 95 92 FF FF
.Voice_data_C4_V2:															; Sound ID #C4 Voice 2 "Nope!"
	1244 DATABYTE 60 51 92 6D 95 92 FF FF

;; -----------------------------------------------------------------------------------------------------------
;; Table of pointers on sound groups pointers!
.Sound_Groups:
	124C DATAWORD 76 12								; Sound_group0_pointer 1276  (Sound ID 0x0x)
	124E DATAWORD 64 12								; Sound_group1_pointer 1264  (Sound ID 0x4x)
	1250 DATAWORD 52 12								; Sound_group2_pointer 1252  (Sound ID 0x8x)

;; -----------------------------------------------------------------------------------------------------------
;; table of Sound data pointer for group 8x
.Sound_group2_pointer:;								 Sound ID #8x
	1252 DATAWORD 4E 13								; Voice_data_noise  80 Walking
	1254 DATAWORD 64 13								; Voice_data_ID81   81 Running
	1256 DATAWORD 74 13								; Voice_data_ID82   82 (descending sequence - faster)
	1258 DATAWORD 88 13								; Voice_data_ID83   83 Fall
	125A DATAWORD 94 13								; Voice_data_ID84   84 (Repeated rising sequence)
	125C DATAWORD A2 13								; Voice_data_ID85   85 (higher blip)
	125E DATAWORD A7 13								; Voice_data_ID86   86 (high blip)
	1260 DATAWORD AC 13								; Voice_data_ID87   87 (sweep down and up)
	1262 DATAWORD B7 13								; Voice_data_ID88   88 Menu blip

;; -----------------------------------------------------------------------------------------------------------
;; table of Sound data pointer for group 4x
.Sound_group1_pointer:;								 Sound ID #4x
	1264 DATAWORD 82 12								; Voice_data_ID40   40 Blacktooth
	1266 DATAWORD 8F 12								; Voice_data_ID41   41 Market
	1268 DATAWORD A2 12								; Voice_data_ID42   42 Egyptus
	126A DATAWORD C5 12								; Voice_data_ID43   43 Penitentiary
	126C DATAWORD E1 12								; Voice_data_ID44   44 Moon base
	126E DATAWORD F0 12								; Voice_data_ID45   45 Book world
	1270 DATAWORD 04 13								; Voice_data_ID46   46 Safari
	1272 DATAWORD 13 13								; Voice_data_ID47   47 Teleport waiting
	1274 DATAWORD 1C 13								; Voice_data_ID48   48 Donut firing

;; -----------------------------------------------------------------------------------------------------------
;; table of Sound data pointer for group 0x
.Sound_group0_pointer:;								 Sound ID #0x
	1276 DATAWORD 47 13								; Voice_data_ID00   00 ????????
	1278 DATAWORD 41 13								; Voice_data_ID01   01 ????????
	127A DATAWORD 5C 13								; Voice_data_ID02   02 ????????
	127C DATAWORD 30 13								; Voice_data_ID03   03 Didididip
	127E DATAWORD 25 13								; Voice_data_ID04   04 GlouGlouGlou
	1280 DATAWORD 3A 13								; Voice_data_ID05   05 Beep

;; -----------------------------------------------------------------------------------------------------------
;; Sounds data for 1 channel sounds 4x, 0x, 8x
.Voice_data_ID40:															; 40 Blacktooth
	1282 DATABYTE C0 0E 34 4E 5C 6C 74 6C 5E 44 26 FF FF
.Voice_data_ID41:															; 41 Market
	128F DATABYTE D0 0E 6E 96 6E 56 FF 01 34 36 FF 0E 7C 6C 54 6E
	129F DATABYTE 47 FF FF
.Voice_data_ID42:															; 42 Egyptus
	12A2 DATABYTE C3 03 94 8C 94 8C FF 26 76 FF 61 6A 72 8A FF 22
	12B2 DATABYTE 8A FF 03 94 8C 74 8C 94 AC A4 94 FF 26 8F FF 22
	12C2 DATABYTE 80 FF FF
.Voice_data_ID43:															; 43 Penitentiary
	12C5 DATABYTE 60 02 6C 96 04 96 8C 96 94 96 FF 0F 8C FF 01 AA
	12D5 DATABYTE FF 41 B2 FF 22 B4 FF 02 04 96 FF FF
.Voice_data_ID44:															; 44 Moon base
	12E1 DATABYTE A8 0F 35 35 55 6D 6E 04 55 56 04 35 36 FF FF
.Voice_data_ID45:															; 45 Book world
	12F0 DATABYTE 90 0E 0C 36 24 35 45 4E 44 4D 35 26 34 25 0D FF
	1300 DATABYTE 0E 27 FF FF
.Voice_data_ID46:															; 46 Safari
	1304 DATABYTE 40 02 36 0C 24 36 0C 24 34 4C 0C 4C 36 FF FF
.Voice_data_ID47:															; 47 Teleport waiting
	1313 DATABYTE F0 67 10 F6 06 16 07 FF FF
.Voice_data_ID48:															; 48 Donut firing
	131C DATABYTE 27 50 51 BB FF 5D 97 FF FF
.Voice_data_ID04:															; 04 GlouGlouGlou
	1325 DATABYTE 03 CA 44 F0 0F FF 8C 01 0C FF FF
.Voice_data_ID03:															; 03 Didididip
	1330 DATABYTE A0 40 30 6C 31 6C 41 6C FF FF
.Voice_data_ID05:															; 05 Beep
	133A DATABYTE B3 47 10 43 00 FF FF
.Voice_data_ID01:															; 01 ????????
	1341 DATABYTE 00 86 82 12 FF FF
.Voice_data_ID00:															; 00 ????????
	1347 DATABYTE 03 86 41
.Voice_data_Silence:														; Sound ID #C0 (Silence) V0,1 and 2
	134A DATABYTE 11 03 FF FF
.Voice_data_noise:															; 80 Walking
	134E DATABYTE D3 29 31 51 01 41 29 01 31 19 01 29 41 01
.Voice_data_ID02:															; 02 ????????
	135C DATABYTE FF 00 F3 EB E3 DB FF FF									; The "FF 00" is the end of "80 Walking"
.Voice_data_ID81:															; 81 Running
	1364 DATABYTE D3 09 31 51 00 41 29 00 31 19 00 29 41 00 FF 00
.Voice_data_ID82:															; 82 (descending sequence - faster)
	1374 DATABYTE D3 09 F3 EB E3 DB EB E3 DB D3 E3 DB D3 CB DB D3
	1384 DATABYTE CB C3 FF 00
.Voice_data_ID83:															; 83 Fall
	1388 DATABYTE D3 09 BB A3 8B 73 5B 43 2B 23 FF 00
.Voice_data_ID84:															; 84 (Repeated rising sequence)
	1394 DATABYTE D3 09 13 33 53 73 93 B3 D3 DB E3 EE FF 00
.Voice_data_ID85:															; 85 (higher blip)
	13A2 DATABYTE 78 05 33 FF FF
.Voice_data_ID86:															; 86 (high blip)
	13A7 DATABYTE 60 25 33 FF FF
.Voice_data_ID87:															; 87 (sweep down and up)
	13AC DATABYTE D3 60 34 6A FF 09 01 BA BA FF FF
.Voice_data_ID88:															; 88 Menu blip
	13B7 DATABYTE 90 44 10 43 00 FF FF

;; -----------------------------------------------------------------------------------------------------------
;; remaining data to HQ sounds C1, C2, C5, C8:
.Voice_data_C1_V0:															; Sound ID #C1 Voice 0 "Tada!"
	13BE DATABYTE 90 41 0C 36 FF 02 35 35 35 45 35 45 FF 41 56 FF
	13CE DATABYTE 21 57 FF FF
.Voice_data_C1_V1:															; Sound ID #C1 Voice 1 "Tada!"
	13D2 DATABYTE 90 41 0C 6E FF 02 6D 6D 6D 7D 6D 7D FF 41 D5 FF
	13E2 DATABYTE 21 D2 D7 FF FF
.Voice_data_C1_V2:															; Sound ID #C1 Voice 2 "Tada!"
	13E7 DATABYTE 90 41 0C E6 FF 02 B5 B5 B5 C5 B5 C5 FF 41 8D FF
	13F7 DATABYTE 21 8A 8F FF FF
.Voice_data_C2_V0:															; Sound ID #C2 Voice 0 Hornpipe
	13FC DATABYTE 63 02 B2 BA CC 34 34 6A 5A 52 6A 92 8A 94 C2 CA
	140C DATABYTE DC 44 44 A2 92 8A 92 8A 7A 6E FF FF
.Voice_data_C2_V1:															; Sound ID #C2 Voice 1 Hornpipe
	1418 DATABYTE C0 03 92 8A 94 34 54 6A 5A 52 6A 92 8A 94 8A 92
	1428 DATABYTE A4 44 64 A2 92 8A 92 8A 7A 6D FF FF
.Voice_data_C2_V2:															; Sound ID #C2 Voice 2 Hornpipe
	1434 DATABYTE 30 02 04 36 0E 56 36 46 1E 64 54 47 FF FF
.Voice_data_C5_V0:															; Sound ID #C5 Voice 0 Dum-diddy-dum
	1442 DATABYTE 33 43 09 33 FF 08 36 56 5E 66 6C 0C 04 FF 02 32
	1452 DATABYTE 37 FF FF
.Voice_data_C5_V1:															; Sound ID #C5 Voice 1 Dum-diddy-dum
	1455 DATABYTE F0 08 04 96 86 7E 76 6C 06 FF 41 94 FF 3E 97 FF
	1465 DATABYTE FF
.Voice_data_C5_V2:															; Sound ID #C5 Voice 2 Dum-diddy-dum
	1466 DATABYTE C0 22 04 96 86 7E 76 6C 06 FF 41 6C FF 2E 6F FF
	1476 DATABYTE FF
.Voice_data_C8_V0:															; Sound ID #C8 Voice 0 Teleport down
	1477 DATABYTE A0 7B F0 A6 5E FF 7C 3E FF FF
.Voice_data_C8_V1:															; Sound ID #C8 Voice 1 Teleport down
	1481 DATABYTE B8 7B C0 A6 5E FF 7C 3E FF 52 27 FF FF
.Voice_data_C8_V2:															; Sound ID #C8 Voice 2 Teleport down
	148E DATABYTE C3 FC 02 C0 A6 5E FF FB 44 3E FF FF

;; -----------------------------------------------------------------------------------------------------------
;; BlitMaskNofM does a masked blit into a dest buffer assumed 6 bytes wide.
;; The blit is from a source N bytes wide in a buffer M bytes wide.
;; The height is in B.
;; Destination is BC', source image is in DE', mask is in HL'.
.BlitMask1of3:
	149A D9             EXX
	149B 0A             LD A,(BC)
	149C A6             AND (HL)
	149D EB             EX DE,HL
	149E B6             OR (HL)
	149F 02             LD (BC),A
	14A0 04             INC B
	14A1 0A             LD A,(BC)
	14A2 B6             OR (HL)
	14A3 EB             EX DE,HL
	14A4 A6             AND (HL)
	14A5 02             LD (BC),A
	14A6 05             DEC B
	14A7 23             INC HL
	14A8 13             INC DE
	14A9 79             LD A,C
	14AA C6 06          ADD A,06
	14AC 4F             LD C,A
	14AD 23             INC HL
	14AE 13             INC DE
	14AF 23             INC HL
	14B0 13             INC DE
	14B1 D9             EXX
	14B2 10 E6          DJNZ BlitMask1of3
	14B4 C9             RET

.BlitMask2of3:
	14B5 D9             EXX
	14B6 0A             LD A,(BC)
	14B7 A6             AND (HL)
	14B8 EB             EX DE,HL
	14B9 B6             OR (HL)
	14BA 02             LD (BC),A
	14BB 04             INC B
	14BC 0A             LD A,(BC)
	14BD B6             OR (HL)
	14BE EB             EX DE,HL
	14BF A6             AND (HL)
	14C0 02             LD (BC),A
	14C1 05             DEC B
	14C2 0C             INC C
	14C3 23             INC HL
	14C4 13             INC DE
	14C5 0A             LD A,(BC)
	14C6 A6             AND (HL)
	14C7 EB             EX DE,HL
	14C8 B6             OR (HL)
	14C9 02             LD (BC),A
	14CA 04             INC B
	14CB 0A             LD A,(BC)
	14CC B6             OR (HL)
	14CD EB             EX DE,HL
	14CE A6             AND (HL)
	14CF 02             LD (BC),A
	14D0 05             DEC B
	14D1 23             INC HL
	14D2 13             INC DE
	14D3 79             LD A,C
	14D4 C6 05          ADD A,05
	14D6 4F             LD C,A
	14D7 23             INC HL
	14D8 13             INC DE
	14D9 D9             EXX
	14DA 10 D9          DJNZ BlitMask2of3
	14DC C9             RET

.BlitMask3of3:
	14DD D9             EXX
	14DE 0A             LD A,(BC)
	14DF A6             AND (HL)
	14E0 EB             EX DE,HL
	14E1 B6             OR (HL)
	14E2 02             LD (BC),A
	14E3 04             INC B
	14E4 0A             LD A,(BC)
	14E5 B6             OR (HL)
	14E6 EB             EX DE,HL
	14E7 A6             AND (HL)
	14E8 02             LD (BC),A
	14E9 05             DEC B
	14EA 0C             INC C
	14EB 23             INC HL
	14EC 13             INC DE
	14ED 0A             LD A,(BC)
	14EE A6             AND (HL)
	14EF EB             EX DE,HL
	14F0 B6             OR (HL)
	14F1 02             LD (BC),A
	14F2 04             INC B
	14F3 0A             LD A,(BC)
	14F4 B6             OR (HL)
	14F5 EB             EX DE,HL
	14F6 A6             AND (HL)
	14F7 02             LD (BC),A
	14F8 05             DEC B
	14F9 0C             INC C
	14FA 23             INC HL
	14FB 13             INC DE
	14FC 0A             LD A,(BC)
	14FD A6             AND (HL)
	14FE EB             EX DE,HL
	14FF B6             OR (HL)
	1500 02             LD (BC),A
	1501 04             INC B
	1502 0A             LD A,(BC)
	1503 B6             OR (HL)
	1504 EB             EX DE,HL
	1505 A6             AND (HL)
	1506 02             LD (BC),A
	1507 05             DEC B
	1508 23             INC HL
	1509 13             INC DE
	150A 79             LD A,C
	150B C6 04          ADD A,04
	150D 4F             LD C,A
	150E D9             EXX
	150F 10 CC          DJNZ BlitMask3of3
	1511 C9             RET

.BlitMask1of4:
	1512 D9             EXX
	1513 0A             LD A,(BC)
	1514 A6             AND (HL)
	1515 EB             EX DE,HL
	1516 B6             OR (HL)
	1517 02             LD (BC),A
	1518 04             INC B
	1519 0A             LD A,(BC)
	151A B6             OR (HL)
	151B EB             EX DE,HL
	151C A6             AND (HL)
	151D 02             LD (BC),A
	151E 05             DEC B
	151F 23             INC HL
	1520 13             INC DE
	1521 79             LD A,C
	1522 C6 06          ADD A,06
	1524 4F             LD C,A
	1525 23             INC HL
	1526 13             INC DE
	1527 23             INC HL
	1528 13             INC DE
	1529 23             INC HL
	152A 13             INC DE
	152B D9             EXX
	152C 10 E4          DJNZ BlitMask1of4
	152E C9             RET

.BlitMask2of4:
	152F D9             EXX
	1530 0A             LD A,(BC)
	1531 A6             AND (HL)
	1532 EB             EX DE,HL
	1533 B6             OR (HL)
	1534 02             LD (BC),A
	1535 04             INC B
	1536 0A             LD A,(BC)
	1537 B6             OR (HL)
	1538 EB             EX DE,HL
	1539 A6             AND (HL)
	153A 02             LD (BC),A
	153B 05             DEC B
	153C 0C             INC C
	153D 23             INC HL
	153E 13             INC DE
	153F 0A             LD A,(BC)
	1540 A6             AND (HL)
	1541 EB             EX DE,HL
	1542 B6             OR (HL)
	1543 02             LD (BC),A
	1544 04             INC B
	1545 0A             LD A,(BC)
	1546 B6             OR (HL)
	1547 EB             EX DE,HL
	1548 A6             AND (HL)
	1549 02             LD (BC),A
	154A 05             DEC B
	154B 23             INC HL
	154C 13             INC DE
	154D 79             LD A,C
	154E C6 05          ADD A,05
	1550 4F             LD C,A
	1551 23             INC HL
	1552 13             INC DE
	1553 23             INC HL
	1554 13             INC DE
	1555 D9             EXX
	1556 10 D7          DJNZ BlitMask2of4
	1558 C9             RET

.BlitMask3of4:
	1559 D9             EXX
	155A 0A             LD A,(BC)
	155B A6             AND (HL)
	155C EB             EX DE,HL
	155D B6             OR (HL)
	155E 02             LD (BC),A
	155F 04             INC B
	1560 0A             LD A,(BC)
	1561 B6             OR (HL)
	1562 EB             EX DE,HL
	1563 A6             AND (HL)
	1564 02             LD (BC),A
	1565 05             DEC B
	1566 0C             INC C
	1567 23             INC HL
	1568 13             INC DE
	1569 0A             LD A,(BC)
	156A A6             AND (HL)
	156B EB             EX DE,HL
	156C B6             OR (HL)
	156D 02             LD (BC),A
	156E 04             INC B
	156F 0A             LD A,(BC)
	1570 B6             OR (HL)
	1571 EB             EX DE,HL
	1572 A6             AND (HL)
	1573 02             LD (BC),A
	1574 05             DEC B
	1575 0C             INC C
	1576 23             INC HL
	1577 13             INC DE
	1578 0A             LD A,(BC)
	1579 A6             AND (HL)
	157A EB             EX DE,HL
	157B B6             OR (HL)
	157C 02             LD (BC),A
	157D 04             INC B
	157E 0A             LD A,(BC)
	157F B6             OR (HL)
	1580 EB             EX DE,HL
	1581 A6             AND (HL)
	1582 02             LD (BC),A
	1583 05             DEC B
	1584 23             INC HL
	1585 13             INC DE
	1586 79             LD A,C
	1587 C6 04          ADD A,04
	1589 4F             LD C,A
	158A 23             INC HL
	158B 13             INC DE
	158C D9             EXX
	158D 10 CA          DJNZ BlitMask3of4
	158F C9             RET

.BlitMask4of4:
	1590 D9             EXX
	1591 0A             LD A,(BC)
	1592 A6             AND (HL)
	1593 EB             EX DE,HL
	1594 B6             OR (HL)
	1595 02             LD (BC),A
	1596 04             INC B
	1597 0A             LD A,(BC)
	1598 B6             OR (HL)
	1599 EB             EX DE,HL
	159A A6             AND (HL)
	159B 02             LD (BC),A
	159C 05             DEC B
	159D 0C             INC C
	159E 23             INC HL
	159F 13             INC DE
	15A0 0A             LD A,(BC)
	15A1 A6             AND (HL)
	15A2 EB             EX DE,HL
	15A3 B6             OR (HL)
	15A4 02             LD (BC),A
	15A5 04             INC B
	15A6 0A             LD A,(BC)
	15A7 B6             OR (HL)
	15A8 EB             EX DE,HL
	15A9 A6             AND (HL)
	15AA 02             LD (BC),A
	15AB 05             DEC B
	15AC 0C             INC C
	15AD 23             INC HL
	15AE 13             INC DE
	15AF 0A             LD A,(BC)
	15B0 A6             AND (HL)
	15B1 EB             EX DE,HL
	15B2 B6             OR (HL)
	15B3 02             LD (BC),A
	15B4 04             INC B
	15B5 0A             LD A,(BC)
	15B6 B6             OR (HL)
	15B7 EB             EX DE,HL
	15B8 A6             AND (HL)
	15B9 02             LD (BC),A
	15BA 05             DEC B
	15BB 0C             INC C
	15BC 23             INC HL
	15BD 13             INC DE
	15BE 0A             LD A,(BC)
	15BF A6             AND (HL)
	15C0 EB             EX DE,HL
	15C1 B6             OR (HL)
	15C2 02             LD (BC),A
	15C3 04             INC B
	15C4 0A             LD A,(BC)
	15C5 B6             OR (HL)
	15C6 EB             EX DE,HL
	15C7 A6             AND (HL)
	15C8 02             LD (BC),A
	15C9 05             DEC B
	15CA 23             INC HL
	15CB 13             INC DE
	15CC 0C             INC C
	15CD 0C             INC C
	15CE 0C             INC C
	15CF D9             EXX
	15D0 10 BE          DJNZ BlitMask4of4
	15D2 C9             RET

.BlitMask1of5:
	15D3 D9             EXX
	15D4 0A             LD A,(BC)
	15D5 A6             AND (HL)
	15D6 EB             EX DE,HL
	15D7 B6             OR (HL)
	15D8 02             LD (BC),A
	15D9 04             INC B
	15DA 0A             LD A,(BC)
	15DB B6             OR (HL)
	15DC EB             EX DE,HL
	15DD A6             AND (HL)
	15DE 02             LD (BC),A
	15DF 05             DEC B
	15E0 23             INC HL
	15E1 13             INC DE
	15E2 79             LD A,C
	15E3 C6 06          ADD A,06
	15E5 4F             LD C,A
	15E6 23             INC HL
	15E7 13             INC DE
	15E8 23             INC HL
	15E9 13             INC DE
	15EA 23             INC HL
	15EB 13             INC DE
	15EC 23             INC HL
	15ED 13             INC DE
	15EE D9             EXX
	15EF 10 E2          DJNZ BlitMask1of5
	15F1 C9             RET

.BlitMask2of5:
	15F2 D9             EXX
	15F3 0A             LD A,(BC)
	15F4 A6             AND (HL)
	15F5 EB             EX DE,HL
	15F6 B6             OR (HL)
	15F7 02             LD (BC),A
	15F8 04             INC B
	15F9 0A             LD A,(BC)
	15FA B6             OR (HL)
	15FB EB             EX DE,HL
	15FC A6             AND (HL)
	15FD 02             LD (BC),A
	15FE 05             DEC B
	15FF 0C             INC C
	1600 23             INC HL
	1601 13             INC DE
	1602 0A             LD A,(BC)
	1603 A6             AND (HL)
	1604 EB             EX DE,HL
	1605 B6             OR (HL)
	1606 02             LD (BC),A
	1607 04             INC B
	1608 0A             LD A,(BC)
	1609 B6             OR (HL)
	160A EB             EX DE,HL
	160B A6             AND (HL)
	160C 02             LD (BC),A
	160D 05             DEC B
	160E 23             INC HL
	160F 13             INC DE
	1610 79             LD A,C
	1611 C6 05          ADD A,05
	1613 4F             LD C,A
	1614 23             INC HL
	1615 13             INC DE
	1616 23             INC HL
	1617 13             INC DE
	1618 23             INC HL
	1619 13             INC DE
	161A D9             EXX
	161B 10 D5          DJNZ BlitMask2of5
	161D C9             RET

.BlitMask3of5:
	161E D9             EXX
	161F 0A             LD A,(BC)
	1620 A6             AND (HL)
	1621 EB             EX DE,HL
	1622 B6             OR (HL)
	1623 02             LD (BC),A
	1624 04             INC B
	1625 0A             LD A,(BC)
	1626 B6             OR (HL)
	1627 EB             EX DE,HL
	1628 A6             AND (HL)
	1629 02             LD (BC),A
	162A 05             DEC B
	162B 0C             INC C
	162C 23             INC HL
	162D 13             INC DE
	162E 0A             LD A,(BC)
	162F A6             AND (HL)
	1630 EB             EX DE,HL
	1631 B6             OR (HL)
	1632 02             LD (BC),A
	1633 04             INC B
	1634 0A             LD A,(BC)
	1635 B6             OR (HL)
	1636 EB             EX DE,HL
	1637 A6             AND (HL)
	1638 02             LD (BC),A
	1639 05             DEC B
	163A 0C             INC C
	163B 23             INC HL
	163C 13             INC DE
	163D 0A             LD A,(BC)
	163E A6             AND (HL)
	163F EB             EX DE,HL
	1640 B6             OR (HL)
	1641 02             LD (BC),A
	1642 04             INC B
	1643 0A             LD A,(BC)
	1644 B6             OR (HL)
	1645 EB             EX DE,HL
	1646 A6             AND (HL)
	1647 02             LD (BC),A
	1648 05             DEC B
	1649 23             INC HL
	164A 13             INC DE
	164B 79             LD A,C
	164C C6 04          ADD A,04
	164E 4F             LD C,A
	164F 23             INC HL
	1650 13             INC DE
	1651 23             INC HL
	1652 13             INC DE
	1653 D9             EXX
	1654 10 C8          DJNZ BlitMask3of5
	1656 C9             RET

.BlitMask4of5:
	1657 D9             EXX
	1658 0A             LD A,(BC)
	1659 A6             AND (HL)
	165A EB             EX DE,HL
	165B B6             OR (HL)
	165C 02             LD (BC),A
	165D 04             INC B
	165E 0A             LD A,(BC)
	165F B6             OR (HL)
	1660 EB             EX DE,HL
	1661 A6             AND (HL)
	1662 02             LD (BC),A
	1663 05             DEC B
	1664 0C             INC C
	1665 23             INC HL
	1666 13             INC DE
	1667 0A             LD A,(BC)
	1668 A6             AND (HL)
	1669 EB             EX DE,HL
	166A B6             OR (HL)
	166B 02             LD (BC),A
	166C 04             INC B
	166D 0A             LD A,(BC)
	166E B6             OR (HL)
	166F EB             EX DE,HL
	1670 A6             AND (HL)
	1671 02             LD (BC),A
	1672 05             DEC B
	1673 0C             INC C
	1674 23             INC HL
	1675 13             INC DE
	1676 0A             LD A,(BC)
	1677 A6             AND (HL)
	1678 EB             EX DE,HL
	1679 B6             OR (HL)
	167A 02             LD (BC),A
	167B 04             INC B
	167C 0A             LD A,(BC)
	167D B6             OR (HL)
	167E EB             EX DE,HL
	167F A6             AND (HL)
	1680 02             LD (BC),A
	1681 05             DEC B
	1682 0C             INC C
	1683 23             INC HL
	1684 13             INC DE
	1685 0A             LD A,(BC)
	1686 A6             AND (HL)
	1687 EB             EX DE,HL
	1688 B6             OR (HL)
	1689 02             LD (BC),A
	168A 04             INC B
	168B 0A             LD A,(BC)
	168C B6             OR (HL)
	168D EB             EX DE,HL
	168E A6             AND (HL)
	168F 02             LD (BC),A
	1690 05             DEC B
	1691 23             INC HL
	1692 13             INC DE
	1693 0C             INC C
	1694 0C             INC C
	1695 0C             INC C
	1696 23             INC HL
	1697 13             INC DE
	1698 D9             EXX
	1699 10 BC          DJNZ BlitMask4of5
	169B C9             RET

.BlitMask5of5:
	169C D9             EXX
	169D 0A             LD A,(BC)
	169E A6             AND (HL)
	169F EB             EX DE,HL
	16A0 B6             OR (HL)
	16A1 02             LD (BC),A
	16A2 04             INC B
	16A3 0A             LD A,(BC)
	16A4 B6             OR (HL)
	16A5 EB             EX DE,HL
	16A6 A6             AND (HL)
	16A7 02             LD (BC),A
	16A8 05             DEC B
	16A9 0C             INC C
	16AA 23             INC HL
	16AB 13             INC DE
	16AC 0A             LD A,(BC)
	16AD A6             AND (HL)
	16AE EB             EX DE,HL
	16AF B6             OR (HL)
	16B0 02             LD (BC),A
	16B1 04             INC B
	16B2 0A             LD A,(BC)
	16B3 B6             OR (HL)
	16B4 EB             EX DE,HL
	16B5 A6             AND (HL)
	16B6 02             LD (BC),A
	16B7 05             DEC B
	16B8 0C             INC C
	16B9 23             INC HL
	16BA 13             INC DE
	16BB 0A             LD A,(BC)
	16BC A6             AND (HL)
	16BD EB             EX DE,HL
	16BE B6             OR (HL)
	16BF 02             LD (BC),A
	16C0 04             INC B
	16C1 0A             LD A,(BC)
	16C2 B6             OR (HL)
	16C3 EB             EX DE,HL
	16C4 A6             AND (HL)
	16C5 02             LD (BC),A
	16C6 05             DEC B
	16C7 0C             INC C
	16C8 23             INC HL
	16C9 13             INC DE
	16CA 0A             LD A,(BC)
	16CB A6             AND (HL)
	16CC EB             EX DE,HL
	16CD B6             OR (HL)
	16CE 02             LD (BC),A
	16CF 04             INC B
	16D0 0A             LD A,(BC)
	16D1 B6             OR (HL)
	16D2 EB             EX DE,HL
	16D3 A6             AND (HL)
	16D4 02             LD (BC),A
	16D5 05             DEC B
	16D6 0C             INC C
	16D7 23             INC HL
	16D8 13             INC DE
	16D9 0A             LD A,(BC)
	16DA A6             AND (HL)
	16DB EB             EX DE,HL
	16DC B6             OR (HL)
	16DD 02             LD (BC),A
	16DE 04             INC B
	16DF 0A             LD A,(BC)
	16E0 B6             OR (HL)
	16E1 EB             EX DE,HL
	16E2 A6             AND (HL)
	16E3 02             LD (BC),A
	16E4 05             DEC B
	16E5 23             INC HL
	16E6 13             INC DE
	16E7 0C             INC C
	16E8 0C             INC C
	16E9 D9             EXX
	16EA 10 B0          DJNZ BlitMask5of5
	16EC C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; When we need to draw pillar sprites below a Door, this is the height of the pillars.
;; In multiples of 6.
.PillarHeight:
	16ED DATABYTE 00

;; -----------------------------------------------------------------------------------------------------------
;; Re-fills the Pillar sprite buffer. Preserves 16b registers.
.FillPillarBuf:
	16EE D5             PUSH DE
	16EF C5             PUSH BC
	16F0 E5             PUSH HL
	16F1 3A ED 16       LD A,(PillarHeight)
	16F4 CD FE 16       CALL DrawPillarBuf
	16F7 E1             POP HL
	16F8 C1             POP BC
	16F9 D1             POP DE
	16FA C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Given a Pillar height in A, redraws the Pillar in PillarBuf.
;; Output: pointer on result sprite in DE.
.SetPillarHeight:
	16FB 32 ED 16       LD (PillarHeight),A									; PillarHeight
.DrawPillarBuf:
	16FE F5             PUSH AF												; preserve A
	16FF 21 98 B8       LD HL,PillarBuf
	1702 01 28 01       LD BC,0128											; Erase from #B898 length #0128 bytes
	1705 CD 67 24       CALL Erase_forward_Block_RAM
	1708 AF             XOR A
	1709 32 C0 1A       LD (IsPillarBufFlipped),A							; reset Flip bit
	170C 3D             DEC A												; FF
	170D 32 41 19       LD (hasPillarUnderDoor),A							; reset "Has Under Door" bit
	1710 F1             POP AF												; restore A
	; Zero height? Draw nothing
	1711 A7             AND A												; test
	1712 C8             RET Z												; if 0 (height of 0) RET Z set, else:
	;; Otherwise, draw in reverse from end of buffer PillarBuf...
	1713 11 BF B9       LD DE,PillarBuf+296-1								; PillarBuf + PillarBufLen - 1 (B9A0 to B9BF)
	1716 21 97 B8       LD HL,image_pillar_btm+32-1							; image_pillar_btm + 4 * 4 - 1 (last byte of image_pillar_btm) (B878 to B897)
	1719 01 20 00       LD BC,0020											; length in bytes : 32 = 4 * 4 * 2
	171C ED B8          LDDR												; Copy Pillar Bottom in pillar buffer
drawPillarLoop:
	171E D6 06          SUB 06												; add as many 6-row tall mid pillars as needed
	1720 28 0A          JR Z,drawPillarTop
	1722 21 77 B8       LD HL,img_pillar_mid+48-1							; img_pillar_mid + 4 * 6 - 1 (last byte of img_pillar_mid) (B848 to B877)
	1725 01 30 00       LD BC,0030											; length in bytes : 48 = 4 * 6 * 2
	1728 ED B8          LDDR												; Copy Pillar Mid in pillar buffer
	172A 18 F2          JR drawPillarLoop									; until desired height is reached
drawPillarTop:
	172C 21 47 B8       LD HL,img_pillar_top+72-1							; img_pillar_top + 4 * 9 - 1 (last byte of img_pillar_top) (B800 to B847)
	172F 01 48 00       LD BC,0048											; length in bytes : 72 = 4 * 9 * 2
	1732 ED B8          LDDR												; Copy Pillar Top in pillar buffer
	1734 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Given extents stored in ViewXExtent and ViewYExtent,
;; draw the appropriate piece of screen background into
;; ViewBuff (to be drawn over and blitted to display later)
;; Buffer to write to is assumed to be 6 bytes wide.
.DrawBkgnd:
	1735 2A 98 1C       LD HL,(ViewXExtent)									; ViewXExtent
	; H contains start, L end, in double-pixels
	1738 7C             LD A,H												; HL = x min and max
	1739 1F             RRA
	173A 1F             RRA													; 4 pix per byte
	173B 4F             LD C,A												; Start byte number stashed in C for later.
	173C E6 3E          AND 3E												; Clear lowest bit to get 2x double column index...
	173E D9             EXX
	173F 6F             LD L,A
	1740 26 6A          LD H,6A												; BkgndData >> 8 ; BkgndData is page-aligned. 6Aaa
	1742 D9             EXX													; Set HL' to column info
	; Calculate width to draw, in bytes
	1743 7D             LD A,L
	1744 94             SUB H												; delta Xmax-Xmin = X width
	1745 1F             RRA
	1746 1F             RRA
	1747 E6 07          AND 07
	1749 D6 02          SUB 02
	174B 11 00 68       LD DE,6800											;; destination buffer
	;; Below here, DE points at the sprite buffer, and HL' the
    ;; source data (two bytes per column pair). A contains number
    ;; of cols to draw, minus 2.
    ;; If index is initially odd, draw RHS of a column pair.
	174E CB 19          RR C
	1750 30 15          JR NC,dbg_1
	1752 FD 21 B6 19    LD IY,ClearOne
	1756 DD 21 67 1A    LD IX,OneColBlitR
	175A 21 31 1A       LD HL,BlitFloorR
	175D CD 8D 17       CALL DrawBkgndCol
	1760 FE FF          CP FF
	1762 C8             RET Z
	1763 D6 01          SUB 01
	1765 18 11          JR dbg_2

dbg_1:
	; Draw two columns at a time.
	1767 FD 21 C5 19    LD IY,ClearTwo
	176B DD 21 80 1A    LD IX,TwoColBlit
	176F 21 04 1A       LD HL,BlitFloor
	1772 CD 8D 17       CALL DrawBkgndCol
	1775 1C             INC E												; We did 2 columns this time, so bump one more.
	1776 D6 02          SUB 02
dbg_2:
	1778 30 ED          JR NC,dbg_1
	; One left-over column.
	177A 3C             INC A
	177B C0             RET NZ
	177C FD 21 B6 19    LD IY,ClearOne
	1780 DD 21 6C 1A    LD IX,OneColBlitL
	1784 21 3E 1A       LD HL,BlitFloorL
	1787 22 49 18       LD (smc_blitfloor_fnptr+1),HL						; value at #1849 ; self mod code of JP
	178A D9             EXX
	178B 18 12          JR DrawBkgndCol2

; Performs register-saving and incrementing HL'/E. Not needed
;; for the last call from DrawBkgnd.
.DrawBkgndCol:
	178D 22 49 18       LD (smc_blitfloor_fnptr+1),HL						; value at #1849 ; self mod code of JP
	1790 D5             PUSH DE
	1791 F5             PUSH AF
	1792 D9             EXX
	1793 E5             PUSH HL
	1794 CD 9F 17       CALL DrawBkgndCol2
	1797 E1             POP HL
	1798 2C             INC L
	1799 2C             INC L
	179A D9             EXX
	179B F1             POP AF
	179C D1             POP DE
	179D 1C             INC E
	179E C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Reads from ViewYExtent
;; * Takes in:
;;   HL' - Floor drawing function
;;   DE' - Destination buffer (only modified via IX, IY, etc.)
;;   IX  - Copying function (takes #rows in A, writes to DE' and updates it)
;;   IY  - Clearing function (takes #rows in A, writes to DE' and updates it)
;;   HL  - Pointer to BkgndData array entry:
;;           Byte 0: Y of wall bottom (0 = clear)
;;           Byte 1: Id for wall panel sprite
;;                   (0-3 - world-specific, 4 - Pillar, 5 - blank, | $80 to flip)
;; Note that the Y coordinates are downward-increasing, matching memory.
;; The basic walls are 56 pixels high
;;			SHORT_WALL:     EQU $38				; 56
;; Pillar/spaces (indices 4 and 5) are up to 74 pixels high, made up
;; of top, repeated middle and bottom section.
;;			TALL_WALL:      EQU (9 + 24 + 4) * 2
.DrawBkgndCol2:
	179F ED 5B 9A 1C    LD DE,(ViewYExtent)									ViewYExtent
	17A3 7B             LD A,E
	17A4 92             SUB D
	17A5 5F             LD E,A												; E now contains height
	17A6 7E             LD A,(HL)
	17A7 A7             AND A
	17A8 28 4C          JR Z,DBC_Clear										; Baseline of zero? Clear full height, then
	17AA 7A             LD A,D
	17AB 96             SUB (HL)
	17AC 57             LD D,A												; D holds how many lines we are below the bottom of the wall
	17AD 30 4A          JR NC,DBC_DoFloor									; Positive? Then skip to drawing the floor.
	;; In this case, we handle the viewing window starting above the start of the floor.
	17AF 23             INC HL
	17B0 0E 38          LD C,38												SHORT_WALL ; Wall height for ids 0-3
	17B2 CB 56          BIT 2,(HL)
	17B4 28 02          JR Z,dbcflag
	17B6 0E 4A          LD C,4A												TALL_WALL ; Wall height for ids 4-5
.dbcflag:
	17B8 81             ADD A,C												; Add the wall height on.
	; Window Y start now relative to the top of the current wall panel.
	17B9 30 0B          JR NC,DBC_TopSpace 									; Still some space left above in window? Jump
	; Start drawing some fraction through the wall panel
	17BB 87             ADD A,A
	17BC CD 2F 19       CALL GetOffsetWall
	17BF D9             EXX
	17C0 7A             LD A,D
	17C1 ED 44          NEG
	17C3 C3 E2 17       JP DBC_Wall

;; We start before the top of the wall panel, so we'll start off by clearing above.
;; A holds -number of rows to top of wall panel, E holds number of rows to write.
.DBC_TopSpace:
	17C6 ED 44          NEG
	17C8 BB             CP E
	17C9 30 2B          JR NC,DBC_Clear						    			; If we're /only/ drawing space, do the tail call.
	; Clear the appropriate amount of space.
	17CB 47             LD B,A
	17CC ED 44          NEG
	17CE 83             ADD A,E
	17CF 5F             LD E,A
	17D0 78             LD A,B
	17D1 CD B4 19       CALL DoClear
	; Get the pointer to the wall panel bitmap to copy in...
	17D4 7E             LD A,(HL)
	17D5 D9             EXX
	17D6 CD 7D 19       CALL GetWall
	17D9 D9             EXX
	; and the height to use
	17DA 3E 38          LD A,38												SHORT_WALL
	17DC CB 56          BIT 2,(HL)
	17DE 28 02          JR Z,DBC_Wall
	17E0 3E 4A          LD A,4A												TALL_WALL
;; Now draw the wall. A holds number of lines of wall to draw, source in HL'
.DBC_Wall:
	17E2 BB             CP E
	17E3 30 0E          JR NC,dbc_copy					     				; Window ends in the wall panel? Tail call
	; Otherwise, copy the full wall panel, and then draw the floor etc.
	17E5 47             LD B,A
	17E6 ED 44          NEG
	17E8 83             ADD A,E
	17E9 08             EX AF,AF
	17EA 78             LD A,B
	17EB CD B2 19       CALL DoCopy
	17EE 08             EX AF,AF
	17EF 16 00          LD D,00
	17F1 18 08          JR DBC_FloorEtc

.dbc_copy:
	17F3 7B             LD A,E
	17F4 DD E9          JP (IX)												; Copy A rows from HL' to DE'. TO CHECK : #1A67, #1A80, #1A6C

.DBC_Clear:
	17F6 7B             LD A,E
	17F7 FD E9          JP (IY)												; Clear A rows at DE'. TO CHECK : #19B6, #19C5, #19B6

;; Point we jump to if we're initially below the top edge of the floor.
.DBC_DoFloor:
	17F9 7B             LD A,E
	17FA 23             INC HL
;; Code to draw the floor, bottom edge, and any space below
;;
;; At this point, HL has been incremented by 1, A contains
;; number of rows to draw, D contains number of lines below
;; bottom of wall we're at.
;; First, calculate the position of the bottom edge.
.DBC_FloorEtc:
	17FB 47             LD B,A												; Store height in B
	17FC 2B             DEC HL												; And go back to original pointer location
	17FD 7D             LD A,L												; L contained column number & ~1
	17FE 87             ADD A,A
	17FF 87             ADD A,A						 						; The bottom edge goes down 4 pixels for each
	1800 C6 04          ADD A,04											; byte across, so multiply by 4 and add 4.
;; Compare A with the position of the corner, to determine the
;; play area edge graphic to use, by overwriting the smc_whichEdge
;; operand. A itself is adjusted around the corner position.
smc_CornerPos:
	1802 FE 00          CP 00
	;;1803 DATABYTE 00														self-modifying code
	1804 38 0C          JR C,DBC_Left
	1806 1E 00          LD E,00												DBE_R - DBE_R ; Right edge graphic case
	1808 20 02          JR NZ,DBC_Right
	180A 1E 05          LD E,05												DBE_C - DBE_R ; Corner edge graphic case
.DBC_Right:
	180C D6 04          SUB 04
.smc_RightAdj:
	180E C6 00          ADD A,00
	;;180F DATABYTE 00														self-modifying code
	1810 18 08          JR DBC_CrnrJmp
.DBC_Left:
	1812 C6 04          ADD A,04
	1814 ED 44          NEG
.smc_LeftAdj:
	1816 C6 00          ADD A,00
	;;1817 DATABYTE 00														self-modifying code. 1817
	1818 1E 08          LD E,08												DBE_L - DBE_R ; Left edge graphic case
;; Store coordinate of bottom edge in C, write out edge graphic
.DBC_CrnrJmp:
	181A ED 44          NEG
	181C C6 0B          ADD A,0B											EDGE_HEIGHT
	181E 4F             LD C,A
	181F 7B             LD A,E
	1820 32 6E 18       LD (smc_whichEdge+1),A								self mod code 186E, value of the relative displacement of the JR ???? (08 or 05)
	;; Find out how much remains to be drawn
	1823 7E             LD A,(HL)											; Load Y baseline
	1824 82             ADD A,D												; Add to offset start to get original start again.
	1825 23             INC HL
	1826 91             SUB C												; Calculate A (onscreen start) - C (screen end of image)
	1827 30 18          JR NC,subclr				   						; <= 0 -> Reached end, so clear buffer
	1829 C6 0B          ADD A,0B											EDGE_HEIGHT
	182B 30 17          JR NC,dbcfloor										; > 11 -> Some floor and edge
	 ;; 0 < Amount to draw <= 11
	182D 5F             LD E,A												; Now we see if we'll reach the end of the bottom edge
	182E D6 0B          SUB 0B												EDGE_HEIGHT
	1830 80             ADD A,B
	1831 38 03          JR C,DBC_AllBottom									; Does the drawing window extend to the edge and beyond?
	1833 78             LD A,B					 							; No, so only draw B lines of edge
	1834 18 2D          JR DrawBottomEdge

;; Case where we're drawing
.DBC_AllBottom:
	1836 F5             PUSH AF
	1837 90             SUB B
	1838 ED 44          NEG													; Draw the bottom edge, then any remaining lines cleared
    ;; Expects number of rows of edge in A, starting row in E,
    ;; draws bottom edge and remaining blanks in DE'. Number of
    ;; blank rows pushed on stack.
.DBC_Bottom:
	183A CD 63 18       CALL DrawBottomEdge
	183D F1             POP AF
	183E C8             RET Z
	183F FD E9          JP (IY)												; Clear A rows at DE'

.subclr:
	1841 78             LD A,B
	1842 FD E9          JP (IY)												; Clear A rows at DE'

;; Draw some floor. A contains -height before reaching edge,
;; B contains drawing window height.
.dbcfloor:
	1844 80             ADD A,B
	1845 38 04          JR C,DBC_FloorNEdge									; Need to draw some floor and also edge.
	1847 78             LD A,B												; Just draw a window-height of floor.
BlitFloorFnPtr:
smc_blitfloor_fnptr:
	1848 C3 00 00		JP 0000
	;;1849 DATAWORD	00 00       											JP 0000 ; self-modifying code: is set during exec at BlitFloorR #1A31, BlitFloor #1A04, BlitFloorL #1A3E

; Draw the floor and then edge etc.
.DBC_FloorNEdge:
	184B F5             PUSH AF
	184C 90             SUB B
	184D ED 44          NEG
	184F CD 48 18       CALL BlitFloorFnPtr
	1852 F1             POP AF
	1853 C8             RET Z
	;; Having drawn the floor, do the same draw edge/draw edge and blank space
    ;; test we did above for the no-floor case
	1854 D6 0B          SUB 0B												EDGE_HEIGHT
	1856 1E 00          LD E,00
	1858 30 04          JR NC,DBC_EdgeNSpace
	185A C6 0B          ADD A,0B											EDGE_HEIGHT
	185C 18 05          JR DrawBottomEdge

.DBC_EdgeNSpace:															;; Draw-the-edge-and-then-space case
	185E F5             PUSH AF
	185F 3E 0B          LD A,0B												EDGE_HEIGHT
	1861 18 D7          JR DBC_Bottom

; Takes starting row number in E, number of rows in A, destination in DE'
;; Returns an updated DE' pointer.
.DrawBottomEdge:
	1863 D5             PUSH DE
	1864 D9             EXX
	1865 E1             POP HL
	1866 26 00          LD H,00
	1868 29             ADD HL,HL
	1869 29             ADD HL,HL
	186A 01 7B 18       LD BC,LeftEdge
smc_whichEdge:
	186D 18 08          JR 08												DBE_L by default, modified to DBE_C
	;;186E DATABYTE 08														Default JR 08= Jump to 1877 (DBE_L) : JR 05= Jump to 1874 (DBE_C); self-modifying code.
DBE_R:
	186F 01 A7 18       LD BC,RightEdge
	1872 18 03          JR DBE_L
DBE_C:
	1874 01 D3 18       LD BC,CornerEdge
DBE_L:
	1877 09             ADD HL,BC
	1878 D9             EXX
	; Copies from HL' to DE', number of rows in A.
	1879 DD E9          JP (IX)

;; -----------------------------------------------------------------------------------------------------------
;; Data to draw the edge of the rooms
.LeftEdge:
	;; 4 bytes * 11  interlaced :
	;;     2 bytes x 11 (height) mask and
	;;     2 bytes x 11 for image
	;; in memory : maskwall1 + wall1 + maskwall2 + wall2 (each are 1byte wide * 11 rows)
	187B DATABYTE 00 40 00 00 00 70 00 00 04 74 00 00 07 77 00 00
	188B DATABYTE 07 37 00 40 07 07 00 70 03 03 04 74 00 00 07 77
	189B DATABYTE 00 00 07 37 00 00 07 07 00 00 03 03
	;; Displaying the images and masks as "mask1+mask2 wall1+wall2"
	;; (reminder: in mem it's mask1+wall1+mask2+wall2)
	;; so it is easier to see.
	;; To visualize the sprite&mask result, let's use this:
	;;	 bit	 bit
	;;	image	mask	result
	;;	0 (.)   0 (.)	Black (X)
	;;	1 (@)   0 (.)	Color (c) (touch of color, depends on current color scheme)
	;;	0 (.)   1 (@)	Transparent (_)
	;;	1 (@)   1 (@)	Cream (.) (main body color)

	     ................ .@.............. XcXXXXXXXXXXXXXX
         ................ .@@@............ XcccXXXXXXXXXXXX
         .....@.......... .@@@.@.......... XcccX.XXXXXXXXXX
         .....@@@........ .@@@.@@@........ XcccX...XXXXXXXX
         .....@@@........ ..@@.@@@.@...... XXccX...XcXXXXXX
         .....@@@........ .....@@@.@@@.... XXXXX...XcccXXXX
         ......@@.....@.. ......@@.@@@.@.. XXXXXX..XcccX.XX
         .............@@@ .........@@@.@@@ XXXXXXXXXcccX...
         .............@@@ ..........@@.@@@ XXXXXXXXXXccX...
         .............@@@ .............@@@ XXXXXXXXXXXXX...
         ..............@@ ..............@@ XXXXXXXXXXXXXX..

.RightEdge:
	18A7 DATABYTE 00 00 03 03 00 00 0F 0F 00 00 1F 1F 00 00 5F 1F
	18B7 DATABYTE 03 03 5C 1C 0F 0F 50 10 1F 1F 40 00 5F 1F 00 00
	18C7 DATABYTE 5C 1C 00 00 50 10 00 00 40 00 00 00

	     ..............@@ ..............@@ XXXXXXXXXXXXXX..
         ............@@@@ ............@@@@ XXXXXXXXXXXX....
         ...........@@@@@ ...........@@@@@ XXXXXXXXXXX.....
         .........@.@@@@@ ...........@@@@@ XXXXXXXXXcX.....
         ......@@.@.@@@.. ......@@...@@@.. XXXXXX..XcX...XX
         ....@@@@.@.@.... ....@@@@...@.... XXXX....XcX.XXXX
         ...@@@@@.@...... ...@@@@@........ XXX.....XcXXXXXX
         .@.@@@@@........ ...@@@@@........ XcX.....XXXXXXXX
         .@.@@@.......... ...@@@.......... XcX...XXXXXXXXXX
         .@.@............ ...@............ XcX.XXXXXXXXXXXX
         .@.............. ................ XcXXXXXXXXXXXXXX

.CornerEdge:
	18D3 DATABYTE 00 40 03 03 00 70 0F 0F 04 74 1F 1F 07 77 5F 1F
	18E3 DATABYTE 07 37 5C 1C 07 07 50 10 03 03 40 00 00 00 00 00
	18F3 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00

	     ..............@@ .@............@@ XcXXXXXXXXXXXX..
         ............@@@@ .@@@........@@@@ XcccXXXXXXXX....
         .....@.....@@@@@ .@@@.@.....@@@@@ XcccX.XXXXX.....
         .....@@@.@.@@@@@ .@@@.@@@...@@@@@ XcccX...XcX.....
         .....@@@.@.@@@.. ..@@.@@@...@@@.. XXccX...XcX...XX
         .....@@@.@.@.... .....@@@...@.... XXXXX...XcX.XXXX
         ......@@.@...... ......@@........ XXXXXX..XcXXXXXX
         ................ ................ XXXXXXXXXXXXXXXX
         ................ ................ XXXXXXXXXXXXXXXX
         ................ ................ XXXXXXXXXXXXXXXX
         ................ ................ XXXXXXXXXXXXXXXX

;; -----------------------------------------------------------------------------------------------------------
;; Takes the room origin in BC, and stores it, and then updates the edge patterns
;; to include a part of the floor pattern.
.TweakEdges:
	18FF 2A E8 19       LD HL,(FloorAddr)
	;; ZX-spectrum has this here : "LD (RoomOrigin),BC"
	1902 01 0A 00       LD BC,000A											2*5
	1905 09             ADD HL,BC											; Move 5 rows into the tile
	1906 0E 10          LD C,10												2*8
	1908 3A C1 1E       LD A,(Has_Door)
	190B 1F             RRA
	190C E5             PUSH HL												; Push this address.
	190D 30 02          JR NC,txedg_1										; If bottom bit of Has_Door is set...
	190F 09             ADD HL,BC
	1910 E3             EX (SP),HL											; Move 8 rows further on the stack-saved pointer
txedg_1:
	1911 09             ADD HL,BC											; In any case, move 8 rows on HL...
	1912 1F             RRA
	1913 30 03          JR NC,txedg_2										; Unless the next bit of Has_Door was set
	1915 A7             AND A
	1916 ED 42          SBC HL,BC
	; Copy some of the left column of the floor into the right edge.
txedg_2:
	1918 11 A7 18       LD DE,RightEdge    									; Call once to tweak right edge
	191B CD 23 19       CALL TweakEdgesInner
	;; Then copy some of the right column of the floor pattern to the left.
	191E E1             POP HL
	191F 23             INC HL
	1920 11 7D 18       LD DE,LeftEdge+2									; then again to tweak left edge
;; Copy 4 bytes, skipping every second byte. Used to copy part of the
;; floor pattern into one side of the top of the edge pattern.
;; Edge pattern in DE, floor in HL.
.TweakEdgesInner:
	1923 3E 04          LD A,04
tei_1:
	1925 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	1927 23             INC HL
	1928 13             INC DE
	1929 13             INC DE
	192A 13             INC DE
	192B 3D             DEC A
	192C 20 F7          JR NZ,tei_1
	192E C9             RET

;; -----------------------------------------------------------------------------------------------------------
; Wrap up a call to GetWall, and add in the starting offset from A.
.GetOffsetWall:
	192F F5             PUSH AF
	1930 7E             LD A,(HL)
	1931 D9             EXX
	1932 CD 7D 19       CALL GetWall
	1935 F1             POP AF
	1936 87             ADD A,A
	1937 F5             PUSH AF
	1938 85             ADD A,L												this does...
	1939 6F             LD L,A
	193A 8C             ADC A,H
	193B 95             SUB L
	193C 67             LD H,A												...HL = HL + A
	193D F1             POP AF
	193E D0             RET NC
	193F 24             INC H
	1940 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Zero means Pillar buffer is zeroed, non-zero means filled with Pillar image.
hasPillarUnderDoor:
	1941 DATABYTE 00

;; Returns PillarBuf in HL.
;; If hasPillarUnderDoor is non-zero, it zeroes the buffer, and the flag.
.GetEmptyPillarBuf:
	1942 3A 41 19       LD A,(hasPillarUnderDoor)							do we have pillar under the door?
	1945 A7             AND A
	1946 21 98 B8       LD HL,PillarBuf
	1949 C8             RET Z
	194A E5             PUSH HL
	194B C5             PUSH BC
	194C D5             PUSH DE
	194D 01 28 01       LD BC,0128											Erase block of #0128 bytes
	1950 CD 67 24       CALL Erase_forward_Block_RAM
	1953 D1             POP DE
	1954 C1             POP BC
	1955 E1             POP HL
	1956 AF             XOR A
	1957 32 41 19       LD (hasPillarUnderDoor),A
	195A C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Called by GetWall for high-index sprites, to draw the space under a door
;;   A=5 -> blank space, A=4 -> Pillars
.GetUnderDoor:
	195B CB 47          BIT 0,A												; Low bit nonzero? Return cleared buffer.
	195D 20 E3          JR NZ,GetEmptyPillarBuf
	195F 6F             LD L,A
	;; Otherwise, we're drawing a Pillar
	1960 3A 41 19       LD A,(hasPillarUnderDoor)
	1963 A7             AND A
	1964 CC EE 16       CALL Z,FillPillarBuf
	1967 3A C0 1A       LD A,(IsPillarBufFlipped)
	196A AD             XOR L
	196B 17             RLA
	; Carry set if we need to flip and update flag to match request...
	196C 21 98 B8       LD HL,PillarBuf
	196F D0             RET NC						 						; Return PillarBuf if no flip required...
	1970 3A C0 1A       LD A,(IsPillarBufFlipped)							; Otherwise, flip flag and buffer.
	1973 EE 80          XOR 80
	1975 32 C0 1A       LD (IsPillarBufFlipped),A
	1978 06 4A          LD B,4A												TALL_WALL
	197A C3 9C 1A       JP FlipPillar

;; -----------------------------------------------------------------------------------------------------------
;; Get a wall section thing.
;; Index in A. Top bit represents whether flip is required.
;; Pointer to data returned in HL.
.GetWall:
	197D CB 57          BIT 2,A												; 4 and 5 handled by GetUnderDoor.
	197F 20 DA          JR NZ,GetUnderDoor
	1981 F5             PUSH AF
	1982 CD 8F 19       CALL NeedsFlip2					 					; Check if flip is required
	1985 08             EX AF,AF
	1986 F1             POP AF
	1987 CD C1 1A       CALL GetPanelAddr
	198A 08             EX AF,AF
	198B D0             RET NC
	198C C3 9A 1A       JP FlipPanel

;; -----------------------------------------------------------------------------------------------------------
;; Takes a sprite index in A. Looks up low three bits in the bitmap.
;; If the top bit was set, we flip the bit if necessary to match,
;; and return carry if a bit flip was needed.
.NeedsFlip2:
	198F 4F             LD C,A
	1990 2A 44 3C       LD HL,(Walls_PanelFlipsPtr)
	1993 E6 03          AND 03
	; A = 1 << A
	1995 47             LD B,A
	1996 04             INC B
	1997 3E 01          LD A,01
nf2_1:
	1999 0F             RRCA
	199A 10 FD          DJNZ nf2_1											right shift B times
	; Check if that bit of (HL) is set
	199C 47             LD B,A
	199D A6             AND (HL)
	199E 20 08          JR NZ,nf2_2
	; It isn't. Was top bit if param set?
	19A0 CB 11          RL C
	19A2 D0             RET NC												; No - return with carry reset
	; It was. So, set bit and return with carry flag set.
	19A3 78             LD A,B
	19A4 B6             OR (HL)
	19A5 77             LD (HL),A
	19A6 37             SCF
	19A7 C9             RET

nf2_2:
	; Top bit was set. Is bit set?
	19A8 CB 11          RL C
	19AA 3F             CCF
	19AB D0             RET NC												; Yes - return with carry reset
	; No. So reset bit and return with carry flag set.
	19AC 78             LD A,B
	19AD 2F             CPL
	19AE A6             AND (HL)
	19AF 77             LD (HL),A
	19B0 37             SCF
	19B1 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.DoJumpIX:
.DoCopy:
	19B2 DD E9          JP (IX)												; Call the copying function
.DoClear:
	19B4 FD E9          JP (IY)												; Call the clearing function

;; -----------------------------------------------------------------------------------------------------------
;; Zero a single column of the 6-byte-wide buffer at DE' (A rows).
.ClearOne:
	19B6 D9             EXX
	19B7 47             LD B,A
	19B8 EB             EX DE,HL
	19B9 1E 00          LD E,00
clro_1:
	19BB 73             LD (HL),E
	19BC 7D             LD A,L
	19BD C6 06          ADD A,06
	19BF 6F             LD L,A
	19C0 10 F9          DJNZ clro_1
	19C2 EB             EX DE,HL
	19C3 D9             EXX
	19C4 C9             RET

;; Zero two columns of the 6-byte-wide buffer at DE' (A rows).
.ClearTwo:
	19C5 D9             EXX
	19C6 47             LD B,A
	19C7 EB             EX DE,HL
	19C8 1E 00          LD E,00
clr2_1:
	19CA 73             LD (HL),E
	19CB 2C             INC L
	19CC 73             LD (HL),E
	19CD 7D             LD A,L
	19CE C6 05          ADD A,05
	19D0 6F             LD L,A
	19D1 10 F7          DJNZ clr2_1
	19D3 EB             EX DE,HL
	19D4 D9             EXX
	19D5 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Set FloorAddr to the floor sprite indexed in A.
;; HL : pointer on the floor tile patterns selected; also copied into FloorAddr.
.SetFloorAddr:
	19D6 4F             LD C,A												; C = index
	19D7 87             ADD A,A												; *2
	19D8 81             ADD A,C												; *3
	19D9 87             ADD A,A												; *6
	19DA 87             ADD A,A												; *12
	19DB 87             ADD A,A												; *24
	19DC 6F             LD L,A
	19DD 26 00          LD H,00												; HL=index*24
	19DF 29             ADD HL,HL											; *48 = #30 (floor tile size in bytes)
	19E0 11 B0 B4       LD DE,floor_tile_pattern0							; IMG_2x24 ; The floor tile images. Base addr for floor tile patterns is floor_tile_pattern0
	19E3 19             ADD HL,DE											; base+tile_data_offset ; Add to floor tile base to get the pointer on the tile data we want.
	19E4 22 E8 19       LD (FloorAddr),HL									; store the addr in FloorAddr
	19E7 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Address of the sprite data used to draw the floor.
;; This is updated by SetFloorAddr.
.FloorAddr:     															; IMG_2x24 + 2 * $30
	19E8 DATAWORD E0 B4            											; default = floor_tile_pattern1

;; -----------------------------------------------------------------------------------------------------------
;; HL' points to the floor sprite id.
;; If it's floor tile 5, we return a blank floor tile (no floor).
;; Otherwise we return the current tile address pointer, plus an
;; offset C (0 or 2*8), in BC.
.GetFloorAddr:
	19EA F5             PUSH AF
	19EB D9             EXX													; get HL' (pointer on the floor sprite ID in the 6A?? buffer)
	19EC 7E             LD A,(HL)											; get floor sprite ID
	19ED F6 FA          OR FA												; ~5
	19EF 3C             INC A												; If the wall sprite id is 5 (space) (then OR FA + 1 will be 0)...
	19F0 D9             EXX													; restore not prime 16b reg
	19F1 28 0C          JR Z,Blank_Tile										; Flor tile ID 5 = No floor, else:
	19F3 79             LD A,C
	19F4 ED 4B E8 19    LD BC,(FloorAddr)									; get the floor_tile_pattern<n> pointer
	19F8 81             ADD A,C												; Add old C to FloorAddr and return in BC.
	19F9 4F             LD C,A
	19FA 88             ADC A,B
	19FB 91             SUB C
	19FC 47             LD B,A												; BC = BC + A
	19FD F1             POP AF
	19FE C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Use the empty floor tile (no floor)
.Blank_Tile:
	19FF 01 00 B6       LD BC,floor_tile_pattern7							; IMG_2x24 + 7 * $30
	1A02 F1             POP AF
	1A03 C9             RET													; Return the blank tile

;; -----------------------------------------------------------------------------------------------------------
;; Fill a 6-byte-wide buffer at DE' with both columns of a floor tile.
;; A contains the number of rows to generate.
;; D contains the initial offset in rows.
;; HL points to the floor sprite id.
;; The +0 or +16 in C below will align the left part (+0) and the right
;; part (+16 : flipped side) of the floor tiles in the Y axis:
;;    /|\
;;    \|/
.BlitFloor:
	1A04 47             LD B,A
	1A05 7A             LD A,D
	;; Move down 8 rows if top bit of (HL) is set,
    ;; i.e. if we're on the flipped side.
	1A06 CB 7E          BIT 7,(HL)											; Flip bit of the sprite ID
	1A08 D9             EXX													; The floor sprite ID is now pointed by HL'
	1A09 0E 00          LD C,00												; not flipped : C offset = 0
	1A0B 28 02          JR Z,bf_1
	1A0D 0E 10          LD C,10												; Flipped : C offset = 2*8 : this will realign the right part of the floor tiles
bf_1:
	1A0F CD EA 19       CALL GetFloorAddr									; BC will point on floor tile data
	;; Construct offset in HL from original D. Double it as tile is 2 wide.
	1A12 E6 0F          AND 0F
	1A14 87             ADD A,A
	1A15 26 00          LD H,00
	1A17 6F             LD L,A
	1A18 D9             EXX
	;; At this point we have source in BC', destination in DE',
    ;; offset of source in HL', and number of rows to copy in B.
bf_2:
	1A19 D9             EXX
	1A1A E5             PUSH HL
	;; Copy both bytes of the current row into the 6-byte-wide buffer.
	1A1B 09             ADD HL,BC
	1A1C 7E             LD A,(HL)
	1A1D 12             LD (DE),A
	1A1E 23             INC HL
	1A1F 1C             INC E
	1A20 7E             LD A,(HL)
	1A21 12             LD (DE),A
	1A22 7B             LD A,E
	1A23 C6 05          ADD A,05
	1A25 5F             LD E,A
	1A26 E1             POP HL
	1A27 7D             LD A,L
	1A28 C6 02          ADD A,02
	;; Floor tiles are 24 pixels high. Depending on odd/even, we
    ;; start at offset 0 or 16 (8 rows in). So, if we read offsets
    ;; 0..31 (rows 0..15) from there, we get the right data, and
    ;; can safely wrap.
	1A2A E6 1F          AND 1F
	1A2C 6F             LD L,A
	1A2D D9             EXX
	1A2E 10 E9          DJNZ bf_2
	1A30 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Fill a 6-byte-wide buffer at DE' with the right column of background tile.
;; A  contains number of rows to generate.
;; D  contains initial offset in rows.
;; HL contains pointer to wall sprite id.
.BlitFloorR:
	1A31 47             LD B,A
	1A32 7A             LD A,D
	;; Move down 8 rows if top bit of (HL) is set.
    ;; Do the second column of the image (the extra +1)
	1A33 CB 7E          BIT 7,(HL)
	1A35 D9             EXX
	1A36 0E 01          LD C,01
	1A38 28 0F          JR Z,bfl_1
	1A3A 0E 11          LD C,11												; 2*8+1
	1A3C 18 0B          JR bfl_1

;; -----------------------------------------------------------------------------------------------------------
;; Fill a 6-byte-wide buffer at DE' with the left column of background tile.
;; A  contains number of rows to generate.
;; D  contains initial offset in rows.
;; HL contains pointer to wall sprite id.
;; (This is to refresh the background (floor tiles) when a sprite moves)
.BlitFloorL:
	1A3E 47             LD B,A
	1A3F 7A             LD A,D
	; Move down 8 rows if top bit of (HL) is set.
	1A40 CB 7E          BIT 7,(HL)
	1A42 D9             EXX
	1A43 0E 00          LD C,00
	1A45 28 02          JR Z,bfl_1
	1A47 0E 10          LD C,10												; 2*8
	;; Get the address (using HL' for wall sprite id)
bfl_1:
	1A49 CD EA 19       CALL GetFloorAddr
	;; Construct offset in HL from original D. Double it as tile is 2 wide.
	1A4C E6 0F          AND 0F
	1A4E 87             ADD A,A
	1A4F 26 00          LD H,00
	1A51 6F             LD L,A
	1A52 D9             EXX
	;; At this point we have source in BC', destination in DE',
    ;; offset of source in HL', and number of rows to copy in B.
bfl_2:
	1A53 D9             EXX
	1A54 E5             PUSH HL
	; Copy 1 byte into 6-byte-wide buffer
	1A55 09             ADD HL,BC
	1A56 7E             LD A,(HL)
	1A57 12             LD (DE),A
	1A58 7B             LD A,E
	1A59 C6 06          ADD A,06
	1A5B 5F             LD E,A
	1A5C E1             POP HL
	1A5D 7D             LD A,L
	1A5E C6 02          ADD A,02
	1A60 E6 1F          AND 1F
	1A62 6F             LD L,A												; Add 1 row to source offset pointer, mod 32
	1A63 D9             EXX
	1A64 10 ED          DJNZ bfl_2
	1A66 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Blit from HL' to DE', right byte of a 2-byte-wide sprite in a 6-byte wide buffer.
;; Number of rows in A.
;; (This is to refresh the background (especially if in front of a wall) when a sprite moves)
.OneColBlitR:
	1A67 D9             EXX
	1A68 23             INC HL
	1A69 23             INC HL
	1A6A 18 01          JR ocbt_1
;; Blit from HL' to DE', left byte of a 2-byte-wide sprite in a 6-byte wide buffer.
;; Number of rows in A.
.OneColBlitL:
	1A6C D9             EXX
ocbt_1:
	1A6D 47             LD B,A
ocbt_2:
	1A6E 7E             LD A,(HL)
	1A6F 12             LD (DE),A
	1A70 23             INC HL
	1A71 15             DEC D
	1A72 7E             LD A,(HL)
	1A73 12             LD (DE),A
	1A74 14             INC D
	1A75 23             INC HL
	1A76 23             INC HL
	1A77 23             INC HL
	1A78 7B             LD A,E
	1A79 C6 06          ADD A,06
	1A7B 5F             LD E,A
	1A7C 10 F0          DJNZ ocbt_2
	1A7E D9             EXX
	1A7F C9             RET

;; Blit from HL' to DE', a 2-byte-wide sprite in a 6-byte wide buffer.
;; Number of rows in A.
.TwoColBlit:
	1A80 D9             EXX
	1A81 47             LD B,A
tcbl_1:
	1A82 7E             LD A,(HL)
	1A83 12             LD (DE),A
	1A84 23             INC HL
	1A85 15             DEC D
	1A86 7E             LD A,(HL)
	1A87 12             LD (DE),A
	1A88 23             INC HL
	1A89 4E             LD C,(HL)
	1A8A 23             INC HL
	1A8B 1C             INC E
	1A8C 7E             LD A,(HL)
	1A8D 12             LD (DE),A
	1A8E 23             INC HL
	1A8F 14             INC D
	1A90 79             LD A,C
	1A91 12             LD (DE),A
	1A92 7B             LD A,E
	1A93 C6 05          ADD A,05
	1A95 5F             LD E,A
	1A96 10 EA          DJNZ tcbl_1
	1A98 D9             EXX
	1A99 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Flip a normal wall panel
;; Used to flip the wall sprite for the right side of the screen.
.FlipPanel:
	1A9A 06 38          LD B,38												; SHORT_WALL
; Reverse a two-byte-wide image. Height in B, pointer to data in HL.
.FlipColumn:
	1A9C D5             PUSH DE
	1A9D 16 69          LD D,69												; RevTable >> 8
	1A9F E5             PUSH HL
fcol_1:
	1AA0 22 B8 1A       LD (smc_dest_addr2+1),HL							; self mod code at 1AB8, value of LD (...),A
	1AA3 5E             LD E,(HL)
	1AA4 1A             LD A,(DE)
	1AA5 23             INC HL
	1AA6 5E             LD E,(HL)
	1AA7 22 B3 1A       LD (smc_dest_addr1+1),HL							; self mod code at 1AB3, value of LD (...),A
	1AAA 23             INC HL
	1AAB 4E             LD C,(HL)
	1AAC 77             LD (HL),A
	1AAD 23             INC HL
	1AAE 1A             LD A,(DE)
	1AAF 5E             LD E,(HL)
	1AB0 77             LD (HL),A
	1AB1 1A             LD A,(DE)
smc_dest_addr1:
	1AB2 32 00 00       LD (0000),A											; addr self modified at 1AA7
	;;1AB3 DATAWORD 00 00
	1AB5 59             LD E,C
	1AB6 1A             LD A,(DE)
smc_dest_addr2:
	1AB7 32 00 00       LD (0000),A											; addr self modified at 1AA0
	;;1AB8 DATAWORD 00 00
	1ABA 23             INC HL
	1ABB 10 E3          DJNZ fcol_1
	1ABD E1             POP HL
	1ABE D1             POP DE
	1ABF C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Top bit is set if the column image buffer is flipped
IsPillarBufFlipped:
	1AC0 DATABYTE 00

;; -----------------------------------------------------------------------------------------------------------
;; Return the wall panel address in HL, given panel index in A.
.GetPanelAddr:
	1AC1 E6 03          AND 03												; Limit to 0-3
	1AC3 87             ADD A,A												; *2
	1AC4 87             ADD A,A												; *4
	1AC5 4F             LD C,A												; =*4
	1AC6 87             ADD A,A												; *8
	1AC7 87             ADD A,A												; *16
	1AC8 87             ADD A,A												; *32
	1AC9 91             SUB C												; *28
	1ACA 87             ADD A,A												; *56
	1ACB 6F             LD L,A
	1ACC 26 00          LD H,00
	1ACE 29             ADD HL,HL											; *112
	1ACF 29             ADD HL,HL											; = 2 x 112 (img and mask)
	1AD0 ED 4B 42 3C    LD BC,(Walls_PanelBase)								; base addr
	1AD4 09             ADD HL,BC											; add offset to Walls_PanelBase in HL and return.
	1AD5 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Given sprite data, return a rotated version of it.
;;
;; A holds the rotation size (in 2-bit units).
;; At start, HL holds source image, DE hold mask image.
;; At end, HL holds dest image, DE holds mask image.
;; A' is incremented.
;; The sprite width and number of bytes are read from SpriteWidth and
;; SpriteRowCount. SpriteWidth is incremented. Uses 'Buffer'.
.BlitRot:
	1AD6 3D             DEC A
	1AD7 87             ADD A,A
	1AD8 D9             EXX
	; Load rotation size into BC, and function table into HL.
	1AD9 4F             LD C,A
	1ADA 06 00          LD B,00
	1ADC 3A 37 35       LD A,(Sprite_Width)									get Sprite_Width
	1ADF 3C             INC A												width + 1
	1AE0 32 37 35       LD (Sprite_Width),A									update Sprite_Width
	1AE3 FE 05          CP 05
	1AE5 21 1C 1B       LD HL,BlitRot3s										Default to BlitRot on 3 case.
	1AE8 20 03          JR NZ,btrot_0
	1AEA 21 22 1B       LD HL,BlitRot4s										SpriteWidth was 4 -> Use the BlitRot on 4 case.
btrot_0
	1AED 09             ADD HL,BC
	;; Dereference function pointer into HL.
	1AEE 7E             LD A,(HL)
	1AEF 23             INC HL
	1AF0 66             LD H,(HL)
	1AF1 6F             LD L,A
	;; And modify the code.
	1AF2 22 06 1B       LD (btrot_1+1),HL									Update the CALL addr at 1B06 (self modifying code)
	1AF5 22 11 1B       LD (btrot_2+1),HL									Update the CALL addr at 1B11 (self modifying code)
	1AF8 D9             EXX
	1AF9 08             EX AF,AF
	1AFA F5             PUSH AF
	; Time to rotate the sprite.
	1AFB 3A 9D 1C       LD A,(SpriteRowCount)								get SpriteRowCount
	1AFE D5             PUSH DE
	1AFF 11 C0 6F       LD DE,6FC0											Buffer
	1B02 06 00          LD B,00												; Blank space in the filler.
	1B04 F3             DI
	;addr at 1B06
smc_btrot_1:
	1B05 CD 00 00	    CALL 0000											default : "CALL 0000" ; addr updated at line 1AF2 (self modifying code)
	;;1B06 DATAWORD 00 00													modified 1AF2
	;; HL now holds the end of the destination buffer.
	1B08 EB             EX DE,HL
	1B09 E1             POP HL
	1B0A D5             PUSH DE
	; And to rotate the mask.
	1B0B 3A 9D 1C       LD A,(SpriteRowCount)								get SpriteRowCount
	1B0E 06 FF          LD B,FF												; Appropriate filler for the mask.
	; addr at 1B11
smc_btrot_2:
	1B10 CD 00 00       CALL 0000											default "CALL 0000" ; addr updated at line 1AF5 (self modifying code)
	;;1B11 DATAWORD 00 00													modified at 1AF5
	1B13 21 C0 6F       LD HL,6FC0											buffer
	1B16 D1             POP DE
	1B17 FB             EI
	1B18 F1             POP AF
	1B19 3C             INC A
	1B1A 08             EX AF,AF
	1B1B C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; pointers on the BlitRot* function to use
BlitRot3s:
	1B1C DATAWORD 2A 1B														; BlitRot2on3 1B2A
	1B1E DATAWORD E0 1B														; BlitRot4on3 1BE0
	1B20 DATAWORD 85 1B														; BlitRot6on3 1B85
BlitRot4s:
	1B22 DATAWORD 03 1C														; BlitRot2on4 1C03
	1B24 DATAWORD 71 1C														; BlitRot4on4 1C71
	1B26 DATAWORD 3A 1C														; BlitRot6on4 1C3A

;; -----------------------------------------------------------------------------------------------------------
Save_Stack_ptr:
	1B28 DATAWORD 00 00

;; -----------------------------------------------------------------------------------------------------------
;; Do a copy with 2-bit shift.
;; Source HL, width 3 bytes.
;; Destination DE, width 4 bytes.
;; A contains byte-count, B contains filler character
;; Returns next space after destination write in HL
.BlitRot2on3:
	1B2A ED 73 28 1B    LD (Save_Stack_ptr),SP
	1B2E 0E 3E          LD C,3E												; C = #3E = "LD A,vv" ; vv (filler) in B
	1B30 ED 43 49 1B    LD (smc_br23_1),BC									; self mod the filler value in B in the instruction at 1B49
	1B34 ED 43 63 1B    LD (smc_br23_2),BC									; self mod the filler value in B in the instruction at 1B63
	1B38 F9             LD SP,HL
	1B39 EB             EX DE,HL
	1B3A CB 3F          SRL A
	1B3C 30 08          JR NC,br23_1
	1B3E 3C             INC A
	1B3F 08             EX AF,AF
	1B40 C1             POP BC
	1B41 41             LD B,C
	1B42 3B             DEC SP
	1B43 C3 62 1B       JP br23_2

br23_1:
	1B46 08             EX AF,AF
	1B47 D1             POP DE
	1B48 C1             POP BC
smc_br23_1:
	1B49 3E 00          LD A,00												the value (contained in B) will be modified at 1B30; self mod code
	1B4B 0F             RRCA
	1B4C CB 1B          RR E
	1B4E CB 1A          RR D
	1B50 CB 19          RR C
	1B52 1F             RRA
	1B53 CB 1B          RR E
	1B55 CB 1A          RR D
	1B57 CB 19          RR C
	1B59 1F             RRA
	1B5A 73             LD (HL),E
	1B5B 23             INC HL
	1B5C 72             LD (HL),D
	1B5D 23             INC HL
	1B5E 71             LD (HL),C
	1B5F 23             INC HL
	1B60 77             LD (HL),A
	1B61 23             INC HL
br23_2:
	1B62 D1             POP DE
smc_br23_2:
	1B63 3E 00          LD A,00												the value (contained in B) will be modified at 1B34 ; self mod code
	1B65 0F             RRCA
	1B66 CB 18          RR B
	1B68 CB 1B          RR E
	1B6A CB 1A          RR D
	1B6C 1F             RRA
	1B6D CB 18          RR B
	1B6F CB 1B          RR E
	1B71 CB 1A          RR D
	1B73 1F             RRA
	1B74 70             LD (HL),B
	1B75 23             INC HL
	1B76 73             LD (HL),E
	1B77 23             INC HL
	1B78 72             LD (HL),D
	1B79 23             INC HL
	1B7A 77             LD (HL),A
	1B7B 23             INC HL
	1B7C 08             EX AF,AF
	1B7D 3D             DEC A
	1B7E 20 C6          JR NZ,br23_1
	1B80 ED 7B 28 1B    LD SP,(Save_Stack_ptr)
	1B84 C9             RET

;; Do a copy with 6-bit shift.
;; Source HL, width 3 bytes.
;; Destination DE, width 4 bytes.
;; A contains byte-count, B contains filler character
;; Returns next space after destination write in HL
.BlitRot6on3:
	1B85 ED 73 28 1B    LD (Save_Stack_ptr),SP
	1B89 0E 3E          LD C,3E												; C = #3E = "LD A,vv" ; vv (filler) in B
	1B8B ED 43 A4 1B    LD (smc_br63_1),BC									; self mod the filler value in B in the instruction at 1BA4
	1B8F ED 43 BE 1B    LD (smc_br63_2),BC									; self mod the filler value in B in the instruction at 1BBE
	1B93 F9             LD SP,HL
	1B94 EB             EX DE,HL
	1B95 CB 3F          SRL A
	1B97 30 08          JR NC,br63_1
	1B99 3C             INC A
	1B9A 08             EX AF,AF
	1B9B C1             POP BC
	1B9C 41             LD B,C
	1B9D 3B             DEC SP
	1B9E C3 BD 1B       JP br63_2

br63_1:
	1BA1 08             EX AF,AF
	1BA2 D1             POP DE
	1BA3 C1             POP BC
smc_br63_1:
	1BA4 3E 00          LD A,00												the value (contained in B) will be modified at 1B8B ; self mod code
	1BA6 07             RLCA
	1BA7 CB 11          RL C
	1BA9 CB 12          RL D
	1BAB CB 13          RL E
	1BAD 17             RLA
	1BAE CB 11          RL C
	1BB0 CB 12          RL D
	1BB2 CB 13          RL E
	1BB4 17             RLA
	1BB5 77             LD (HL),A
	1BB6 23             INC HL
	1BB7 73             LD (HL),E
	1BB8 23             INC HL
	1BB9 72             LD (HL),D
	1BBA 23             INC HL
	1BBB 71             LD (HL),C
	1BBC 23             INC HL
br63_2:
	1BBD D1             POP DE
smc_br63_2:
	1BBE 3E 00          LD A,00												the value (contained in B) will be modified at 1B8F ; self mod code
	1BC0 07             RLCA
	1BC1 CB 12          RL D
	1BC3 CB 13          RL E
	1BC5 CB 10          RL B
	1BC7 17             RLA
	1BC8 CB 12          RL D
	1BCA CB 13          RL E
	1BCC CB 10          RL B
	1BCE 17             RLA
	1BCF 77             LD (HL),A
	1BD0 23             INC HL
	1BD1 70             LD (HL),B
	1BD2 23             INC HL
	1BD3 73             LD (HL),E
	1BD4 23             INC HL
	1BD5 72             LD (HL),D
	1BD6 23             INC HL
	1BD7 08             EX AF,AF
	1BD8 3D             DEC A
	1BD9 20 C6          JR NZ,br63_1
	1BDB ED 7B 28 1B    LD SP,(Save_Stack_ptr)
	1BDF C9             RET

;; Do a copy with 4-bit shift.
;; Source HL, width 3 bytes.
;; Destination DE, width 4 bytes.
;; A contains byte-count, B contains filler character
;; Returns next space after destination write in HL
.BlitRot4on3:
	1BE0 48             LD C,B
	1BE1 47             LD B,A
	1BE2 79             LD A,C
	1BE3 C5             PUSH BC
	1BE4 0E FF          LD C,FF
	1BE6 D5             PUSH DE
br43_1:
	1BE7 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	1BE9 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	1BEB ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	1BED 12             LD (DE),A
	1BEE 13             INC DE
	1BEF 10 F6          DJNZ br43_1
	1BF1 E1             POP HL
	1BF2 C1             POP BC
	1BF3 79             LD A,C
br43_2:
	1BF4 ED 67          RRD
	1BF6 23             INC HL
	1BF7 ED 67          RRD
	1BF9 23             INC HL
	1BFA ED 67          RRD
	1BFC 23             INC HL
	1BFD ED 67          RRD
	1BFF 23             INC HL
	1C00 10 F2          DJNZ br43_2
	1C02 C9             RET

;; Do a copy with 2-bit shift.
;; Source HL, width 3 bytes.
;; Destination DE, width 4 bytes.
;; A contains byte-count, B contains filler character
;; Returns next space after destination write in HL
.BlitRot2on4:
	1C03 ED 73 28 1B    LD (Save_Stack_ptr),SP
	1C07 0E 3E          LD C,3E												; C = #3E = "LD A,vv" ; vv (filler) in B
	1C09 ED 43 12 1C    LD (smc_bt24_1),BC									; self mod the filler value in B in the instruction at 1C12
	1C0D F9             LD SP,HL
	1C0E EB             EX DE,HL
br24_1:
	1C0F 08             EX AF,AF
	1C10 D1             POP DE
	1C11 C1             POP BC
smc_bt24_1:
	1C12 3E 00          LD A,00												the value (contained in B) will be modified at 1C09 ; self mod code
	1C14 0F             RRCA
	1C15 CB 1B          RR E
	1C17 CB 1A          RR D
	1C19 CB 19          RR C
	1C1B CB 18          RR B
	1C1D 1F             RRA
	1C1E CB 1B          RR E
	1C20 CB 1A          RR D
	1C22 CB 19          RR C
	1C24 CB 18          RR B
	1C26 1F             RRA
	1C27 73             LD (HL),E
	1C28 23             INC HL
	1C29 72             LD (HL),D
	1C2A 23             INC HL
	1C2B 71             LD (HL),C
	1C2C 23             INC HL
	1C2D 70             LD (HL),B
	1C2E 23             INC HL
	1C2F 77             LD (HL),A
	1C30 23             INC HL
	1C31 08             EX AF,AF
	1C32 3D             DEC A
	1C33 20 DA          JR NZ,br24_1
	1C35 ED 7B 28 1B    LD SP,(Save_Stack_ptr)
	1C39 C9             RET

;; Do a copy with 6-bit shift.
;; Source HL, width 3 bytes.
;; Destination DE, width 4 bytes.
;; A contains byte-count, B contains filler character
;; Returns next space after destination write in HL
.BlitRot6on4:
	1C3A ED 73 28 1B    LD (Save_Stack_ptr),SP
	1C3E 0E 3E          LD C,3E												; C = #3E = "LD A,vv" ; vv (filler) in B
	1C40 ED 43 49 1C    LD (smc_br64_1),BC									; self mod the filler value in B in the instruction at 1C49
	1C44 F9             LD SP,HL
	1C45 EB             EX DE,HL
bt64_1:
	1C46 08             EX AF,AF
	1C47 D1             POP DE
	1C48 C1             POP BC
smc_br64_1:
	1C49 3E 00          LD A,00												the value (contained in B) will be modified at 1C40 ; self mod code
	1C4B 07             RLCA
	1C4C CB 10          RL B
	1C4E CB 11          RL C
	1C50 CB 12          RL D
	1C52 CB 13          RL E
	1C54 17             RLA
	1C55 CB 10          RL B
	1C57 CB 11          RL C
	1C59 CB 12          RL D
	1C5B CB 13          RL E
	1C5D 17             RLA
	1C5E 77             LD (HL),A
	1C5F 23             INC HL
	1C60 73             LD (HL),E
	1C61 23             INC HL
	1C62 72             LD (HL),D
	1C63 23             INC HL
	1C64 71             LD (HL),C
	1C65 23             INC HL
	1C66 70             LD (HL),B
	1C67 23             INC HL
	1C68 08             EX AF,AF
	1C69 3D             DEC A
	1C6A 20 DA          JR NZ,bt64_1
	1C6C ED 7B 28 1B    LD SP,(Save_Stack_ptr)
	1C70 C9             RET

;; Do a copy with 4-bit shift.
;; Source HL, width 3 bytes.
;; Destination DE, width 4 bytes.
;; A contains byte-count, B contains filler character
;; Returns next space after destination write in HL
.BlitRot4on4:
	1C71 48             LD C,B
	1C72 47             LD B,A
	1C73 79             LD A,C
	1C74 C5             PUSH BC
	1C75 0E FF          LD C,FF
	1C77 D5             PUSH DE
brot44_1:
	1C78 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	1C7A ED A0          LDI
	1C7C ED A0          LDI
	1C7E ED A0          LDI
	1C80 12             LD (DE),A
	1C81 13             INC DE
	1C82 10 F4          DJNZ brot44_1
	1C84 E1             POP HL
	1C85 C1             POP BC
brot44_2:
	1C86 ED 67          RRD
	1C88 23             INC HL
	1C89 ED 67          RRD
	1C8B 23             INC HL
	1C8C ED 67          RRD
	1C8E 23             INC HL
	1C8F ED 67          RRD
	1C91 23             INC HL
	1C92 ED 67          RRD
	1C94 23             INC HL
	1C95 10 EF          DJNZ brot44_2
	1C97 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Sprite variables
;; LSB is upper extent, MSB is lower extent
;; X extent is in screen units (2 pixels per unit). Units
;; increase down and to the right.
ViewXExtent:
	1C98 DATAWORD 66 60
ViewYExtent:
	1C9A DATAWORD 70 50
SpriteXStart:
	1C9C DATABYTE 00
SpriteRowCount:
	1C9D DATABYTE 00
ObjXExtent:
	1C9E DATAWORD 00 00
ObjYExtent:
	1CA0 DATAWORD 00 00
SpriteFlags:
	1CA2 DATABYTE 00

;; -----------------------------------------------------------------------------------------------------------
;; Given an object pointer in HL, calculate and store the object extents.
.StoreObjExtents:
	1CA3 23             INC HL
	1CA4 23             INC HL
	1CA5 CD 1E 1E       CALL GetObjExtents
	1CA8 ED 43 9E 1C    LD (ObjXExtent),BC
	1CAC 22 A0 1C       LD (ObjYExtent),HL
	1CAF C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Takes object in HL, gets union of the extents of that object and
;; Obj[XY]Extent. Returns X extent in HL, Y extent in DE.
.UnionExtents:
	1CB0 23             INC HL
	1CB1 23             INC HL
	1CB2 CD 1E 1E       CALL GetObjExtents
	1CB5 ED 5B A0 1C    LD DE,(ObjYExtent)
	; D = min(D, H)
	1CB9 7C             LD A,H
	1CBA BA             CP D
	1CBB 30 01          JR NC,unext_1
	1CBD 54             LD D,H
	;; E = max(E, L)
unext_1:
	1CBE 7B             LD A,E
	1CBF BD             CP L
	1CC0 30 01          JR NC,unext_2
	1CC2 5D             LD E,L
unext_2:
	1CC3 2A 9E 1C       LD HL,(ObjXExtent)
	; H = min(B, H)
	1CC6 78             LD A,B
	1CC7 BC             CP H
	1CC8 30 01          JR NC,unext_3
	1CCA 60             LD H,B
	; L = max(C, L)
unext_3:
	1CCB 7D             LD A,L
	1CCC B9             CP C
	1CCD D0             RET NC
	1CCE 69             LD L,C
	1CCF C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Takes X extent in HL, rounds it to the byte, and stores in ViewXExtent.
.PutXExtent:
	1CD0 7D             LD A,L												Round L up
	1CD1 C6 03          ADD A,03											~#03
	1CD3 E6 FC          AND FC												align on a mult of 4 value (bits[1:0] = 2b00)
	1CD5 6F             LD L,A
	1CD6 7C             LD A,H
	1CD7 E6 FC          AND FC												~#03 ; Round H down
	1CD9 67             LD H,A
	1CDA 22 98 1C       LD (ViewXExtent),HL
	1CDD C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Takes X extent in HL and Y extent in DE.
.DrawXSafe:
	1CDE CD D0 1C       CALL PutXExtent
	1CE1 18 12          JR Draw_small_start

;; If the end's before Y_START, give up. Otherwise bump the start down
;; and continue.
.BumpYMinAndDraw:
	1CE3 3E 40          LD A,40												Y_START
	1CE5 BB             CP E
	1CE6 D0             RET NC
	1CE7 16 40          LD D,40												Y_START
	1CE9 18 11          JR DrawCore

.UnionAndDraw:
	1CEB CD B0 1C       CALL UnionExtents

;; -----------------------------------------------------------------------------------------------------------
;; Draw a given range of the screen, drawing into ViewBuff and then
;; blitting to the screen. This entry point sanity-checks the extents
;; first.
;; X extent in HL, Y extent in DE
.Draw_View:
	1CEE CD D0 1C       CALL PutXExtent
	; Check the Y extent - give up if it's too far down.
	1CF1 7B             LD A,E
	1CF2 FE F1          CP F1
	1CF4 D0             RET NC
;; Check the Y extent size - give up if it's negative.
;; If the start's less than Y_START, do a special case.
.Draw_small_start:
	1CF5 7A             LD A,D
	1CF6 BB             CP E
	1CF7 D0             RET NC
	1CF8 FE 40          CP 40												Y_START
	1CFA 38 E7          JR C,BumpYMinAndDraw
;; The core drawing routine: Draw the background to the view buffer,
;; draw the sprites, and then copy it to the screen.
;; Y extent passed in through DE.
.DrawCore:
	1CFC ED 53 9A 1C    LD (ViewYExtent),DE
	1D00 CD 35 17       CALL DrawBkgnd
	1D03 3A C0 1E       LD A,(Has_no_wall)
	1D06 E6 0C          AND 0C
	1D08 28 45          JR Z,drwc_1
	; Skip next room in V if $08 not set.
	1D0A 5F             LD E,A
	1D0B E6 08          AND 08
	1D0D 28 23          JR Z,drwc_2
	;; Next room in V appears on left of screen...
    ;; Skip if left of X extent is right of CornerX
	1D0F ED 4B 98 1C    LD BC,(ViewXExtent)
	1D13 21 48 3C       LD HL,Walls_CornerX
	1D16 78             LD A,B
	1D17 BE             CP (HL)
	1D18 30 18          JR NC,drwc_2
	; Skip if min Y extent plus min X is greater than ScreenMaxV
	1D1A 3A 9B 1C       LD A,(ViewYExtent+1)
	1D1D 80             ADD A,B
	1D1E 1F             RRA
	1D1F 57             LD D,A
	1D20 3A 46 3C       LD A,(Walls_ScreenMaxV)
	1D23 BA             CP D
	1D24 38 0C          JR C,drwc_2
	; Draw the next room in the V direction.
	1D26 21 AD 39       LD HL,ObjectLists + 1*4
	1D29 D5             PUSH DE
	1D2A CD 64 1D       CALL Blit_Objects
	1D2D D1             POP DE
	;; Skip next room in U if $04 not set.
	1D2E CB 53          BIT 2,E
	1D30 28 1D          JR Z,drwc_1
	;; Next room in U appears on right of screen...
    ;; Skip if right of X extent is left of CornerX
drwc_2:
	1D32 ED 4B 98 1C    LD BC,(ViewXExtent)
	1D36 3A 48 3C       LD A,(Walls_CornerX)
	1D39 B9             CP C
	1D3A 30 13          JR NC,drwc_1
	;; Skip if min Y minus max X is greater than Walls_ScreenMaxU
	1D3C 3A 9B 1C       LD A,(ViewYExtent+1)
	1D3F 91             SUB C
	;; If it goes negative, top bit is reset, otherwise top bit is set.
    ;; Effectively, we add 128 as we RRA, allowing us to compare with Walls_ScreenMaxU.
	1D40 3F             CCF
	1D41 1F             RRA
	1D42 57             LD D,A
	1D43 3A 47 3C       LD A,(Walls_ScreenMaxU)
	1D46 BA             CP D
	1D47 38 06          JR C,drwc_1
	;; Draw the next room in U direction.
	1D49 21 B1 39       LD HL,ObjectLists + 2*4
	1D4C CD 64 1D       CALL Blit_Objects
drwc_1:
	1D4F 21 B5 39       LD HL,ObjectLists + 3*4								Far
	1D52 CD 64 1D       CALL Blit_Objects
	1D55 21 A9 39       LD HL,ObjectLists + 0*4								Main object list
	1D58 CD 64 1D       CALL Blit_Objects
	1D5B 21 B9 39       LD HL,ObjectLists + 4*4  							Near
	1D5E CD 64 1D       CALL Blit_Objects
	1D61 C3 A7 05       JP Blit_screen

;; -----------------------------------------------------------------------------------------------------------
;; Call Sub_BlitObject for each object in the linked list pointed to by
;; HL. Note that we're using the second link, so the passed HL is an
;; object + 2.
.Blit_Objects:
	1D64 7E             LD A,(HL)
	1D65 23             INC HL
	1D66 66             LD H,(HL)											get new HL from curr HL
	1D67 6F             LD L,A
	1D68 B4             OR H												if new HL=0
	1D69 C8             RET Z												then leave, else:
	1D6A 22 71 1D       LD (smc_CurrObject2+1),HL							self modify the value of LD HL,... at 1D70 (smc_CurrObject2+1)
	1D6D CD 75 1D       CALL Sub_BlitObject
smc_CurrObject2:
	1D70 21 00 00       LD HL,0000											get next object in list ; addr at 1D71 is written above at 1D6A
	;;1D71 DATAWORD 00 00													Self-modifying code
	1D73 18 EF          JR Blit_Objects

;; -----------------------------------------------------------------------------------------------------------
;;  Set carry flag if there's overlap
;;  X adjustments in HL', X overlap in A'
;;  Y adjustments in HL,  Y overlap in A
.Sub_BlitObject:
	1D75 CD 03 1E       CALL IntersectObj
	1D78 D0             RET NC												; No intersection? Return
	1D79 32 9D 1C       LD (SpriteRowCount),A								update SpriteRowCount
	1D7C 7C             LD A,H
	;; Find sprite blit destination:
    ;; &ViewBuff[Y-low * 6 + X-low / 4]
    ;; (X coordinates are in 2-bit units, want byte coordinate)
	1D7D 87             ADD A,A
	1D7E 84             ADD A,H
	1D7F 87             ADD A,A
	1D80 D9             EXX
	1D81 CB 3C          SRL H
	1D83 CB 3C          SRL H
	1D85 84             ADD A,H
	1D86 5F             LD E,A
	1D87 16 67          LD D,67												ViewBuff >> 8   ; #6700 + offset
	1D89 D5             PUSH DE												; Push destination.
	1D8A E5             PUSH HL												; Push X adjustments
	1D8B D9             EXX
	;; A = SpriteWidth & 4 ? -L * 4 : -L * 3
    ;; (Where L is the Y-adjustment for the sprite)
	1D8C 7D             LD A,L
	1D8D ED 44          NEG
	1D8F 47             LD B,A
	1D90 3A 37 35       LD A,(Sprite_Width)									get Sprite_Width
	1D93 E6 04          AND 04
	1D95 78             LD A,B
	1D96 20 04          JR NZ,btobj_0
	1D98 87             ADD A,A
	1D99 80             ADD A,B
	1D9A 18 02          JR btobj_1
btobj_0:
	1D9C 87             ADD A,A												*2
	1D9D 87             ADD A,A												*4
btobj_1:
	1D9E F5             PUSH AF
	;; Image and mask addressed loaded, and then adjusted by A.
	1D9F CD B3 35       CALL Load_sprite_image_address_into_DE
	1DA2 C1             POP BC
	1DA3 48             LD C,B
	1DA4 06 00          LD B,00
	1DA6 09             ADD HL,BC
	1DA7 EB             EX DE,HL
	1DA8 09             ADD HL,BC
	;; Rotate the sprite if not byte-aligned.
	1DA9 3A 9C 1C       LD A,(SpriteXStart)
	1DAC E6 03          AND 03
	1DAE C4 D6 1A       CALL NZ,BlitRot
	;; Get X adjustment back.
	1DB1 C1             POP BC
	1DB2 79             LD A,C
	1DB3 ED 44          NEG
	;; Rounded up divide by 4 to get byte adjustment...
	1DB5 C6 03          ADD A,03
	1DB7 0F             RRCA
	1DB8 0F             RRCA
	;; and apply to image and mask.
	1DB9 E6 07          AND 07
	1DBB 4F             LD C,A
	1DBC 06 00          LD B,00												BC = A
	1DBE 09             ADD HL,BC
	1DBF EB             EX DE,HL
	1DC0 09             ADD HL,BC
	;; Set it so that destination is in BC', image and mask in HL' and DE'.
	1DC1 C1             POP BC
	1DC2 D9             EXX
	;; Load DE with an index from the blit functions table. This selects
    ;; the subtable based on the sprite width.
	1DC3 3A 37 35       LD A,(Sprite_Width)									get Sprite_Width
	1DC6 D6 03          SUB 03
	1DC8 87             ADD A,A
	1DC9 5F             LD E,A
	1DCA 16 00          LD D,00
	1DCC 21 E5 1D       LD HL,BlitMaskFns
	1DCF 19             ADD HL,DE
	1DD0 5E             LD E,(HL)
	1DD1 23             INC HL
	1DD2 56             LD D,(HL)
	;; X overlap is still in A' from the IntersectObj call
	1DD3 08             EX AF,AF
	;; We use this to select the function within the subtable, which will
    ;; blit over n bytes worth, depending on the overlap size...
    ;; We convert the overlap in double-pixels into the overlap in bytes,
    ;; x2, to get the offset of the function in the table.
	1DD4 3D             DEC A
	1DD5 1F             RRA
	1DD6 E6 0E          AND 0E
	1DD8 6F             LD L,A
	1DD9 26 00          LD H,00
	1DDB 19             ADD HL,DE
	1DDC 7E             LD A,(HL)
	1DDD 23             INC HL
	1DDE 66             LD H,(HL)
	1DDF 6F             LD L,A
	;; Call the blit function with number of rows in B, destination in
    ;; BC', source in DE', mask in HL'
	1DE0 3A 9D 1C       LD A,(SpriteRowCount)								get SpriteRowCount
	1DE3 47             LD B,A
	1DE4 E9             JP (HL)					 							; Tail call (ie. will RET) to blitter...

;; -----------------------------------------------------------------------------------------------------------
.BlitMaskFns:
	1DE5 DATAWORD EB 1D             										BlitMasksOf1 1DEB
	1DE7 DATAWORD F1 1D             										BlitMasksOf2 1DF1
	1DE9 DATAWORD F9 1D             										BlitMasksOf3 1DF9
.BlitMasksOf1:
	1DEB DATAWORD 9A 14             										BlitMask1of3 149A
	1DED DATAWORD B5 14             										BlitMask2of3 14B5
	1DEF DATAWORD DD 14          											BlitMask3of3 14DD
.BlitMasksOf2:
	1DF1 DATAWORD 12 15             										BlitMask1of4 1512
	1DF3 DATAWORD 2F 15             										BlitMask2of4 152F
	1DF5 DATAWORD 59 15             										BlitMask3of4 1559
	1DF7 DATAWORD 90 15             										BlitMask4of4 1590
.BlitMasksOf3:
	1DF9 DATAWORD D3 15          											BlitMask1of5 15D3
	1DFB DATAWORD F2 15														BlitMask2of5 15F2
	1DFD DATAWORD 1E 16														BlitMask3of5 161E
	1DFF DATAWORD 57 16         											BlitMask4of5 1657
	1E01 DATAWORD 9C 16         											BlitMask5of5 169C

;; -----------------------------------------------------------------------------------------------------------
;; Given an object, calculate the intersections with
;; ViewXExtent and ViewYExtent. Also saves the X start in SpriteXStart.
;;
;; Parameters: HL contains object+2
;; Returns:
;;  Set carry flag if there's overlap
;;  X adjustments in HL', X overlap in A'
;;  Y adjustments in HL,  Y overlap in A
.IntersectObj:
	1E03 CD 36 1E       CALL GetShortObjExt
	1E06 78             LD A,B
	1E07 32 9C 1C       LD (SpriteXStart),A
	1E0A E5             PUSH HL
	1E0B ED 5B 98 1C    LD DE,(ViewXExtent)
	1E0F CD 52 1E       CALL IntersectExtent
	1E12 D9             EXX
	1E13 C1             POP BC
	1E14 D0             RET NC
	1E15 08             EX AF,AF
	1E16 ED 5B 9A 1C    LD DE,(ViewYExtent)
	1E1A CD 52 1E       CALL IntersectExtent
	1E1D C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Like GetShortObjExt, except it copes with tall objects.
;; If bit5 is set, H is adjusted by -12, if bit5 not set then H adjusted by -16
;;
;; TODO: I expect bit 5 set means it's two chained objects, 6 Z units
;; (12 Y units) apart. I expect bit 5 reset means it's a 3x32 object,
;; so we include the other 16 height.
;;
;; Parameters: Object+2 in HL
;; Returns: X extent in BC, Y extent in HL
.GetObjExtents:
	1E1E 23             INC HL
	1E1F 23             INC HL
	1E20 7E             LD A,(HL)
	1E21 CB 5F          BIT 3,A												; Tall bit set?
	1E23 28 14          JR Z,gsobjext_1										; Tail call out if not tall.
	1E25 CD 39 1E       CALL gsobjext_1										; Otherwise, call and return
	1E28 3A A2 1C       LD A,(SpriteFlags)
	1E2B CB 6F          BIT 5,A												; Chained object bit set?
	1E2D 3E F0          LD A,F0												-16 ; Bit not set - add 16 to height.
	1E2F 28 02          JR Z,goex_1
	1E31 3E F4          LD A,F4												-12 ; Bit set - add 12 to height.
goex_1:
	1E33 84             ADD A,H
	1E34 67             LD H,A												; Bring min Y up.
	1E35 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Sets SpriteFlags and generates extents for the object.
;; Parameters: Object+2 in HL
;; Returns: X extent in BC, Y extent in HL
.GetShortObjExt:
	1E36 23             INC HL
	1E37 23             INC HL
	1E38 7E             LD A,(HL)
	;; Put a flip flag in A if the "switched" bit is set on the object.
    ;; A = (object[4] & 0x10) ? 0x80 : 0x00
gsobjext_1:
	1E39 CB 67          BIT 4,A
	1E3B 3E 00          LD A,00
	1E3D 28 02          JR Z,gsobjext_2
	1E3F 3E 80          LD A,80
gsobjext_2:
	1E41 08             EX AF,AF
	1E42 23             INC HL
	1E43 CD 77 1E       CALL UVZtoXY				 						; Called with object + 5
	1E46 23             INC HL
	1E47 23             INC HL												; Now at object + 9
	1E48 7E             LD A,(HL)
	1E49 32 A2 1C       LD (SpriteFlags),A
	1E4C 2B             DEC HL
	1E4D 08             EX AF,AF
	1E4E AE             XOR (HL)											; Add extra horizontal flip to the sprite.
	1E4F C3 4A 35       JP GetSprExtents									; will RET

;; -----------------------------------------------------------------------------------------------------------
;; Calculate parameters to do with overlapping extents
;; Parameters:
;;  BC holds extent of sprite
;;  DE holds current extent
;; Returns:
;;  Sets carry flag if there's any overlap.
;;  H holds the extent adjustment
;;  L holds the sprite adjustment
;;  A holds the overlap size.
.IntersectExtent:
    ;; Check overlap and return NC if there is none.
	1E52 7A             LD A,D
	1E53 91             SUB C
	1E54 D0             RET NC												; C <= D, return
	1E55 78             LD A,B
	1E56 93             SUB E
	1E57 D0             RET NC												; E <= B, return
	; There's overlap. Calculate it.
	1E58 ED 44          NEG
	1E5A 6F             LD L,A												; L = E - B
	1E5B 78             LD A,B
	1E5C 92             SUB D												; A = B - D
	1E5D 38 0B          JR C,subIntersectExtent
	;; B >= D case
	1E5F 67             LD H,A
	1E60 79             LD A,C
	1E61 90             SUB B
	1E62 4D             LD C,L
	1E63 2E 00          LD L,00
	1E65 B9             CP C												; Return A = min(C - B, E - B)
	1E66 D8             RET C
	1E67 79             LD A,C
	1E68 37             SCF
	1E69 C9             RET

.subIntersectExtent:
	1E6A 6F             LD L,A
	1E6B 79             LD A,C
	1E6C 92             SUB D
	1E6D 4F             LD C,A
	1E6E 7B             LD A,E
	1E6F 92             SUB D
	1E70 B9             CP C
	1E71 26 00          LD H,00
	1E73 D8             RET C					 							; Return A = min(E - D, C - D)
	1E74 79             LD A,C
	1E75 37             SCF
	1E76 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Given HP pointing to an Object + 5, return X coordinate
;; in C, Y coordinate in B. Increments HL by 2.
;; 		.----------> X
;; 		|  V   U
;; 		|   \ /
;; 		|    |
;; 		|    Z
;; 		Y
.UVZtoXY:
	1E77 7E             LD A,(HL)
	1E78 57             LD D,A												; U coordinate
	1E79 23             INC HL
	1E7A 5E             LD E,(HL)											; V coordinate
	1E7B 93             SUB E
	1E7C C6 80          ADD A,80											; U - V + 128 = X coordinate
	1E7E 4F             LD C,A
	1E7F 23             INC HL
	1E80 7E             LD A,(HL)											; Z coordinate
	1E81 87             ADD A,A
	1E82 93             SUB E
	1E83 92             SUB D
	1E84 C6 7F          ADD A,7F
	1E86 47             LD B,A						 						; 2 * Z - U - V + 127 = Y coordinate
	1E87 C9             RET

;; -----------------------------------------------------------------------------------------------------------
; Pointer into stack for current origin coordinates
.DecodeOrgPtr:
	1E88 DATAWORD 8A 1E														DecodeOrgStack pointer (1E8A)

; Each stack entry contains UVZ coordinates
.DecodeOrgStack:
	1E8A DATABYTE 00 00 00
	1E8D DATABYTE 00 00 00
	1E90 DATABYTE 00 00 00
	1E93 DATABYTE 00 00 00

BaseFlags:				; object flags when builing a room
	1E96 DATABYTE 00
	1E97 DATABYTE 00

;; -----------------------------------------------------------------------------------------------------------
;; Offset 0: O_???? 'B' list next item pointer
;; Offset 2: O_????	'A' list next item pointer
;; Offset 4: O_FLAGS : Some flags:
;;           	Bits 0-2: Object Dimensions - see GetUVZExtents
;;           	Bit 3: Tall (extra 6 height)
;;           	Bit 4: Holds switch status for a switch.
;;           	Bit 5: Used on doors by Case3x56.
;;           	For doors, bits 4 and 5 hold the direction.
;;           	Bit 6: Object is a special collectable item.
;;			 	bits 6 and 7 causes skipping.
;; Offset 5: O_U : U coordinate
;; Offset 6: O_V : V coordinate
;; Offset 7: O_Z : Z coordinate, C0 = ground
;; Offset 8: O_SPRITE : Sprite code
;; Offset 9: O_SPRFLAGS : Sprite flags:
;;           	Bit 0 - perhaps is playable character?
;;           	Bit 1 set for other bit of double height?
;;           	Bit 2 = we're Head.
;;           	Bit 4 = non-deadlyness?
;;           	Bit 5 = 0 single height (one sprite) ; 1 double size (i.e. 2 sprites, need to Animate and move both sprites together as a single object);
;;				bit 6 = 0 : object has function; 1 : do not do function
;;           	Bit 7 = switched flag
;;           	Gets loaded into SpriteFlags
;; Offset A: O_FUNC : Function and Phase
;;				Top bit is flag that's checked against Phase
;;			 	Lower 6 bits are object function.
;; Offset B: O_????
;;				Bottom 4 bits are roller direction... last move dir for updated things.
;; Offset C: O_????
;;				Some form of direction bitmask?
;;           	how we're being pushed.
;;				I think bit 5 means 'being stood on'.
;; Offset D&E: O_????
;;				Object we're resting on. zeroed on the floor. Forms a pointer?
;; Offset F: O_ANIM : Animation code
;;				top 5 bits [7:3] are the animation code ([7:0] = ((index in AnimTable * 2) + 2) << 2)
;;				bottom 3 bits are the frame number.
;; Offset 10: O_DIRECTION : Direction code. I think this is not the bit mask.
;; Offset 11: O_SPECIAL : This may be several things depending on context:
;;				Z limits for helipad
;;				state for switch
;;				special indexd for specials items.

; Buffer for an object used during unpacking
.TmpObj_variables:					; 18 bytes
	1E98 DATABYTE 00				;	0 :
	1E99 DATABYTE 00				;	1 :
	1E9A DATABYTE 00				;	2 :
	1E9B DATABYTE 00				;	3 :
	1E9C DATABYTE 00				;	4 : O_FLAGS
	1E9D DATABYTE 00				;	5 : O_U coordinate
	1E9E DATABYTE 00				;	6 : O_V coordinate
	1E9F DATABYTE 00				;	7 : O_Z coordinate
	1EA0 DATABYTE 00				;	8 : O_SPRITE
	1EA1 DATABYTE 00				;	9 : O_SPRFLAGS
	1EA2 DATABYTE 00				;	A : O_FUNC
	1EA3 DATABYTE FF				;	B :
	1EA4 DATABYTE FF				;	C :
	1EA5 DATABYTE 00				;	D :
	1EA6 DATABYTE 00				;	E :
	1EA7 DATABYTE 00				;	F : O_ANIM
	1EA8 DATABYTE 00				;	10 : O_DIRECTION
	1EA9 DATABYTE 00				;	11 : O_SPECIAL

;; Bit 0: Do we loop?
;; Bit 1: Are all the switch flags the same in the loop?
;; Bit 2: If they're the same, the value.
UnpackFlags:
	1EAA DATABYTE 00

DataPtr:
	1EAB DATAWORD 0E CD														; Current pointer to bit-packed data (FetchData)
CurrData:
	1EAD DATABYTE 05														; The remaining bits to read at the current address.

ExpandDone:
	1EAE DATABYTE 00

DoorSprites:
	1EAF DATABYTE 00 00														; Sprites to use for L and R parts of the door.

;; Door flags when building a room (the value will be copied in
;; the object O_FLAGS).
;; Bits [5:4] as follows:
;;   nw=10/\01=ne
;;   sw=11\/00=se
;; Bits [2:1] : ???? but notice how the far doors (nw,ne) have a 7, left (nw,sw) have a 6, right (ne,se) have a 5, near (sw,se) have a 4
Door_Obj_Flags:  ; L  R  L  R  L  R  L  R
	1EB1 DATABYTE 27 26 17 15 05 04 36 34

RoomDimensionsIdx:
	1EB9 DATABYTE 00            			 								; The room Dimensions for the main room.
RoomDimensionsIdxTmp:
	1EBA DATABYTE 00            			 								; The room Dimensions for the room being processed.
FloorCode:
	1EBB DATABYTE 00														; The index of the floor pattern to use.
FloorAboveFlag:
	1EBC DATABYTE 00            			 								; Set if the room above has a floor.
SkipObj:
	1EBD DATABYTE 00            			 								; 0: draw objects: not0: don't AddObject (used when restoring room state in BuildRoom*)
color_scheme:
	1EBE DATABYTE 00														current Color scheme
WorldId:
	1EBF DATABYTE 00						 								0: "Blacktooth", 1: "Market", 2: "Egyptus", 3: "Penitentiary", 4: "Moon base", 5: "Book world", 6: "Safari", 7: "Prison"

;; -----------------------------------------------------------------------------------------------------------
;; Bit numbers for the doors:
;; 3/\2				8 = Extra_room in +V
;; 0\/1				4 = Extra room in +U
Has_no_wall:
	1EC0 DATABYTE 00
Has_Door:
	1EC1 DATABYTE 00

;; -----------------------------------------------------------------------------------------------------------
;; IY is pointed to MinU, and values are loaded in (based on RoomDimensions),
;; with IY incrementing to point after MaxV when loading is complete.
.Max_min_UV_Table:
	1EC2 DATABYTE 3A						; MinU Max_min_UV_Table+0 (don't care about these default values)
	1EC3 DATABYTE 8A						; MinV Max_min_UV_Table+1 (don't care about these default values)
	1EC4 DATABYTE 40						; MaxU Max_min_UV_Table+2 (don't care about these default values)
	1EC5 DATABYTE 32						; MaxV Max_min_UV_Table+3 (don't care about these default values)

; AltLimits[12] are also used as IY for drawing extra rooms.
AltLimits1:
	1EC6 DATABYTE 85 40 47 C9            									(these are supposed to be 00)
AltLimits2:
	1ECA DATABYTE F5 11 2C 41												(these are supposed to be 00)

;; -----------------------------------------------------------------------------------------------------------
;; Array of room Dimensions: Min U, Min V, Max U, Max V
;; Index into array is the RoomDimensionsIdx(Tmp)
.RoomDimensions:
	1ECE DATABYTE 08 08 48 48												Room type 0 : Min U, Min V, Max U, Max V
	1ED2 DATABYTE 08 10 48 40
	1ED6 DATABYTE 08 18 48 38
	1EDA DATABYTE 08 20 48 30
	1EDE DATABYTE 10 08 40 48												...
	1EE2 DATABYTE 18 08 38 48
	1EE6 DATABYTE 20 08 30 48
	1EEA DATABYTE 10 10 40 40												Room type 7 : Min U, Min V, Max U, Max V

;; -----------------------------------------------------------------------------------------------------------
;; Heights of the 4 doors, for the main room.
;; 0/\1
;; 3\/2
.DoorHeights:
	1EEE DATABYTE 00 00 00 00												; nw ne se sw doors

;; Locations of the 4 doors along their respective walls, for the room
;; currently being processed.
.DoorHeightsTmp:
	1EF2 DATABYTE 00 00 00 00												; nw ne se sw doors

; The height of the highest door present.
.HighestDoor:
	1EF6 DATABYTE C0														; The height of the highest door present.

;; -----------------------------------------------------------------------------------------------------------
;; 2 Functions:
;; * BuildRoom : reset room, read room data and rebuild evreything (including objects).
;; * BuildRoomNoObj : Like BuildRoom, but we skip calling AddObject on the
;; main room. ;; Used when restoring previously-stashed room state.
;; (SkipObj will be reset by BuildRoom soon afterwards.)
.BuildRoomNoObj:
	1EF7 3E FF          LD A,FF
	1EF9 32 BD 1E       LD (SkipObj),A										; SkipObj=-1 : Skip buildin Objects (already in memory)
.BuildRoom:
	1EFC FD 21 C2 1E    LD IY,Max_min_UV_Table								; points on MinU
	1F00 21 D0 30       LD HL,30D0											; ViewXExtent full screen X
	1F03 22 98 1C       LD (ViewXExtent),HL
	1F06 21 FF 00       LD HL,00FF											; ViewXExtent full screen Y
	1F09 22 9A 1C       LD (ViewYExtent),HL
	1F0C 21 C0 C0       LD HL,C0C0											; reset values for door height; #C0 is ground level
	1F0F 22 F2 1E       LD (DoorHeightsTmp),HL								; nw ne doors; init value
	1F12 22 F4 1E       LD (DoorHeightsTmp+1),HL							; se sw doors; init value
	1F15 21 00 00       LD HL,0000											; UV origin (0,0) for ReadRoom
	1F18 ED 4B 0E 01    LD BC,(current_Room_ID)								; get current_Room_ID in BC
	1F1C CD B8 1F       CALL ReadRoom										; read room data
	1F1F AF             XOR A												; A = 0
	1F20 32 BD 1E       LD (SkipObj),A										; Reset SkipObj to 0 (reset to "Build room AND the objects")
	1F23 32 F6 1E       LD (HighestDoor),A									; reset highest door
	1F26 2A A3 39       LD HL,(Object_Destination)							get Object_Destination buffer pointer
	1F29 22 BD 39       LD (Saved_Object_Destination),HL					update Saved_Object_Destination
	1F2C 3A BA 1E       LD A,(RoomDimensionsIdxTmp)							copy temp room dimension
	1F2F 32 B9 1E       LD (RoomDimensionsIdx),A							into RoomDimensionsIdx
	1F32 11 EE 1E       LD DE,DoorHeights									copy 4 doors heights from ...
	1F35 21 F2 1E       LD HL,DoorHeightsTmp								... tmp to object array
	1F38 01 04 00       LD BC,0004											... (nw ne se sw)
	1F3B ED B0          LDIR												repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	1F3D 21 00 6A       LD HL,6A00											BkgndData buffer
	1F40 01 40 00       LD BC,0040											BkgndDataLen erase #0040 (64) bytes from #6A00
	1F43 CD 67 24       CALL Erase_forward_Block_RAM						Erase BkgndData buffer
	1F46 CD D0 22       CALL DoConfigWalls									do Walls
	1F49 CD D8 21       CALL HasFloorAbove									check if Floor Above (Carry set = no Floor Above)
	1F4C 3E 00          LD A,00
	1F4E 17             RLA													get Carry into bit0 of FloorAboveFlag
	1F4F 32 BC 1E       LD (FloorAboveFlag),A								bit0: if 0: Floor above or No room above; if 1: room with no floor above
	1F52 CD 4A 3C       CALL StoreCorner									get where the far corner would be
	1F55 2A C0 1E       LD HL,(Has_no_wall)									get Has_no_wall (in L) and Has_Door (in H) values
	1F58 E5             PUSH HL												save it
	1F59 7D             LD A,L												A = Has_no_wall
	1F5A E6 08          AND 08												test bit3 (Nw wall)
test_if_wall_far_V:
	1F5C 28 1C          JR Z,test_if_wall_far_U								if 0 then has Nw wall jump test_if_wall_far_U, else:
	;; Draw the room in V direction (Nw side)								current room has no Nw wall (can see further in next room)
	1F5E 3E 01          LD A,01
	1F60 CD C1 39       CALL SetObjList										index 1 in obj list
	1F63 ED 4B 0E 01    LD BC,(current_Room_ID)								get current_Room_ID
	1F67 78             LD A,B												Room ID UV
	1F68 3C             INC A												V+1
	1F69 A8             XOR B
	1F6A E6 0F          AND 0F												ignore the carry that could have impacted U (get back real U and roll over V if needed)
	1F6C A8             XOR B
	1F6D 47             LD B,A												BC = id of the next room Nw side
	1F6E 3A C5 1E       LD A,(Max_min_UV_Table+3)							MaxV
	1F71 67             LD H,A
	1F72 2E 00          LD L,00												Set HL to MaxV value (UV origin)
	1F74 CD B8 1F       CALL ReadRoom										Read that other room; ; IY pointing to AltLimits1.
	1F77 CD D0 22       CALL DoConfigWalls									and add wall config to current room config
test_if_wall_far_U:
	1F7A FD 21 CA 1E    LD IY,AltLimits2
	1F7E E1             POP HL												restore Has_no_wall (in L) and Has_Door (in H) values
	1F7F E5             PUSH HL												save them again
	1F80 7D             LD A,L
	1F81 E6 04          AND 04												test bit2 (Ne wall)
	1F83 28 1D          JR Z,bldroom_2										if Ne side has a wall, jump bldroom_2, else:
	;; Draw the room in U direction (Ne side)								current room has no Ne wall (can see further in next room)
	1F85 3E 02          LD A,02												object list 2
	1F87 CD C1 39       CALL SetObjList
	1F8A ED 4B 0E 01    LD BC,(current_Room_ID)								get current_Room_ID
	1F8E 78             LD A,B												BC = room id UV
	1F8F C6 10          ADD A,10											U+1 (next far room in Ne)
	1F91 A8             XOR B
	1F92 E6 F0          AND F0												make sure V has not been touched, rool over U if needed
	1F94 A8             XOR B
	1F95 47             LD B,A												BC = next room Ne side
	1F96 3A C4 1E       LD A,(Max_min_UV_Table+2)							MaxU
	1F99 6F             LD L,A
	1F9A 26 00          LD H,00												Set HL offset to MaxU (UV origin)
	1F9C CD B8 1F       CALL ReadRoom										Read that room IY pointing to AltLimits2.
	1F9F CD D0 22       CALL DoConfigWalls									and add it ti current to visualize
bldroom_2:																	now do Doors
	1FA2 3A F6 1E       LD A,(HighestDoor)
	1FA5 2A AF 1E       LD HL,(DoorSprites)
	1FA8 F5             PUSH AF
	1FA9 CD E8 34       CALL OccludeDoorway					 				Occlude edge of door sprites at the back.
	1FAC F1             POP AF
	1FAD CD FB 16       CALL SetPillarHeight 								pillar is as high as the tallest door
	1FB0 E1             POP HL
	1FB1 22 C0 1E       LD (Has_no_wall),HL									Restore value from first pass
	1FB4 AF             XOR A												Switch back to usual object list (index 0).
	1FB5 C3 C1 39       JP SetObjList

;; -----------------------------------------------------------------------------------------------------------
;; Unpacks a room, adds all its sprites to the lists.
;; See "Room_list1" comments for the Room data format.
;; Inputs: IY points to where we stash the room size.
;; 		   BC = Room Id
;; 		   HL = UV origin of the room
.ReadRoom:
	1FB8 22 8A 1E       LD (DecodeOrgStack),HL				  				; Initialize UV origin.
	1FBB AF             XOR A
	1FBC 32 8C 1E       LD (DecodeOrgStack+2),A								; and Z origin (to 0)
	1FBF C5             PUSH BC
	1FC0 CD EF 21       CALL FindVisitRoom									; find Room ID in BC and set the "visited" bit; DataPtr and CurrData point on the begining of the room data.
	1FC3 06 03          LD B,03												; number of bit to fetch from CurrData
	1FC5 CD B2 22       CALL FetchData										; Fetch room dimension code
	1FC8 32 BA 1E       LD (RoomDimensionsIdxTmp),A							; 3 first bits are "Room dimensions"
	1FCB 87             ADD A,A												; *2
	1FCC 87             ADD A,A												; *4  (4 bytes min u,v max u,v)
	1FCD C6 CE          ADD A,CE											; (RoomDimensions & #00FF) + (room index offset * 4)
	1FCF 6F             LD L,A
	1FD0 CE 1E          ADC A,1E											; (RoomDimensions & #FF00) >> 8
	1FD2 95             SUB L
	1FD3 67             LD H,A												; HL = RoomDimensions + (4*RoomDimensionsIdxTmp)
	1FD4 06 02          LD B,02												; U, then V
	1FD6 DD 21 8A 1E    LD IX,DecodeOrgStack								; Origin: IX:U, IX+1:V, IX+2:Z ; Load U, then V room Dimensions and origin.
rdroom_1:
	1FDA 4E             LD C,(HL)											; read min dimension
	1FDB DD 7E 00       LD A,(IX+00)										; get origin (U at 1st loop, V at 2nd loop)
	1FDE A7             AND A												; test origin
	1FDF 28 0B          JR Z,rdroom_jump									; if 0 jump rdroom_jump (use min), else:
    ;; subtracting C and dividing by 8 to create grix
    ;; coordinates, and store the unadjusted value in IY.
	1FE1 91             SUB C												; orig - min
	1FE2 5F             LD E,A												; save that value
	1FE3 1F             RRA
	1FE4 1F             RRA
	1FE5 1F             RRA													; div8
	1FE6 E6 1F          AND 1F												; mod32
	1FE8 DD 77 00       LD (IX+00),A										; update origin (U, then V at 2nd loop)
	1FEB 7B             LD A,E												; restore saved value so orig will be calculated as equal the previous/original one
rdroom_jump:
	1FEC 81             ADD A,C												; orig + min
	1FED FD 77 00       LD (IY+00),A										; update coord
	1FF0 23             INC HL												; Then do "V" dimension
	1FF1 DD 23          INC IX												; next orig coord value
	1FF3 FD 23          INC IY												; next coord byte in result
	1FF5 10 E3          DJNZ rdroom_1										; loop a 2nd time for V
	1FF7 06 02          LD B,02
rdroom_2:																	; Take previous origin, multiply by 8 and add max U/V.
	1FF9 DD 7E FE       LD A,(IX+FE)										; IX-2 (recently updated orig U, then V at 2nd loop)
	1FFC 87             ADD A,A
	1FFD 87             ADD A,A
	1FFE 87             ADD A,A												; *8
	1FFF 86             ADD A,(HL)											; add max
	2000 FD 77 00       LD (IY+00),A										; Then save it.
	2003 FD 23          INC IY												; next byte in coords
	2005 DD 23          INC IX												; next orig value
	2007 23             INC HL												; redo it for maxV
	2008 10 EF          DJNZ rdroom_2										; loop again
	; Read the room Color Scheme, WorldId and FloorCode:
	200A 06 03          LD B,03												; number of bit to fetch from CurrData
	200C CD B2 22       CALL FetchData										; Fetch color scheme
	200F 32 BE 1E       LD (color_scheme),A									; update color scheme
	2012 06 03          LD B,03												; number of bit to fetch from CurrData
	2014 CD B2 22       CALL FetchData										; Fetch World ID
	2017 32 BF 1E       LD (WorldId),A										; update the current world identifier
	201A CD DE 20       CALL DoWallsnDoors									; this will fetch 3+4*3 bits to setup the Walls and Doors
	201D 06 03          LD B,03												; number of bit to fetch from CurrData
	201F CD B2 22       CALL FetchData										; Fetch Floor Tile Id
	2022 32 BB 1E       LD (FloorCode),A									; update the floor pattern to use
	2025 CD D6 19       CALL SetFloorAddr									; update FloorAddr
rdroom_loop:
	2028 CD 7E 20       CALL ProcEntry										; Loop to process objects in the room.
	202B 30 FB          JR NC,rdroom_loop									; until all data have been processed
	202D C1             POP BC
	202E C3 F7 3E       JP AddSavedCrowns_and_SpecialItems					; now add the special items and update saved worlds ?? TODO ; will RET

;; -----------------------------------------------------------------------------------------------------------
;; value going in are 3-bit signed value (-4 to +3)
;; we add that value to the value in (HL)
;; Return result in A
.Add3Bit:
	2031 CB 57          BIT 2,A												; is 3b value negative?
	2033 28 02          JR Z,add3b_1										; no (0 to +3), so jump add3b_1, else:
	2035 F6 F8          OR F8												; gen negative value on 8bit (-4 to -1)
add3b_1:
	2037 86             ADD A,(HL)											; add A to (HL)
	2038 C9             RET													; return A

;; -----------------------------------------------------------------------------------------------------------
;; Recursively do ProcEntry. Macro code is in A.
.RecProcEntry:
	2039 08             EX AF,AF
    ; When processing recursively, we read local UVZ values to adjust the
    ; origin for the macro-expanded processing (so a Macro can be played
    ; at any position you like).
    ; Read values UVZ into B, C, A
	203A CD 9D 22       CALL FetchData333									; from CurrData ; fetch 3*3bits (UVZ) : 3bits going in B, 3 in C and 3 in A to adjust origin
	203D 2A 88 1E       LD HL,(DecodeOrgPtr)								; get room origin
	2040 F5             PUSH AF
	2041 78             LD A,B						 						; Adjust U value
	2042 CD 31 20       CALL Add3Bit
	2045 47             LD B,A
	2046 23             INC HL
	2047 79             LD A,C												; Adjust V value
	2048 CD 31 20       CALL Add3Bit
	204B 4F             LD C,A
	204C 23             INC HL
	204D F1             POP AF
	204E D6 07          SUB 07
	2050 86             ADD A,(HL)											; Adjust Z value (slightly different)
	2051 23             INC HL
	2052 22 88 1E       LD (DecodeOrgPtr),HL								; Write out origin values, update pointer
	2055 70             LD (HL),B
	2056 23             INC HL
	2057 71             LD (HL),C
	2058 23             INC HL
	2059 77             LD (HL),A
	205A 3A AD 1E       LD A,(CurrData)										; save the current read pointer.
	205D 2A AB 1E       LD HL,(DataPtr)
	2060 F5             PUSH AF												; save CurrData and DataPtr
	2061 E5             PUSH HL
	2062 CD C6 21       CALL FindMacro										; find the Macro in Room_Macro_data
	2065 22 AB 1E       LD (DataPtr),HL										; update DataPtr with MacroData
rpent_loop:
	2068 CD 7E 20       CALL ProcEntry
	206B 30 FB          JR NC,rpent_loop
	206D 2A 88 1E       LD HL,(DecodeOrgPtr)								; origin
	2070 2B             DEC HL
	2071 2B             DEC HL
	2072 2B             DEC HL
	2073 22 88 1E       LD (DecodeOrgPtr),HL
	2076 E1             POP HL
	2077 F1             POP AF
	2078 22 AB 1E       LD (DataPtr),HL										; And restore the read pointer.
	207B 32 AD 1E       LD (CurrData),A
;; -----------------------------------------------------------------------------------------------------------
;; Process one entry in the room description array. Returns carry when done.
.ProcEntry:
	207E 06 08          LD B,08												; number of bit to fetch from CurrData
	2080 CD B2 22       CALL FetchData										; Get object ID, or Macro Id or FF
	2083 FE FF          CP FF												; is it FF
	2085 37             SCF													; Carry = 1
	2086 C8             RET Z												; if was FF leave with Z and Carry=1, else:
	2087 FE C0          CP C0												; Code >= $C0 means Macro (recurse).
	2089 30 AE          JR NC,RecProcEntry									; if fetched byte was >= #C0 go Recurse RecProcEntry (macro), else:
	208B FD E5          PUSH IY												; save the room size pointer in IY
	208D FD 21 98 1E    LD IY,TmpObj_variables								; IY points on 18-byte temp variable
	2091 CD F5 36       CALL InitObj										; Init the Object
	2094 FD E1          POP IY												; get back room size pointer
	2096 06 02          LD B,02												; number of bit to fetch from CurrData
	2098 CD B2 22       CALL FetchData										; get next 2bits:
	;; The 2 bits fetched are:
	;; Bit0, if 0 : only one object with current object code;
	;;       if 1 : several objects to create with current object code.
	;; Bit1, if 0 : we will need to fetch one bit before every coord-set to get the per-object orientation bit.
	;;       if 1 : the next fetched bit will serve as orientation bit for all onjects in that group.
	209B CB 4F          BIT 1,A												; test bit1 (mode one-bit for all or read-new-bit-each-time)
	209D 20 04          JR NZ,global_orientation_bit						; if set (global orientation bit), jump global_orientation_bit, else:
	209F 3E 01          LD A,01												; set A to 3b001
	20A1 18 0A          JR pent_1											; jump pent_1

global_orientation_bit:														; Read once and store in the bit2.
	20A3 F5             PUSH AF												; save value in A
	20A4 06 01          LD B,01												; number of bit to fetch from CurrData
	20A6 CD B2 22       CALL FetchData										; get one more bit (global orientation bit : "0"=NO Flip; "1"=Flip)
	20A9 C1             POP BC												; restore saved AF value in BC
	20AA 07             RLCA
	20AB 07             RLCA												; Shift left twice the global orientation bit (put in bit2)
	20AC B0             OR B												; in A we have 3b'<orientation_bit_value>01
pent_1:
	20AD 32 AA 1E       LD (UnpackFlags),A									; save 3b flag value from A in UnpackFlags
pent_loop:
	20B0 CD 37 22       CALL SetTmpObjFlags									; update object flags
	20B3 CD 6B 22       CALL SetTmpObjUVZEx									; get its coordinates ; 3*3 bits fetched per object for UVZ
	20B6 3A AA 1E       LD A,(UnpackFlags)									; load 3b flag value in A
	20B9 1F             RRA													; A >> 1 : bit0 in Carry
	20BA 30 0B          JR NC,pent_one_obj									; if bit0 was 0 (one object) jump pent_one_obj, else:
	20BC 3A AE 1E       LD A,(ExpandDone)									; get ExpandDone (UVZ = "770" put "FF" in ExpandDone which is a code for stop)
	20BF 3C             INC A												; +1 (if FF will be 0)
	20C0 A7             AND A												; test
	20C1 C8             RET Z												; if 0 (in other words if it was "FF") then RET, else:
	20C2 CD CC 20       CALL AddObjOpt										; else AddObjOpt and
	20C5 18 E9          JR pent_loop										; loop to (try to) create another object with same code ID.

pent_one_obj:
	20C7 CD CC 20       CALL AddObjOpt										; AddObjOpt and
	20CA A7             AND A												; test A
	20CB C9             RET													; Return (update Z and Carry)

;; -----------------------------------------------------------------------------------------------------------
;; If SkipObj is zero, do an "AddObject"; else skip AddObject
.AddObjOpt:
	20CC 21 98 1E       LD HL,TmpObj_variables								; point on tmp Object array
	20CF 01 12 00       LD BC,0012											; length #12 bytes
	20D2 FD E5          PUSH IY
	20D4 3A BD 1E       LD A,(SkipObj)										; if SkipObj...
	20D7 A7             AND A												; ...test SkipObj...
	20D8 CC F1 39       CALL Z,AddObject									; is 0 then do AddObject (else don't)
	20DB FD E1          POP IY
	20DD C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Initialise the doors. IY is pointing a byte after Max_min_UV_Table (IY = Max_min_UV_Table+4)
;; and will be accessed with negative offsets.
.DoWallsnDoors:
	20DE 06 03          LD B,03												; number of bit to fetch from CurrData
	20E0 CD B2 22       CALL FetchData										; A = DoorId (theorically 0 to 7, but only 0 to 3 is used)
	20E3 CD 5D 04       CALL ToDoorId										; if A<3 get A, else A-1 (since only 0,1,2,3 is used as input, it returns 0,1,2,2)
	20E6 87             ADD A,A												; *2
	20E7 6F             LD L,A												; Left part of the door
	20E8 67             LD H,A
	20E9 24             INC H												; Right part of the door
	20EA 22 AF 1E       LD (DoorSprites),HL									; store the pointer on the door sprite data
	20ED DD 21 B1 1E    LD IX,Door_Obj_Flags
	20F1 21 F2 1E       LD HL,DoorHeightsTmp								; nw door ; 1EF2+0 ; Door heights are stored in DoorHeightsTmp.
	20F4 D9             EXX
	20F5 FD 7E FF       LD A,(IY+FF)										; nw door ; IY-1 = Max_min_UV_Table+3 ; MaxV
	20F8 C6 04          ADD A,04											; tmp obj V = MaxV + 4
	20FA CD 5B 21       CALL DoWallnDoorU									; calc tmp obj U and place Door sprites
	20FD 21 F3 1E       LD HL,DoorHeightsTmp+1  							; ne door ; 1EF2+1
	2100 D9             EXX
	2101 FD 7E FE       LD A,(IY+FE)										; ne door ; IY-2 = Max_min_UV_Table+2 ; MaxU
	2104 C6 04          ADD A,04											; tmp obj U = MaxU + 4
	2106 CD 4F 21       CALL DoWallnDoorV									; calc tmp obj V and place Door sprites
	2109 21 F4 1E       LD HL,DoorHeightsTmp+2								; se door ; 1EF2+2
	210C D9             EXX
	210D FD 7E FD       LD A,(IY+FD)										; se door ; IY-3 = Max_min_UV_Table+1 ; MinV
	2110 D6 04          SUB 04												; tmp obj V = MinV - 4
	2112 CD 5B 21       CALL DoWallnDoorU									; calc tmp obj U and place Door sprites
	2115 21 F5 1E       LD HL,DoorHeightsTmp+3								; sw door ; 1EF2+3
	2118 D9             EXX
	2119 FD 7E FC       LD A,(IY+FC)										; sw door ; IY-4 = Max_min_UV_Table+0 ; MinU
	211C D6 04          SUB 04												; tmp obj U = MinU - 4
	211E C3 4F 21       JP DoWallnDoorV										; calc tmp obj V and place Door sprites

;; -----------------------------------------------------------------------------------------------------------
;; Update flags into Has_no_vall and Has_Door; this will be called for all 4 walls/doors
;; so both Has_no_vall and Has_Door will have 4 meaningful bits [3:0] for Nw,Ne,Se,Sw
;; if needed; sets the door Z coord in TmpObj_variables and HL' (DoorHeightsTmp pointer).
;; Read value:
;;  0 : Wall, No door
;;  1 : No wall, No door.
;;  2..7 :  Door; Door Height #A2 to #C0 (ground level)
;; Return: Has_no_vall and Has_Door updated
;;         Carry reset = has no door; Carry set = has door
.FetchWallnDoor:
	2121 06 03          LD B,03												; number of bit to fetch from CurrData
	2123 CD B2 22       CALL FetchData										; (value 0 to 7)
	2126 21 C0 1E       LD HL,Has_no_wall									; HL points on Has_no_vall (HL) and Has_Door (HL+1) bytes
	2129 D6 02          SUB 02												; test if data if < 2
	212B 38 17          JR C,FetchedNoDoor									; if data = 0 or 1 jump "FetchedNoDoor", else Carry=0 (has door):
fetchedDoor:
	212D CB 16          RL (HL)												; put Carry=0 into "Has_no_wall" bit0 (has door, hence has wall?) and push left the other bits (other walls)
	212F 23             INC HL												; move on "Has_Door"
	2130 37             SCF													; Carry=1
	2131 CB 16          RL (HL)												; put a 1 into bit0 of "Has_Door" (has door) and push left the other bits (other doors)
	2133 D6 07          SUB 07												; these 2 lines convert...
	2135 ED 44          NEG													; ...initial data height 2..7 to value 7..2, so initial data of 7 becomes ground level (#C0)
	2137 4F             LD C,A												; *1
	2138 87             ADD A,A												; *2
	2139 81             ADD A,C												; *3
	213A 87             ADD A,A												; *6
	213B C6 96          ADD A,96											; +#96 : an initial data of 2 gives $C0=ground level, for a data of 7 we have a max value #A2
	213D 32 9F 1E       LD (TmpObj_variables+O_Z),A							; update object A
	2140 37             SCF													; Return with Carry set = Door found
	2141 D9             EXX
	2142 77             LD (HL),A											; update DoorHeightsTmp
	2143 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; If no door is found on the current side, update the corresponding bit in:
;;  * Has_no_vall (0  = Wall or 1 NoWall);
;;  * Has_Door (0 = No Door)
FetchedNoDoor:																; No door case:
	2144 FE FF          CP FF												; test if FF (FF, Carry=0 : data was 1 = NoWall/NoDoor; FE, Carry=1: data was 0 = Wall/NoDoor)
	2146 3F             CCF													; flip Carry flag, so now Carry=data (1 = NoWall/NoDoor; 0 = Wall/NoDoor)
	2147 CB 16          RL (HL)												; Rotate Carry into Has_no_vall bit0 (0 (Wall/NoDoor = has wall) or 1 (NoWall/NoDoor = has no door)) and push left the other bits (other walls)
	2149 A7             AND A												; refresh Carry bit with 0
	214A 23             INC HL												; HL now points on Has_Door
	214B CB 16          RL (HL)												; put a Carry=0 into Has_Door bit0 (No door) and push left the other bits (other doors)
	214D A7             AND A												; refresh Carry with 0
	214E C9             RET													; Return with Carry reset

;; -----------------------------------------------------------------------------------------------------------
;; Build a Door on the U or V axis:
;; DoWallnDoorV : Build a door parallel to the V axis (Nw and Se sides).
;; DoWallnDoorU : Build a door parallel to the U axis (Ne and Sw sides).
;; Coordinate of the wall plane in A
;; HL' point on the coordinates
;; IX points to flags to use (Door_Obj_Flags).
.DoWallnDoorV:
	214F 32 9D 1E       LD (TmpObj_variables+O_U),A
	2152 21 9E 1E       LD HL,TmpObj_variables+O_V							; V
	2155 3A 8B 1E       LD A,(DecodeOrgStack+1)				  				; V orig offset
	2158 C3 64 21       JP DoWallnDoorAux									; will RET

.DoWallnDoorU:
	215B 32 9E 1E       LD (TmpObj_variables+O_V),A
	215E 21 9D 1E       LD HL,TmpObj_variables+O_U							; U
	2161 3A 8A 1E       LD A,(DecodeOrgStack)					  			; U orig offset
	;; will flow into DoWallnDoorAux
;; -----------------------------------------------------------------------------------------------------------
;; HL points to the object's coordinate field to write to
;; A holds the origin value in that dimension.
;; Takes extra parameters in IX
;; IX (object flags) and HL' (pointer to relevant DoorHeightsTmp entry).
;; 		V   U
;; 		 \ /
;; 		  |
;; 		  Z
.DoWallnDoorAux:
	2164 87             ADD A,A												; orig coord *2
	2165 87             ADD A,A												; *4
	2166 87             ADD A,A												; *8 => grid to pix
	2167 F5             PUSH AF
	2168 C6 24          ADD A,24											; #24 in the coordinate offset of the left part of the door sprite
	216A 77             LD (HL),A											; TmpObj_var coord
	216B E5             PUSH HL
	; Get the door Z coordinate set up, return if no object to add.
	216C CD 21 21       CALL FetchWallnDoor									; note: it does a EXX
	216F 30 4E          JR NC,NoDoorRet										; no door leave, else:
	; Draw the first half of the door
	2171 DD 7E 00       LD A,(IX+00)										; get Door_Obj_Flags
	2174 32 9C 1E       LD (TmpObj_variables+O_FLAGS),A						; Set the TmpObj flags
	2177 DD 23          INC IX												; next index in Door_Obj_Flags
	2179 3A AF 1E       LD A,(DoorSprites)									; first half door sprite
	217C 32 A0 1E       LD (TmpObj_variables+O_SPRITE),A					; Set the sprite.
	217F CD 95 21       CALL AddHalfDoorObj									; Add the first half door object
	; Draw the other half of the door
	2182 DD 7E 00       LD A,(IX+00)										; next door's flag
	2185 32 9C 1E       LD (TmpObj_variables+O_FLAGS),A						; update tmp object flag
	2188 DD 23          INC IX												; point on next flag byte
	218A 3A B0 1E       LD A,(DoorSprites+1)								; get sprite code for the other half of the door
	218D 32 A0 1E       LD (TmpObj_variables+O_SPRITE),A					; update tmp obj sprite
	2190 E1             POP HL
	2191 F1             POP AF
	2192 C6 2C          ADD A,2C											; need to add a coord offset of #2C for the right part of the door; note that to create the 3D effect, that sprite overlaps the left part by a third
	2194 77             LD (HL),A											; Update coord
.AddHalfDoorObj:
	;; Adds the current object in TmpObj_variables
	2195 CD CC 20       CALL AddObjOpt										; Add current object.
	;; Return early for the far doors. Only add ledges for the near doors.
	2198 3A 9C 1E       LD A,(TmpObj_variables+O_FLAGS)						; recover the current flag
	219B 4F             LD C,A												; get door flags
	219C E6 30          AND 30												; test bits [5:4]
	219E E0             RET PO												; if both bits 5 and 4 are different (01 or 10 = far walls side) leave (no need for a door step), else if equal (00 or 11 = near walls side):
	;; If the door is at ground level, then can leave.
	219F E6 10          AND 10												; keep only bit4
	21A1 F6 01          OR 01												; set bit0 (A can be #01 or #11)
	21A3 32 9C 1E       LD (TmpObj_variables+O_FLAGS),A						; update flags
	21A6 3A 9F 1E       LD A,(TmpObj_variables+O_Z)							; get height
	21A9 FE C0          CP C0												; compare with ground level
	21AB C8             RET Z												; $C0 is ground level, don't need to put anything underneath (leave).
	; Otherwise, add a doorstep under the doorway (6 down)
	21AC F5             PUSH AF												; else, the door is on the near side, and not on ground level, so need to draw a doorstep underneath
	21AD C6 06          ADD A,06											; Z minus 6 (Z axis goes down)
	21AF 32 9F 1E       LD (TmpObj_variables+O_Z),A          				; Update Z coord
	21B2 3E 54          LD A,54												; SPR_DOORSTEP
	21B4 32 A0 1E       LD (TmpObj_variables+O_SPRITE),A     				; Update sprite code to doorstep
	21B7 CD CC 20       CALL AddObjOpt										; Add the step to the object list
	21BA F1             POP AF
	21BB 32 9F 1E       LD (TmpObj_variables+O_Z),A          				; And restore Z.
	21BE C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; No door case - unwind variables and return
.NoDoorRet:
	21BF E1             POP HL
	21C0 F1             POP AF
	21C1 DD 23          INC IX
	21C3 DD 23          INC IX
	21C5 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Finds a Macro used to Build a room
;; Reset CurrData. Macro id we are searching is passed in A'.
;; Returns a pointer to a specific room description macro in Room_Macro_data
.FindMacro:
	21C6 3E 80          LD A,80
	21C8 32 AD 1E       LD (CurrData),A										; Clear buffered byte with value #80.
	21CB 21 D0 50       LD HL,Room_Macro_data								; point on Macro table
	21CE 08             EX AF,AF                                            ; recover the Macro ID stared in A'
	21CF 16 00          LD D,00
fm_loop:
	21D1 5E             LD E,(HL)											; DE=first byte = macro length
	21D2 23             INC HL												; next byte, is macro Id
	21D3 BE             CP (HL)												; Have we found the macro Id in A' we are looking for?
	21D4 C8             RET Z												; yes, leave with Macro pointer in HL
	21D5 19             ADD HL,DE											; jump to next macro
	21D6 18 F9          JR fm_loop											; loop

;; -----------------------------------------------------------------------------------------------------------
;; Checks if the room above the current one exists and has no floor (so we can get in by going up)
;; Returns with Carry set if the room above has a floor.
;; Returns with Carry reset if the room above has No floor.
.HasFloorAbove:
	21D8 ED 4B 0E 01    LD BC,(current_Room_ID)								; get current_Room_ID
	21DC 79             LD A,C
	21DD 3D             DEC A												; C is low byte of RoomID; 4msb=Z, lsb=0. For exemple : #40-1 = #3F; #3F and #F0 = #30 so new Z=3
	21DE E6 F0          AND F0												; room Z-1 = room above
	21E0 4F             LD C,A
	21E1 CD F8 21       CALL FindRoom										; Look if a room ID U,V,Z-1 exists
	21E4 D8             RET C												; if Carry set=room not found, so leave, else:
check_floorid_above:
    ;; Room Data Format (excluding size byte) is:
	;; 12b roomID UVZ, 3b roomDimensions, 3b colorScheme,
	;; 3b WorldId, 15b door data, 3b floorId, 8b Object, etc.
	;; 		uuuuvvvv_zzzzdddc_ccwwwDDD_pppDDDpp_pDDDfffo_ooooooo..
	;; DE currently pointing on the second byte, so +3 points on the
	;; byte with the floorId. ORing #F1 checks if floorId is 7 (no floor).
	21E5 13             INC DE
	21E6 13             INC DE
	21E7 13             INC DE												; DE+3 = point on the data byte with FloorId
	21E8 1A             LD A,(DE)											; get data
	21E9 F6 F1          OR F1												; test bits [3:1]
	21EB 3C             INC A												; if bits were 3b111, A is now 0 (Floor code 7 means "no floor")
	21EC C8             RET Z												; Return with Z set and Carry reset if that room has no floor.
	21ED 37             SCF													; else:
	21EE C9             RET													; Return with Carry set if there's a floor

;; -----------------------------------------------------------------------------------------------------------
;; Like FindRoom, but set the "visited" bit (in RoomMask_buffer) as well.
;; Input: Takes room Id in BC.
;; Return: First data byte in A, and room bit mask & location (in RoomMask_buffer) in C' and HL'.
;; Return: Carry set=not found or Carry reset=found)
;; If found, DataPtr and CurrData are updated, and pointing on the
;; begining of the room actual data (after room ID)
.FindVisitRoom:
	21EF CD F8 21       CALL FindRoom										; Calls FindRoom
	21F2 D9             EXX													; get the room bit mask & location (in RoomMask_buffer) in C' and HL'.
	21F3 79             LD A,C												; get current RoomMask (indicating which bit to set)
	21F4 B6             OR (HL)												; add it to the value already in RoomMask_buffer
	21F5 77             LD (HL),A											; and update RoomMask_buffer
	21F6 D9             EXX													; return to not-prime registers
	21F7 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Find room data if room exist.
;; Input: Takes room id in BC.
;; Return: First data byte in A, and room bit mask & location (in RoomMask_buffer) in C' and HL'.
;; Return: Carry set=not found or Carry reset=found)
;; If found, DataPtr and CurrData are updated, and pointing on the
;; begining of the room actual data (after room ID)
.FindRoom:
	21F8 16 00          LD D,00
	21FA 21 41 52       LD HL,Room_list1
	21FD CD 06 22       CALL Sub_FindRoom									; init and look in first list
	2200 D0             RET NC												; found, leave
	2201 21 E6 60       LD HL,Room_List2									; else (Carry set=not found) look in 2nd list
	2204 18 07          JR Sub_FindRoom_more								; return Carry set=not found of reset=found)

;; -----------------------------------------------------------------------------------------------------------
;; Finds an entry in the room list.
;; The data structure is:
;;  -  1 byte = size (excluding this byte); a size of zero terminates the list.
;;  -  1.5 bytes = room id "UVZ" (Bottom nibble is ignored for matching),
;;							 eg. "8A 43" means Room #8A40, also note these are
;;							    in big_endian format: U=8,V=#A,Z=4 (3=don't care)
;;  -  0.5 + N bytes of Data
;; Input:
;;   HL pointing to the start of the tagged list
;;   BC is the room id we're looking for (eg. #8A40 for Head's first room)
;;   HL' and C' are incremented as the address in RoomMask_buffer and
;;      bit mask for a bitfield associated with the Nth entry.
;; Return:
;;   DE will be the entry size (D should be zero)
;; 	 The carry flag is set if nothing's found.
;; 	 If the room is found, you can read data with FetchData:
;;      Current byte to process in CurrData;
;;      Addr pointer on data in DataPtr
.Sub_FindRoom:
	2206 D9             EXX
	2207 21 61 42       LD HL,RoomMask_buffer								; HL' points on a 301 bytes buffer (1 per room)
	220A 0E 01          LD C,01												; wandering 1 bit mask start bit 0
	220C D9             EXX													; Save as HL' and C', get back HL= pointer on room list 1
.Sub_FindRoom_more:
	220D 5E             LD E,(HL)											; read first byte = length for current room block of data (including room id)
	220E 1C             INC E
	220F 1D             DEC E												; test if value in E (data block length) = 0
	2210 37             SCF													; Return with Carry if length byte = 0 (not found and end of list reached)
	2211 C8             RET Z												; so if E = 0 leave; else:
	2212 23             INC HL												; point on next byte (id high byte) (UV)
	2213 78             LD A,B												; compare the id in B...
	2214 BE             CP (HL)												; ... with that byte
	2215 28 0A          JR Z,frin_b_matched									; if identical jump frin_b_matched, else:
frin_2:																		; (B did't match)
	2217 19             ADD HL,DE											; skip until next data block
	2218 D9             EXX													; get C' (bitmask)
	2219 CB 01          RLC C												; move the wandering 1 left; C' bit7 goes in Carry
	221B 30 01          JR NC,frin_1										; if bit7 = 0 jump frin_1, else (moved 8 times):
	;; We only need 301 bits (a 1 indicating we visited it) but the
	;; RoomMask_buffer is 301 bytes because of the function used to
	;; count visited rooms that is shared with other functionalities.
	221D 23             INC HL												; increment RoomMask_buffer addr in HL'
frin_1:																		; save C',HL' and ...
	221E D9             EXX													; ...recover C (id low byte) and HL (data pointer)
	221F 18 EC          JR Sub_FindRoom_more								; loop at Sub_FindRoom_more

frin_b_matched:																; B was a match so now check C
	2221 23             INC HL												; next byte
	2222 1D             DEC E												; so decrement DE
	2223 7E             LD A,(HL)											; get id low byte
	2224 E6 F0          AND F0												; and only look at bits [7:4] (Z)
	2226 B9             CP C												; compare with id low byte in C (Z part of the roomId)
	2227 20 EE          JR NZ,frin_2										; no match, jump to skip to next data block; else found!
	2229 2B             DEC HL												; Matched room ID! point back on ID high byte (because of the INC HL in FetchData)
	222A 22 AB 1E       LD (DataPtr),HL										; store pointer on data block in DataPtr
	222D 3E 80          LD A,80												; init CurrData with #80 (will make FetchData jump to the is low byte)
	222F 32 AD 1E       LD (CurrData),A										; to init the fetching pointer by skipping the 4 upper bits and pointing on the low nibble
	2232 06 04          LD B,04												; dummy read first nibble of id low byte
	2234 C3 B2 22       JP FetchData										; will point on low nibble of id low byte ; will RET

;; -----------------------------------------------------------------------------------------------------------
.SetTmpObjFlags:
	2237 3A AA 1E       LD A,(UnpackFlags)									; get orientation 3b flag value
	223A 1F             RRA
	223B 1F             RRA													; get bit1 from saved flags in Carry
	223C 38 05          JR C,stof_1											; if bit1 set then don't read a new bit (global value is in bit2), else do:
	223E 06 01          LD B,01												; if bit1 = 0 then read 1 new bit per object:
	2240 CD B2 22       CALL FetchData										; per-object orientation bit fetched from CurrData
stof_1:
	2243 E6 01          AND 01												; look at bit2 only (because of the 2 RRA above, the bit2 orrientation (flipped or not) flag is currently at bit0!)
	2245 07             RLCA
	2246 07             RLCA
	2247 07             RLCA
	2248 07             RLCA
	2249 E6 10          AND 10												; shift it to bit 4
	224B 4F             LD C,A
	224C 3A 97 1E       LD A,(BaseFlags+1)									; get current flag
	224F A9             XOR C												; flip bit 4 of BaseFlags+1 if needed
	2250 32 9C 1E       LD (TmpObj_variables+O_FLAGS),A						; and update tmp flags; this bit indicated if the sprite needs flip or not
	2253 ED 4B 96 1E    LD BC,(BaseFlags)
	2257 CB 67          BIT 4,A												; test bit4
	2259 28 0B          JR Z,stof_end										; If bit4 reset then jump stof_end, else (bit4 set):
	225B CB 4F          BIT 1,A												; test bit1
	225D 28 05          JR Z,stof_2											; if bit1 reset then jump stof_2, else (bit1 rest):
	225F EE 01          XOR 01												; flip bit 0
	2261 32 9C 1E       LD (TmpObj_variables+O_FLAGS),A						; update Flags
stof_2:
	2264 0D             DEC C
	2265 0D             DEC C
stof_end:
	2266 79             LD A,C
	2267 32 A8 1E       LD (TmpObj_variables+O_DIRECTION),A
	226A C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Read (ie. FetchData) U, V, Z coords (3 bits each), and
;; set TmpObj_variables's location
.SetTmpObjUVZEx:
	226B CD 9D 22       CALL FetchData333									; Fectch 3*3b U,V,Z in B,C,A
.SetTmpObjUVZ:
	226E 08             EX AF,AF
	226F 2A 88 1E       LD HL,(DecodeOrgPtr)								; get origin
	2272 11 9D 1E       LD DE,TmpObj_variables+0_U							; DE points on Obj U
;; Calculates U, V and Z coordinates
;;  DE points to where we will write the U, V and Z coordinates
;;  HL points to the address of the origin data.
;;  We pass in coordinates: B contains U, C contains V, A' contains Z
;;  U/V coordinates are built on a grid of * 8 + 12
;;  Z coordinate is built on a grid of * 6 + 0x96 (0..7 will return #96 to #C0=ground level)
;;  Sets ExpandDone to 0xFF (done) if "B = 7, C = 7, A' = 0"
.Set_UVZ:
	2275 78             LD A,B												; U
	2276 CD 95 22       CALL CalcGridPos									; Calc U grid and HL++
	2279 12             LD (DE),A											; Set Obj U coordinate = ((OriginU+U) * 8) + 12
	227A 79             LD A,C												; V
	227B CD 95 22       CALL CalcGridPos									; Calc V grid and HL++
	227E 13             INC DE
	227F 12             LD (DE),A											; Set Obj V coordinate = ((OriginV+V) * 8) + 12
	2280 08             EX AF,AF											; get Z from A'
	2281 F5             PUSH AF
	2282 86             ADD A,(HL)											; OriginZ+Z
	2283 6F             LD L,A												; *1
	2284 87             ADD A,A												; *2
	2285 85             ADD A,L												; *3
	2286 87             ADD A,A												; *6
	2287 C6 96          ADD A,96											; +#96
	2289 13             INC DE
	228A 12             LD (DE),A											; Set Z coordinate = ((OriginZ+Z) * 6) + #96
	228B F1             POP AF												; get Z back
	228C 2F             CPL													; invert bits (if Z=0 (3b000) we will get 3b111)
	228D A1             AND C												; if V=7, A[2:0] is still 3b111
	228E A0             AND B												; if U=7, A[2:0] is still 3b111
	228F F6 F8          OR F8												; make sure A[7:3] are set
	2291 32 AE 1E       LD (ExpandDone),A									; ExpandDone will be #FF is UVZ = 7,7,0 (else ExpandDone not #FF)
	2294 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Add curr coord (U or V) to the Origin (U or V) from (HL) and
;; calculate the resulting pixel position.
;; Input: A = U or V current value;
;;        HL : pointer on U or V origin value.
;; Output: A = ((coord+origin) * 8) + 12
;;         HL is incremented
.CalcGridPos:
	2295 86             ADD A,(HL)											; coord (U or V) + origin (U or V)
	2296 23             INC HL												; move pointer on next coord
	2297 07             RLCA
	2298 07             RLCA
	2299 07             RLCA												; A*8
	229A C6 0C          ADD A,0C											; +12
	229C C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This will fetch (see FetchData) 3 values of 3-bits.
;; Output: First value in B, next in C and Last in A.
;;         CurrData and DataPtr are updated as needed
;; It is used to get the UVZ coords from the Room data.
.FetchData333:
	229D 06 03          LD B,03
	229F CD B2 22       CALL FetchData										; fetch 3 bits (U will go in B)
	22A2 F5             PUSH AF
	22A3 06 03          LD B,03
	22A5 CD B2 22       CALL FetchData										; fetch 3 bits (V will go in H and copied in C)
	22A8 F5             PUSH AF
	22A9 06 03          LD B,03
	22AB CD B2 22       CALL FetchData										; fetch 3 bits (Z will be in A)
	22AE E1             POP HL
	22AF C1             POP BC
	22B0 4C             LD C,H
	22B1 C9             RET													; Return first 3 bits in B, next 3 bits in C, final 3 bits in A

;; -----------------------------------------------------------------------------------------------------------
;; Fetch a value from bit-packed data.
;; Input: Number of bits in B.
;;        Also the current byte of data must be in CurrData;
;;        and current data pointer in DataPtr
;; Output: DataPtr and CurrData updated
;;         Fetched B-bit value in A
;; Exemple: From the 2 consecutive bytes "B1" and "72" ("101|1_000|1_0|111_00|10"),
;;     if we FetchData with B being 3 then 4, 2 and finaly 5 we get in A
;;     respectively #05, then #08, #02 and finaly #1C, with CurrData being #80
;;     and DataPtr increase by 1.
.FetchData:
	22B2 11 AD 1E       LD DE,CurrData										; pointer on current data processed
	22B5 1A             LD A,(DE)											; get data
	22B6 2A AB 1E       LD HL,(DataPtr)										; get addr for the data
	22B9 4F             LD C,A												; byte of data in C
	22BA AF             XOR A												; A = 0; Carry = 0
fetchd_0:
	22BB CB 11          RL C												; Left rotate C, leaving bit goes in Carry
	22BD 28 06          JR Z,fdta_next										; if remaining data = 0, jump fdta_next, else:
fetchd:
	22BF 17             RLA													; rotate A and insert Carry at bit 0
	22C0 10 F9          DJNZ fetchd_0										; fetch B bits
	22C2 EB             EX DE,HL
	22C3 71             LD (HL),C											; update CurrData with what's left after extracting B bits from it
	22C4 C9             RET

fdta_next:																	; we can get next byte, as we emptied the current one!
	22C5 23             INC HL												; next byte
	22C6 22 AB 1E       LD (DataPtr),HL										; update data pointer in DataPtr
	22C9 4E             LD C,(HL)											; get next byte
	22CA 37             SCF													; set Carry
	22CB CB 11          RL C												; Rotate left C, bit7 goes in Carry, and the old Carry (1) goes in bit0
	22CD C3 BF 22       JP fetchd											; continue fetching bits with that new byte

;; -----------------------------------------------------------------------------------------------------------
;; Configure the walls for the current room
.DoConfigWalls:
	22D0 2A F2 1E       LD HL,(DoorHeightsTmp)								; Get the heights of the doors on the back walls.
	22D3 7D             LD A,L												; compare the 2 doors, take the lowest:
	22D4 BC             CP H												; H < L ?
	22D5 38 01          JR C,dcwll_1										; if H < L skip using L (lowest), else:
	22D7 7C             LD A,H												; use H as it is the lowest
dcwll_1:
	22D8 ED 44          NEG
	22DA C6 C0          ADD A,C0											; #C0 (ground level) - height of the lowest of the 2 back doors.
	22DC 21 F6 1E       LD HL,HighestDoor									; test if the highest door
	22DF BE             CP (HL)												; is below "#C0-height of the lowest of the 2 back doors"
	22E0 38 01          JR C,dcwll_2										; if it is the case skip, else:
	22E2 77             LD (HL),A											; update the value for the highest door
dcwll_2:
	22E3 7E             LD A,(HL)											; in all case takse the value of the heiest door (updated or not)
	22E4 C3 63 3C       JP ConfigWalls										; do ConfigWalls ; will RET

;; -----------------------------------------------------------------------------------------------------------
;; Calls all the initialization functions
.Init_setup:
	22E7 CD 62 04       CALL Init_table_and_crtc							; Tables, Interrupts and CRTC
	22EA C3 39 35       JP Init_table_rev									; Continue at Init_table_rev ; will have a RET

;; -----------------------------------------------------------------------------------------------------------
;; Initialization of a new game
.Init_new_game:
	22ED AF             XOR A												; A=0
	22EE 32 EA 3D       LD (saved_World_Mask),A								; reset saved_World_Mask
	22F1 32 58 46       LD (access_new_room_code),A							; init access_new_room_code to 0 ("stay same room" Code)
	22F4 32 94 41       LD (Save_point_value),A								; Initialize the save point value to 0
	22F7 3E 18          LD A,18												; Init Heels' anim sprite
	22F9 32 B8 24       LD (Heels_variables+O_SPRITE),A
	22FC 3E 1F          LD A,1F												; Init Head's anim sprite
	22FE 32 CA 24       LD (Head_variables+O_SPRITE),A
	2301 CD C6 43       CALL Erase_visited_room								; Erase "visited room" bits from mem #4261 length 012D (301 bytes (for 301 rooms) : in fact only 38 are used!)
	2304 CD 55 24       CALL Reinitialise									; Reinitialise with:
	2307 DATAWORD 71 24            											; Argument StatusReinit 2471 (counters)
	2309 CD 50 3F       CALL ResetSpecials									; reset the "picked up" bit for the special items
	230C 21 40 89       LD HL,RoomID_Heels_1st								; This is Heels initial room id (#8940)
	230F 22 0E 01       LD (current_Room_ID),HL								; update current_Room_ID
	2312 3E 01          LD A,01												; init selected character
	2314 CD 22 23       CALL InitOtherChar									; this will first load Heels room, build it, and create Heels and Objects; then we'll switch the Head (1st room we see when starting the game), so that if we Swop, the other character (Heels) is already defined.
	2317 21 40 8A       LD HL,RoomID_Head_1st								; This is Head initial room id (#8A40)
	231A 22 0E 01       LD (current_Room_ID),HL								; update current_Room_ID
	231D AF             XOR A												; A=0
	231E 32 58 46       LD (access_new_room_code),A							; reset access_new_room_code with 0 ("stay same room" Code)
	2321 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Initialize the character in A (1=Heels, 2=Head) to create the "other"
;; character so then if we swop, everything needed (other char, other char's room, objects) already exist.
.InitOtherChar:
	2322 32 84 24       LD (selected_characters),A							; update selected_characters with value in A
	2325 F5             PUSH AF
	2326 32 10 BB       LD (Other_Character_state),A
	2329 CD 9E 23       CALL EnterRoom										; enter first room
	232C AF             XOR A												; A=0
	232D 32 87 24       LD (Teleport_down_anim_length),A					; Init Teleport anim
	2330 CD 48 2B       CALL CharThing15
	2333 18 03          JR initth_sub

initth_loop:
	2335 CD 51 25       CALL CharThing
initth_sub:
	2338 3A AC 24       LD A,(Saved_Objects_List_index)						; get Saved_Objects_List_index
	233B A7             AND A												; test A
	233C 20 F7          JR NZ,initth_loop									; if not 0 jump loop, else:
	233E F1             POP AF
	233F EE 03          XOR 03												; switch bits 1 and 0 (change selected character)
	2341 32 84 24       LD (selected_characters),A							; update selected_characters
	2344 CD 7B 27       CALL CharThing3										; init bit2 of SwopChara_Pressed
	2347 C3 73 03       JP Save_array										; save other character

;; -----------------------------------------------------------------------------------------------------------
.Init_Continue_game:
	234A CD 55 24       CALL Reinitialise									; Reinitialise with:
	234D DATAWORD 71 24        												; Argument StatusReinit 2471 (counters)
	234F 3E 08          LD A,08												; "All Black" color scheme
	2351 CD 2C 05       CALL Set_colors										; set color scheme
	2354 C3 85 40       JP DoContinue										; continue at DoContinue

;; -----------------------------------------------------------------------------------------------------------
.FinishRestore:
	2357 CD F7 1E       CALL BuildRoomNoObj
	235A CD 55 24       CALL Reinitialise									; Reinitialise with:
	235D DATAWORD 8A 24             										; Argument ReinitThing 248A
	235F CD 28 03       CALL Set_Character_Flags
	2362 CD F9 23       CALL GetScreenEdges
	2365 CD F8 04       CALL DrawBlacked
	2368 AF             XOR A												; a = 0
	2369 32 85 24       LD (both_in_same_room),A							; reset both_in_same_room
	236C 18 24          JR Update_Screen_Periph								; Update HUD

;; -----------------------------------------------------------------------------------------------------------
????:
	236E DATABYTE 00

WorldIdSnd:
	236F DATABYTE 00														; Sound ID of the current World (#40 to #46)

;; -----------------------------------------------------------------------------------------------------------
.Do_Enter_Room:
	2370 CD 9E 23       CALL EnterRoom
	2373 3A 86 2F       LD A,(Sound_menu_data)								; get Sound_menu_data
	2376 A7             AND A
	2377 20 13          JR NZ,br_238C
	2379 3A BF 1E       LD A,(WorldId)										; get WorldId
	237C FE 07          CP 07												; Compare with 7: "Prison"
	237E 20 03          JR NZ,br_2383										; if not prison, skip, else:
	2380 3A 6F 23       LD A,(WorldIdSnd)									; get current (or default = 0) WorldIdSnd: this will set the "Prison" sound to "Blacktooth" (ID #40)
br_2383
	2383 32 6F 23       LD (WorldIdSnd),A									; save WorldIdSnd
	2386 F6 40          OR 40												; add #40 to get a Worlds Sound ID (they start at ID #40)
	2388 47             LD B,A												; #40 + WorldId = World music
	2389 CD 91 0D       CALL Play_Sound										; Play world music
br_238C
	238C CD F8 04       CALL DrawBlacked
	238F CD 48 2B       CALL CharThing15
.Update_Screen_Periph:
	2392 3A BE 1E       LD A,(color_scheme)									; get color_scheme
	2395 CD 2C 05       CALL Set_colors										; Set color scheme
	2398 CD 51 41       CALL PrintStatus									; Print the HUD counters values
	239B C3 9C 45       JP Draw_Screen_Periphery							; Draw HUD ; will RET

;; -----------------------------------------------------------------------------------------------------------
.EnterRoom:
	239E CD 55 24       CALL Reinitialise									; Reinitialise with:
	23A1 DATAWORD 86 39            											; Argument ObjVars 3986
	23A3 CD 55 24       CALL Reinitialise									; Reinitialise with:
	23A6 DATAWORD 8A 24         											; Argument ReinitThing 248A
	23A8 3A 84 24       LD A,(selected_characters)							; get selected_characters
	23AB FE 03          CP 03
	23AD 20 0C          JR NZ,br_23BB
	23AF 21 10 BB       LD HL,Other_Character_state
	23B2 CB C6          SET 0,(HL)
	23B4 CD FC 1E       CALL BuildRoom
	23B7 3E 01          LD A,01
	23B9 18 38          JR br_23F3

br_23BB
	23BB CD 5F 03       CALL Do_We_Share_Room
	23BE 20 2F          JR NZ,br_23EF
	23C0 CD 76 03       CALL Restore_array
	23C3 CD F7 1E       CALL BuildRoomNoObj
	23C6 21 B0 24       LD HL,Heels_variables
	23C9 CD 2F 3B       CALL GetUVZExtentsB
	23CC D9             EXX
	23CD 21 C2 24       LD HL,Head_variables
	23D0 CD 2F 3B       CALL GetUVZExtentsB
	23D3 CD C6 2E       CALL CheckOverlap
	23D6 30 13          JR NC,br_23EB
	23D8 3A 84 24       LD A,(selected_characters)							; get selected_characters
	23DB 1F             RRA
	23DC 38 01          JR C,br_23DF
	23DE D9             EXX
br_23DF
	23DF 78             LD A,B
	23E0 C6 05          ADD A,05
	23E2 D9             EXX
	23E3 B8             CP B
	23E4 38 05          JR C,br_23EB
	23E6 3E FF          LD A,FF
	23E8 32 6E 23       LD (236E),A
br_23EB
	23EB 3E 01          LD A,01
	23ED 18 04          JR br_23F3

br_23EF
	23EF CD FC 1E       CALL BuildRoom
	23F2 AF             XOR A
br_23F3
	23F3 32 85 24       LD (both_in_same_room),A							reset both_in_same_room
	23F6 C3 F9 23       JP GetScreenEdges

;; -----------------------------------------------------------------------------------------------------------
.GetScreenEdges:
	23F9 2A C2 1E       LD HL,(Max_min_UV_Table)							MinU; MinU in L, MinV in H.
	23FC 3A C1 1E       LD A,(Has_Door)										Has_Door
	23FF F5             PUSH AF
	2400 CB 4F          BIT 1,A
	2402 28 04          JR Z,br_2408
	; If there's a door, bump up MinV.
	2404 25             DEC H
	2405 25             DEC H
	2406 25             DEC H
	2407 25             DEC H
br_2408
	2408 1F             RRA
	2409 7D             LD A,L												MinU
	240A 30 03          JR NC,br_240F
	;; If there's the other door, reduce MinU.
	240C D6 04          SUB 04
	240E 6F             LD L,A
	;; Find MinU - MinV
br_240F
	240F 94             SUB H
	;; And use this to set the X coordinate of the corner.
	2410 C6 80          ADD A,80
	2412 32 03 18       LD (smc_CornerPos+1),A								self_mod code #1803 (value of CP ...)
	2415 4F             LD C,A												; Save in C for TweakEdges
	;; Then set the Y coordinate of the corner, taking into
    ;; account various fudge factors.
	2416 3E FC          LD A,FC												Y_START + $C0 - EDGE_HEIGHT - 1
	2418 94             SUB H
	2419 95             SUB L
	;; Save Y coordinate of the corner in B for TweakEdges
	241A 47             LD B,A
	;; Then generate offsets to convert from screen X coordinates to
    ;; associated Y coordinates.
	241B ED 44          NEG
	241D 5F             LD E,A												; E = MinU + MinV - $FC
	241E 81             ADD A,C
	241F 32 17 18       LD (smc_LeftAdj+1),A								1817 ; E + CornerPos, value of ADD A,??? ; self mod
	2422 79             LD A,C
	2423 ED 44          NEG
	2425 83             ADD A,E
	2426 32 0F 18       LD (smc_RightAdj+1),A								180F:  E - CornerPos, value of ADD A,??? ; self mod
	2429 CD FF 18       CALL TweakEdges
	;; Then, inspect Has_Doors to see if we need to remove
	;; a column panel or two.
	242C F1             POP AF
	242D 1F             RRA
	242E F5             PUSH AF
	242F D4 4A 24       CALL NC,NukeColL
	2432 F1             POP AF
	2433 1F             RRA
	2434 D8             RET C
;; Scan from the right for the first drawn column
NukeColR:
	2435 21 3E 6A       LD HL,6A3E											BkgndData + 31*2
.ScanR:
	2438 7E             LD A,(HL)
	2439 A7             AND A
	243A 20 04          JR NZ,NukeCol
	243C 2B             DEC HL
	243D 2B             DEC HL
	243E 18 F8          JR ScanR

;; If the current screen column sprite is a blank, delete it.
.NukeCol:
	2440 23             INC HL
	2441 7E             LD A,(HL)
	2442 F6 FA          OR FA												~5
	2444 3C             INC A
	2445 C0             RET NZ
	2446 77             LD (HL),A
	2447 2B             DEC HL
	2448 77             LD (HL),A
	2449 C9             RET

;; Scan from the left for the first drawn column
.NukeColL:
	244A 21 00 6A       LD HL,6A00											BkgndData buffer
ScanL:
	244D 7E             LD A,(HL)
	244E A7             AND A
	244F 20 EF          JR NZ,NukeCol
	2451 23             INC HL
	2452 23             INC HL
	2453 18 F8          JR ScanL

;; -----------------------------------------------------------------------------------------------------------
;; This copies a block of data to another block in order to reset the
;; values of the destination block.
;; The "CALL Reinitialise" must be followed by a DATAWORD argument with
;; the address of the byte indicating both block length.
;; Then the first byte of data to copy is the addr after it up to the
;; block length.
;; The destination block is the contiguous block after that.
.Reinitialise:
	;; Dereference top of stack into HL, incrementing pointer
	;; hence the CALL if followed by a DATAWORD argument
	2455 E1             POP HL												; get PC from Stack; it is pointing on the byte after the CALL, which is an argument
	2456 5E             LD E,(HL)
	2457 23             INC HL
	2458 56             LD D,(HL)											; DE = Argument value
	2459 23             INC HL												; HL points on the byte after the Word argument
	245A E5             PUSH HL												; Push that addr as the RETurn addr
	245B EB             EX DE,HL											; argument now in HL
	245C 4E             LD C,(HL)											; get the value at addr in HL (argument)
	245D 06 00          LD B,00												; put value in BC (length)
	245F 23             INC HL												; point on next byte (argument addr +1)
	2460 54             LD D,H
	2461 5D             LD E,L												; DE = "arg affr value + 1"
	2462 09             ADD HL,BC											; HL = arg+1 + length
	2463 EB             EX DE,HL											; DE = "arg+1 + length"; HL = "arg + 1"
	2464 ED B0          LDIR												; repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	2466 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; 2 available functions to Erase a block of memory.
;; Erase_forward_Block_RAM will erase using the value 00
;; Erase_block_val_in_E will erase using the value in E
;; Input: HL=start addr, BC=length, E (erase value for Erase_block_val_in_E only)
.Erase_forward_Block_RAM:
	2467 1E 00          LD E,00												; default erase value is 0
.Erase_block_val_in_E:														; if entering directly here; E will have the erase value
	2469 73             LD (HL),E											; Start at HL, fill with value in E
	246A 23             INC HL												; next HL
	246B 0B             DEC BC												; BC counter - 1
	246C 78             LD A,B
	246D B1             OR C												; test if BC = 0
	246E 20 F9          JR NZ,Erase_block_val_in_E							; no? then loop until finished
	2470 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; These are the init/default values for the Inventory (see 247B) and
;; Counters (see 247C). First byte is the length of the array (9).
;; Then the reset values to initialize the variables.
;; The Reinitialise call with 2471 as argument will copy the 9 bytes of
;; StatusReinit_reset_data into the Inventory (247B) & after
StatusReinit:
	2471 DATABYTE 09             											; Number of bytes (length) to reinit with
StatusReinit_reset_data:
	2472 DATABYTE 00														; Inventory reset value; Indicates what objects we have; a #FF here gives us all the objects!
	2473 DATABYTE 00             											; Speed reset value
	2474 DATABYTE 00             											; Springs reset value
	2475 DATABYTE 00             											; Heels invulnerable reset value
	2476 DATABYTE 00             											; Head invulnerable reset value
	2477 DATABYTE 08             											; Heels lives reset value
	2478 DATABYTE 08             											; Head lives reset value
	2479 DATABYTE 00             											; Donuts reset value
	247A DATABYTE 00             											; TODO : jump force reset value

;; -----------------------------------------------------------------------------------------------------------
;; This will indicate the available character inventory.
;; A '1' means that the item has been picked up.
;;		bit0 : Purse (Heels)
;;		bit1 : Hooter (Head)
;;		bit2 : Tray of Donuts (Head)
.Inventory:
	247B DATABYTE 00

;; -----------------------------------------------------------------------------------------------------------
,, These are the main counters (Lives, Invuln, Speed, Spring, Donuts)
.Counters:
.Speed:
	247C DATABYTE 00														; speed
.Spring:
	247D DATABYTE 00														; number of extra jumps
.Heels_invulnerability:
	247E DATABYTE 00														; Head's invulnerable
.Head_s_invulnerability:
	247F DATABYTE 00														; Heels' invulnerable
Characters_lives:
	2480 DATABYTE 04														; Heels' lives
	2481 DATABYTE 04                     									; Head's lives
nb_donuts:
	2482 DATABYTE 00														; Number of Donuts available

jump_force____to_be_checked:
	2483 DATABYTE 00             											; Number of boosted Jumps

;; -----------------------------------------------------------------------------------------------------------

selected_characters:
	2484 DATABYTE 03     													Note: both can be selected! ; bit0=Heels, Bit1=Head; Bit2=Next character to swop to (0 Heels, 1 Head)
both_in_same_room:
	2485 DATABYTE 01

.Teleport_up_anim_length:
	2486 DATAWORD 00
.Teleport_down_anim_length:
	2487 DATAWORD 00

.InvulnModulo:
	2488 DATABYTE 03             											InvulnModulo
.SpeedModulo:
	2489 DATABYTE 02             											SpeedModulo

;; -----------------------------------------------------------------------------------------------------------
;; Reinitialisation size of the array
;; The Reinitialise call with 248A as argument will copy the 3 bytes of
;; ReinitThing_reset_data into the ???_248E & after
ReinitThing:
	248A DATABYTE 03             											; Three bytes to reinit with:
ReinitThing_reset_data:
	248B DATABYTE 00 00 FF

;; -----------------------------------------------------------------------------------------------------------
???
	248E DATABYTE 00
???
	248F DATABYTE 00
.IsStill:
	2490 DATABYTE FF     													IsStill; $00 if moving, $FF if still

;; -----------------------------------------------------------------------------------------------------------
.TickTock:
	2491 DATABYTE 02														TickTock; Phase for moving

;; =======================================
????:
	2492 DATABYTE 00														???
.EntryPosn:
	2493 DATABYTE 00 00 00													; Where we entered the room (for when we die).
????:
	2496 DATABYTE 03  					        							???

Carrying:
	2497 DATAWORD 00 00             										; Pointer to carried object.

;; Fired Donut Object
FiredObj_variables:  				; #12 = 18
	2499 DATABYTE 00				;	0 :
	249A DATABYTE 00				;	1 :
	249B DATABYTE 00				;	2 :
	249C DATABYTE 00				;	3 :
	249D DATABYTE 20				;	4 : O_FLAGS
	249E DATABYTE 28				;	5 : O_U coordinate
	249F DATABYTE 0B				;	6 : O_V coordinate
	24A0 DATABYTE C0				;	7 : O_Z coordinate
	24A1 DATABYTE 24				;	8 : O_SPRITE
	24A2 DATABYTE 08				;	9 : Sprite flags (bit5: set = double size)
	24A3 DATABYTE 12				;	A : O_FUNC
	24A4 DATABYTE FF				;	B :
	24A5 DATABYTE FF				;	C :
	24A6 DATABYTE 00				;	D :
	24A7 DATABYTE 00				;	E :
	24A8 DATABYTE 08				;	F : O_ANIM
	24A9 DATABYTE 00				;	10 : O_DIRECTION
	24AA DATABYTE 00				;	11 :

;; =======================================
character_direction:
	24AB DATABYTE 0F             				 							; Bitmask of direction, suitable for passing to LookupDir.
Saved_Objects_List_index:
	24AC DATABYTE 00
Other_sound_ID:
	24AD DATABYTE 00
Sound_ID:
	24AE DATABYTE 00       						 							; Id of sound, +1 (0 = no sound)
Movement:
	24AF DATABYTE FF

;; Head_offset: EQU 12
Heels_variables:					; #12 = 18
	24B0 DATABYTE 00				;	0 :
	24B1 DATABYTE 00				;	1 :
	24B2 DATABYTE 00				;	2 :
	24B3 DATABYTE 00				;	3 :
	24B4 DATABYTE 08				;	4 : O_FLAGS
	24B5 DATABYTE 28				;	5 : O_U coordinate
	24B6 DATABYTE 0B				;	6 : O_V coordinate
	24B7 DATABYTE C0				;	7 : O_Z coordinate
	24B8 DATABYTE 18				;	8 : O_SPRITE
	24B9 DATABYTE 21				;	9 : Sprite flags (bit5: set = double size)
	24BA DATABYTE 00				;	A : O_FUNC
	24BB DATABYTE FF				;	B :
	24BC DATABYTE FF				;	C :
	24BD DATABYTE 00				;	D :
	24BE DATABYTE 00				;	E :
	24BF DATABYTE 00				;	F : O_ANIM
	24C0 DATABYTE 00				;	10 : O_DIRECTION
	24C1 DATABYTE 00				;	11 :

;; Head_variables addr = Heels_variables + Head_offset
Head_variables:						; #12 = 18
	24C2 DATABYTE 00				;	0 :
	24C3 DATABYTE 00				;	1 :
	24C4 DATABYTE 00				;	2 :
	24C5 DATABYTE 00				;	3 :
	24C6 DATABYTE 08				;	4 : O_FLAGS
	24C7 DATABYTE 28				;	5 : O_U coordinate
	24C8 DATABYTE 0B				;	6 : O_V coordinate
	24C9 DATABYTE C0				;	7 : O_Z coordinate
	24CA DATABYTE 1F				;	8 : O_SPRITE
	24CB DATABYTE 25				;	9 : Sprite flags (bit5: set = double size)
	24CC DATABYTE 00				;	A : O_FUNC
	24CD DATABYTE FF				;	B :
	24CE DATABYTE FF				;	C : (displacement when trying to merge (when swop to both))
	24CF DATABYTE 00				;	D :
	24D0 DATABYTE 00				;	E :
	24D1 DATABYTE 00				;	F : O_ANIM
	24D2 DATABYTE 00				;	10 : O_DIRECTION
	24D3 DATABYTE 00				;	11 :

;; -----------------------------------------------------------------------------------------------------------
;; This defines the sprites list that compose an animation for
;; Head and Heels (facing and rearward) and also for the "Vape"
;; animations (Dying, Teleporting, Vanishing (hushpuppies), etc.).
;; The first byte is the current index in the animation (which is
;; the current sprite in the anim). The list is 0-terminated.
;; If the bit7 of the sprite code is set, the sprite is mirrored.
.HeelsLoop:
	24D4 DATABYTE 00 18 19 18 1A 00					; Frame_index, SPR_HEELS1,SPR_HEELS2,SPR_HEELS1,SPR_HEELS3, end
.HeelsBLoop:
	24DA DATABYTE 00 1B 1C 1B 1D 00					; Frame_index, SPR_HEELSB1,SPR_HEELSB2,SPR_HEELSB1,SPR_HEELSB3, end
.HeadLoop:
	24E0 DATABYTE 00 1E 1F 1E 20 00					; Frame_index, SPR_HEAD1,SPR_HEAD2,SPR_HEAD1,SPR_HEAD3, end
.HeadBLoop:
	24E6 DATABYTE 00 21 22 21 23 00					; Frame_index, SPR_HEADB1,SPR_HEADB2,SPR_HEADB1,SPR_HEADB3, end
.Vapeloop1:
	24EC DATABYTE 00 24 A4 A5 25 A5					; Frame_index, SPR_VAPE1, $80 | SPR_VAPE1, $80 | SPR_VAPE2, SPR_VAPE2, $80 | SPR_VAPE2,
	24F2 DATABYTE A6 26 26 A6						; $80 | SPR_VAPE3, SPR_VAPE3, SPR_VAPE3, $80 | SPR_VAPE3,
	24F6 DATABYTE A6 26 26 00             			; $80 | SPR_VAPE3 SPR_VAPE3, SPR_VAPE3, end
.VapeLoop2:
	24FA DATABYTE 00 26 A6 26 A6          			; Frame_index, SPR_VAPE3, $80 | SPR_VAPE3, SPR_VAPE3, $80 | SPR_VAPE3,
	24FF DATABYTE A5 25 24 A5 00					; $80 | SPR_VAPE2, SPR_VAPE2, SPR_VAPE1, $80 | SPR_VAPE2, end

;; -----------------------------------------------------------------------------------------------------------
;; These are the variable and function to make a facing Head blink!
;; Note that redoing Xor a second time cancel the result
;; (ie. revert back to the original image)
.BlinkEyesState:															; (for BlinkEyes)
	2504 DATABYTE 00
.BlinkEyesCounter:															; (for BlinkEyes)
	2505 DATABYTE 40

.BlinkEyes:
	2506 21 04 25       LD HL,BlinkEyesState								; point on BlinkEyesState
	2509 3E 80          LD A,80
	250B AE             XOR (HL)											; read, inverse bit7 and....
	250C 77             LD (HL),A											; ...update BlinkEyesState
	250D 3A E3 70       LD A,(70E3) 										; probably checks if the sprite is flipped or not
	2510 CB 47          BIT 0,A												; test bit0 (Z set = facing right, Z reset = facing right)
	2512 21 CD 8F       LD HL,8FCD											; SPR_HEAD2 + #0D offset (start of the eyes)
	2515 11 45 25       LD DE,Blink_XOR_facing_right						; load Xor Right
	2518 28 04          JR Z,weybw_doit										; if bit 0 previously was zero then jump weybw_doit with Xor2
	251A 2B             DEC HL												; else HL points on 8FCB
	251B 11 39 25       LD DE,Blink_XOR_facing_Left							; and use Xor Left instead of Xor Right
weybw_doit:
	251E D5             PUSH DE
	251F E5             PUSH HL
	2520 CD 29 25       CALL BlinkEyes_XORify								; do it on the 3x24 SPR_HEAD2 image
	2523 11 48 00       LD DE,0048											; then redo it #48 bytes further (72=3x24) which is the ...
	2526 E1             POP HL												; ... mask part (SPR_HEAD2+spritelength + #0D)
	2527 19             ADD HL,DE
	2528 D1             POP DE
.BlinkEyes_XORify:
	2529 0E 06          LD C,06												; 6 lines (SPR_HEAD2 sprite is 3x24)
wgxor_1:
	252B 06 02          LD B,02												; do 2 bytes in a row
wgxor_2:
	252D 1A             LD A,(DE)											; read XOR value
	252E AE             XOR (HL)											; Xor sprite byte
	252F 77             LD (HL),A											; and update it
	2530 13             INC DE												; next xor byte
	2531 23             INC HL												; next data byte
	2532 10 F9          DJNZ wgxor_2										; loop 2 consecutive bytes
	2534 23             INC HL												; skip next byte (nothing needed to be xored)
	2535 0D             DEC C												; next line
	2536 20 F3          JR NZ,wgxor_1										; loop all 6 lines
	2538 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Xor table to invert chosen bits and blink Head's eyes;
;; One set is used if Head is facing left, the other for facing right.
;; For exemple, if facing right, the xoring result on the image SPR_HEAD2 (#8FC0) is this:
;; (the effect is more obvious in game!)
;;         ........................                               ........................
;;         .........@@@@@..........        Xor:                   .........@@@@@..........
;;         .......@@@@@@@@@........		  03 00 1B 80 38 00       .......@@@@@@@@@........
;;         ......@@@@@@@@@@@.......		  21 00 08 00 04 00       ......@@@@@@@@@@@.......
;;         .....@@@@@@@@@..@.......	   8FCD : ......FF ........   .....@@@@@@@@@##@.......
;;         .....@@@@@@..@@@@@......   ________...FF.FF F.......   .....@@@@@@##@,,,@......
;;         ....@@@@@@.@@@@@@@......   ________..FFF... ........   ....@@@@@@#,,@@@@@......
;;         ....@@@@@@@@@@@.@@@@....   ________..F....F ........   ....@@@@@@,@@@@#@@@@....
;;         ....@@@@@@@@.@@.@...@...   ________....F... ........   ....@@@@@@@@#@@.@...@...
;;         ....@@@@@@@@.@@@.....@..   ________.....F.. ........   ....@@@@@@@@.,@@.....@..
;;         ...@.@@@@@@@@@@@.....@..                               ...@.@@@@@@@@@@@.....@..
;;         .@@@.@@@@@@@@@@......@..                               .@@@.@@@@@@@@@@......@..
;;         ..@.@@@@@@@@@@.@.....@..       F = bit flipped         ..@.@@@@@@@@@@.@.....@..
;;         ..@.@@@.@@@@@@......@...                               ..@.@@@.@@@@@@......@...
;;         ..@.@@@.@@@.@@......@@..                               ..@.@@@.@@@.@@......@@..
;;         .@.@@@.@@@..@@@@..@@@@@.                               .@.@@@.@@@..@@@@..@@@@@.
;;         ...@@@@.@@@@....@@.@@@@.                               ...@@@@.@@@@....@@.@@@@.
;;         ....@@@@..@@@@@@@...@@..                               ....@@@@..@@@@@@@...@@..
;;         ...@.@@.@@.@@@@.........                               ...@.@@.@@.@@@@.........
;;         ...@@.@@@@@.............                               ...@@.@@@@@.............
;;         .....@.@.@@.............                               .....@.@.@@.............
;;         ........@@..............                               ........@@..............
;;         ........................                               ........................
;;         ........................                               ........................
;; and on the mask (#9008) it'll be this:
;;         @@@@@@@@@.....@@@@@@@@@@                              @@@@@@@@@.....@@@@@@@@@@
;;         @@@@@@@..@@@@@..@@@@@@@@        Xor:                  @@@@@@@..@@@@@..@@@@@@@@
;;         @@@@@@.@@@@@@@@@.@@@@@@@		  03 00 1B 80 38 00      @@@@@@.@@@@@@@@@.@@@@@@@
;;         @@@@@.@@@@@@@@@@@.@@@@@@		  21 00 08 00 04 00      @@@@@.@@@@@@@@@@@.@@@@@@
;;         @@@@.@@@@@@@@@..@.@@@@@@	   9015 : ......FF ........  @@@@.@@@@@@@@@##@.@@@@@@
;;         @@@@.@@@@@@..@@@@@.@@@@@   ________...FF.FF F.......  @@@@.@@@@@@##@,,,@.@@@@@
;;         @@@.@@@@@@.@@@@@@@.@@@@@   ________..FFF... ........  @@@.@@@@@@#,,@@@@@.@@@@@
;;         @@@.@@@@@@@@@@@.@@@@@@@@   ________..F....F ........  @@@.@@@@@@,@@@@#@@@@@@@@
;;         @@@.@@@@@@@@.@@.@...@@@@   ________....F... ........  @@@.@@@@@@@@#@@.@...@@@@
;;         @@@.@@@@@@@@.@@@.....@@@   ________.....F.. ........  @@@.@@@@@@@@.,@@.....@@@
;;         @....@@@@@@@@@@@.....@@@                              @....@@@@@@@@@@@.....@@@
;;         .....@@@@@@@@@@......@@@                              .....@@@@@@@@@@......@@@
;;         @...@@@@@@@@@@.@.....@@@        F = bit flipped       @...@@@@@@@@@@.@.....@@@
;;         @...@@@.@@@@@@......@.@@                              @...@@@.@@@@@@......@.@@
;;         @...@@@.@@@.@@......@..@                              @...@@@.@@@.@@......@..@
;;         ...@@@.@@@..@@@@..@@....                              ...@@@.@@@..@@@@..@@....
;;         @..@@@@.@@@@....@@......                              @..@@@@.@@@@....@@......
;;         @@@.@@@@..@@@@@@@.@....@                              @@@.@@@@..@@@@@@@.@....@
;;         @@...@@....@@@@..@@@..@@                              @@...@@....@@@@..@@@..@@
;;         @@....@........@@@@@@@@@                              @@....@........@@@@@@@@@
;;         @@@.........@@@@@@@@@@@@                              @@@.........@@@@@@@@@@@@
;;         @@@@@.@....@@@@@@@@@@@@@                              @@@@@.@....@@@@@@@@@@@@@
;;         @@@@@@@@..@@@@@@@@@@@@@@                              @@@@@@@@..@@@@@@@@@@@@@@
;;         @@@@@@@@@@@@@@@@@@@@@@@@                              @@@@@@@@@@@@@@@@@@@@@@@@
Blink_XOR_facing_Left:
	2539 DATABYTE 00 C0 01 D8 00 1C 00 84 00 10 00 20
Blink_XOR_facing_right:
	2545 DATABYTE 03 00 1B 80 38 00 21 00 08 00 04 00

;; -----------------------------------------------------------------------------------------------------------
; Think it involves general movement/firing etc.
.CharThing:
	2551 3A 04 25       LD A,(BlinkEyesState)
	2554 17             RLA
	2555 DC 06 25       CALL C,BlinkEyes 									;; If currently blinked, unblink it!
	2558 21 59 46       LD HL,DyingAnimFrameIndex							get DyingAnimFrameIndex
	255B 7E             LD A,(HL)											read DyingAnimFrameIndex
	255C A7             AND A												test
	255D 28 0F          JR Z,br_256E										if 0 then skip further, else:
	255F D9             EXX													dying and the vape/dying anim is being played
	2560 21 84 24       LD HL,selected_characters							points on selected_characters
	2563 3A 5A 46       LD A,(Dying)										get Dying
	2566 A6             AND (HL)											compare with char selected
	2567 D9             EXX
	2568 C2 A8 26       JP NZ,HandleDeath									if NZ then HandleDeath and RET, else
	256B CD A8 26       CALL HandleDeath									also do HandleDeath but after do this:
br_256E
	256E 21 86 24       LD HL,Teleport_up_anim_length
	2571 7E             LD A,(HL)
	2572 A7             AND A												read and test ????
	2573 C2 99 26       JP NZ,br_2699										if not 0 the jump ???2699, else:
	2576 23             INC HL												point on Teleport_down_anim_length
	2577 B6             OR (HL)
	2578 C2 92 26       JP NZ,br_2692
	; Deal with invuln counter every 3 frames.
	257B 21 88 24       LD HL,InvulnModulo
	257E 35             DEC (HL)
	257F 20 17          JR NZ,br_2598
	2581 36 03          LD (HL),03
	2583 2A 84 24       LD HL,(selected_characters)							get selected_characters in L and both_in_same_room in H
	2586 7C             LD A,H												both_in_same_room in A
	2587 87             ADD A,A												*2 or << 1
	2588 B4             OR H
	2589 B5             OR L
	258A 1F             RRA
	258B F5             PUSH AF
decr_heels_invuln:
	258C 3E 02          LD A,02
	258E DC 43 41       CALL C,Decrement_counter_and_display
	2591 F1             POP AF
	2592 1F             RRA
decr_head_invuln:
	2593 3E 03          LD A,03
	2595 DC 43 41       CALL C,Decrement_counter_and_display
br_2598
	2598 3E FF          LD A,FF
	259A 32 AF 24       LD (Movement),A										stop movement
	259D 3A 58 46       LD A,(access_new_room_code)							get access_new_room_code
	25A0 A7             AND A												test
	25A1 28 13          JR Z,br_25B6										if 0 (stay same room) skip to ??25B6??, else (change room):
	25A3 3A AC 24       LD A,(Saved_Objects_List_index)						get Saved_Objects_List_index
	25A6 A7             AND A												test
	25A7 28 0A          JR Z,br_25B3										if 0 skip to ??25B3??, else:
	25A9 3A AB 24       LD A,(character_direction)							get character_direction
	25AC 37             SCF													set Carry
	25AD 17             RLA													rotate left and set bit0 to 1
	25AE 32 12 01       LD (Current_Direction),A							update Current_Direction
	25B1 18 03          JR br_25B6

br_25B3
	25B3 32 58 46       LD (access_new_room_code),A							update access_new_room_code
br_25B6
	25B6 CD 87 27       CALL CharThing4

br_25B9:
	25B9 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	25BC E5             PUSH HL
	25BD FD E1          POP IY
	25BF FD 7E 07       LD A,(IY+O_Z)
	25C2 FE 84          CP 84
	25C4 30 0F          JR NC,DoSomething
	25C6 AF             XOR A
	25C7 32 8F 24       LD (248F),A
	25CA 3A BC 1E       LD A,(FloorAboveFlag)
	25CD A7             AND A
	25CE 20 05          JR NZ,DoSomething
	25D0 3E 06          LD A,06												"go room Above" code
	25D2 32 58 46       LD (access_new_room_code),A							update access_new_room_code
.DoSomething:
	; Check for Fire being pressed
	25D5 3A 15 01       LD A,(FireDonuts_Pressed)							get FireDonuts_Pressed
	25D8 1F             RRA													get bit0 in Carry
	25D9 30 66          JR NC,CheckDying									Carry reset so not pressed, jump to CheckDying, else:
	25DB 3A 84 24       LD A,(selected_characters)							get selected_characters
	25DE F6 FD          OR FD												~#02 test for Head
	25E0 3C             INC A												if bit1 was 1, then A is now 0
	25E1 21 AC 24       LD HL,Saved_Objects_List_index						point on Saved_Objects_List_index
	25E4 B6             OR (HL)
	25E5 20 57          JR NZ,CantDoSomething 								; Skips if not Head (alone)
	25E7 3A 7B 24       LD A,(Inventory)									get inventory
	25EA F6 F9          OR F9												~#06 test bits 2 (Donuts) and 1 (Hooter)
	25EC 3C             INC A												A is now 0 if we have both Hotter and donuts
	25ED 20 4F          JR NZ,CantDoSomething 								Skips to CantDoSomething if don't have donuts and a hooter, else:
	25EF 3A A8 24       LD A,(FiredObj_variables+O_ANIM)
	25F2 FE 08          CP 08
	25F4 20 48          JR NZ,CantDoSomething								if there is an Anim loop jump CantDoSomething, else:
	25F6 21 C7 24       LD HL,Head_variables+O_U							Head U
	25F9 11 9E 24       LD DE,FiredObj_variables+O_U						FiredObj U
	25FC 01 03 00       LD BC,0003											U,V and Z
	25FF ED B0          LDIR												Copies X/Y/Z coordinate from Head to fired donut. repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	2601 21 99 24       LD HL,FiredObj_variables
	2604 E5             PUSH HL
	2605 FD E1          POP IY												Sets IY to FiredObj_variables
	2607 3A 10 01       LD A,(Do_Objects_Phase)								get Do_Objects_Phase
	260A F6 19          OR 19												ObjFnFire
	260C 32 A3 24       LD (FiredObj_variables+O_FUNC),A
	260F FD 36 04 00    LD (IY+O_FLAGS),00									Init fire obj flags ;
	2613 3A AB 24       LD A,(character_direction)							get character_direction
	2616 32 A4 24       LD (FiredObj_variables+0B),A
	2619 FD 36 0C FF    LD (IY+0C),FF										??? displacement if merges ???
	261D FD 36 0F 20    LD (IY+O_ANIM),20									anim sprite in [7:3] = #04 and frame = 0
	2621 CD 66 3A 		CALL EnlistAux
	; Use up a donut
	2624 3E 06       	LD A,06
	2626 CD 43 41       CALL Decrement_counter_and_display
	2629 06 48          LD B,48												Sound ID #48 = Donut use
	262B CD 91 0D       CALL Play_Sound
	262E 3A 82 24       LD A,(nb_donuts)
	2631 A7             AND A												To test if A==0
	2632 20 0D          JR NZ,CheckDying									if A > 0 then can shoot Donut  ; if we put a #18 0D (JR CheckDying) then we have infinite Shoots
	2634 21 7B 24       LD HL,Inventory										point on inventory
	2637 CB 96          RES 2,(HL)
	2639 CD 9C 45       CALL Draw_Screen_Periphery
	263C 18 03          JR CheckDying

.CantDoSomething:
	263E CD 71 02       CALL Play_Sound_NoCanDo
.CheckDying:
	2641 21 58 46       LD HL,access_new_room_code							point on access_new_room_code
	2644 7E             LD A,(HL)											get access_new_room_code
	2645 E6 7F          AND 7F												ignore bit7
	2647 C8             RET Z												if (#80 () or #00 (staying in same room)) leave, else (change room):
	2648 3A 59 46       LD A,(DyingAnimFrameIndex)							get DyingAnimFrameIndex
	264B A7             AND A												test
	264C 28 03          JR Z,FinishedDying									if 0 (finished dying) continue at FinishedDying, else (Dying):
	264E 36 00          LD (HL),00											indicate we stay in the room, we can't change room when dying
	2650 C9             RET

;; -----------------------------------------------------------------------------------------------------------
FinishedDying:
	2651 3A 85 24       LD A,(both_in_same_room)							get both_in_same_room
	2654 A7             AND A												test
	2655 28 32          JR Z,nfc_end										no? then jump nfc_end, else:
	2657 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	265A E5             PUSH HL
	265B FD E1          POP IY
	265D CD F1 3A       CALL Unlink
	2660 3A 84 24       LD A,(selected_characters)							get selected_characters
	2663 FE 03          CP 03
	2665 28 22          JR Z,nfc_end
	2667 21 96 24       LD HL,2496
	266A BE             CP (HL)
	266B 28 05          JR Z,br_2672
	266D EE 03          XOR 03
	266F 77             LD (HL),A
	2670 18 0B          JR br_267D

br_2672
	2672 21 31 BB       LD HL,BB31											copy the 5 bytes in the buffer in the 3 variables from 2492
	2675 11 92 24       LD DE,2492
	2678 01 05 00       LD BC,0005
	267B ED B0          LDIR												repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0

br_267D
	267D 21 00 00       LD HL,0000
	2680 22 BD 24       LD (Heels_variables+0D),HL							reset Heels item #D and #E
	2683 22 CF 24       LD (Head_variables+0D),HL							reset Head item #D and #E
	2686 CD 73 03       CALL Save_array										SaveStuff
nfc_end:
	2689 21 00 00       LD HL,0000											reset Carrying
	268C 22 97 24       LD (Carrying),HL
	268F C3 8D 01       JP Go_to_room										Change room

br_2692
	2692 35             DEC (HL)
	2693 2A 84 24       LD HL,(selected_characters)							get selected_characters and both_in_same_room
	2696 C3 33 27       JP CharThing18

br_2699:
	2699 35             DEC (HL)
	269A 2A 84 24       LD HL,(selected_characters)							get selected_characters and both_in_same_room
	269D C2 3C 27       JP NZ,CharThing19
	26A0 3E 07          LD A,07												Teleport Code
	26A2 32 58 46       LD (access_new_room_code),A							update access_new_room_code
	26A5 C3 B9 25       JP br_25B9

;; -----------------------------------------------------------------------------------------------------------
.HandleDeath:
	26A8 35             DEC (HL)											decrease DyingAnimFrameIndex
	26A9 C2 39 27       JP NZ,CharThing20									in the process of dying go CharThing20, else dead:
end_of_death:
	26AC 21 00 00       LD HL,0000
	26AF 22 97 24       LD (Carrying),HL
	26B2 21 80 24       LD HL,Characters_lives								point on Characters_lives
	26B5 ED 4B 5A 46    LD BC,(Dying)
	26B9 06 02          LD B,02
	26BB 16 FF          LD D,FF
hded_loop:
	26BD CB 19          RR C
	26BF 30 09          JR NC,br_26CA
	26C1 7E             LD A,(HL)											Sub 1 to a base10 value in HL (1st time : Characters_lives = Heels lives; 2nd time : Characters_lives + 1)
	26C2 D6 01          SUB 01
	26C4 27             DAA													This subroutine is used to decrease Head's or Heels' lives
	26C5 77             LD (HL),A											a 00 (NOP) here, gives infinite lives
	26C6 20 02          JR NZ,br_26CA
	26C8 16 00          LD D,00												; D updated to $00 if any lives reduced.
br_26CA
	26CA 23             INC HL												points on Head's lives
	26CB 10 F0          DJNZ hded_loop
	; If no lives left, game over.
	26CD 2B             DEC HL
	26CE 7E             LD A,(HL)
	26CF 2B             DEC HL
	26D0 B6             OR (HL)
	26D1 CA 19 01       JP Z,Game_over										if Z set then Game_over
	; No lives lost, then skip to the end.
	26D4 7A             LD A,D
	26D5 A7             AND A
	26D6 20 39          JR NZ,HD_8
	26D8 21 80 24       LD HL,Characters_lives								point on Characters_lives
	26DB 3A 85 24       LD A,(both_in_same_room)							get both_in_same_room
	26DE A7             AND A												test A
	26DF 28 1E          JR Z,HD_6											if 0 (not in same room) jump HD_6, else (same room):
	26E1 3A 96 24       LD A,(2496)
	26E4 FE 03          CP 03												TODO is this to share a life when one has 0, borrow 1 life to the other char.
	26E6 20 0C          JR NZ,hddth_1
	26E8 7E             LD A,(HL)
	26E9 A7             AND A
	26EA 3E 01          LD A,01
	26EC 20 01          JR NZ,br_26EF
	26EE 3C             INC A
br_26EF
	26EF 32 96 24       LD (2496),A
	26F2 18 1D          JR HD_8

hddth_1:
	26F4 1F             RRA
	26F5 38 01          JR C,hddth_skip_inc
	26F7 23             INC HL
hddth_skip_inc:
	26F8 7E             LD A,(HL)
	26F9 A7             AND A
	26FA 20 12          JR NZ,br_270E
	26FC 32 85 24       LD (both_in_same_room),A							update both_in_same_room; InSameRoom

HD_6:
	;; Current character has no more lives, switch to other character"
	26FF CD 92 02       CALL Switch_Character
	2702 21 00 00       LD HL,0000
	2705 22 59 46       LD (DyingAnimFrameIndex),HL							reset DyingAnimFrameIndex and Dying
HD_7:
	2708 21 10 BB       LD HL,Other_Character_state
	270B CB C6          SET 0,(HL)
	270D C9             RET

br_270E
	270E CD 08 27       CALL HD_7
HD_8
	2711 3A 96 24       LD A,(2496)
	2714 32 84 24       LD (selected_characters),A							update selected_characters
	2717 CD 7B 27       CALL CharThing3
	271A CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	271D 11 05 00       LD DE,0005											object link list is 5 bytes per element
	2720 19             ADD HL,DE											update pointer
	2721 EB             EX DE,HL
	2722 21 93 24       LD HL,EntryPosn
	2725 01 03 00       LD BC,0003
	2728 ED B0          LDIR												repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	272A 3A 92 24       LD A,(2492)
	272D 32 58 46       LD (access_new_room_code),A							update access_new_room_code
	2730 C3 B9 01       JP Long_move_to_new_room

CharThing18:
	2733 E5             PUSH HL
	2734 21 FA 24       LD HL,VapeLoop2										VapeLoop2 anim
	2737 18 07          JR CharThing21

CharThing20:
	2739 2A 5A 46       LD HL,(Dying)
CharThing19:
	273C E5             PUSH HL
	273D 21 EC 24       LD HL,Vapeloop1										Vapeloop1 anim index
CharThing21:
	2740 FD 21 B0 24    LD IY,Heels_variables
	2744 CD 6F 44       CALL Read_Loop_byte
	2747 E1             POP HL
	2748 E5             PUSH HL
	2749 CB 4D          BIT 1,L
	274B 28 15          JR Z,br_2762
	274D F5             PUSH AF
	274E 32 CA 24       LD (Head_variables+O_SPRITE),A
	2751 FD CB 16 9E    RES 3,(IY+Head_offset+O_FLAGS)						; #16 = #12 + #04
	2755 21 C2 24       LD HL,Head_variables
	2758 CD A3 1C       CALL StoreObjExtents
	275B 21 C2 24       LD HL,Head_variables
	275E CD EB 1C       CALL UnionAndDraw
	2761 F1             POP AF
br_2762
	2762 E1             POP HL
	2763 CB 1D          RR L
	2765 D0             RET NC
	2766 EE 80          XOR 80
	2768 32 B8 24       LD (Heels_variables+O_SPRITE),A
	276B FD CB 04 9E    RES 3,(IY+O_FLAGS)
	276F 21 B0 24       LD HL,Heels_variables
	2772 CD A3 1C       CALL StoreObjExtents
	2775 21 B0 24       LD HL,Heels_variables
	2778 C3 EB 1C       JP UnionAndDraw

;; -----------------------------------------------------------------------------------------------------------
;; Put bit 0 of A into bit 2 of SwopPressed
CharThing3:
	277B E6 01          AND 01												keep bit0 (put Carry=0???)
	277D 07             RLCA
	277E 07             RLCA												and put it in bit2
	277F 21 14 01       LD HL,SwopChara_Pressed								point on SwopChara_Pressed
	2782 CB 96          RES 2,(HL)											reset bit 2 of SwopChara_Pressed
	2784 B6             OR (HL)												keep the other bits as is
	2785 77             LD (HL),A											and put the new value of bit2 = value from bit0
	2786 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Looks like more movement stuff
CharThing4:
	2787 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	278A E5             PUSH HL
	278B FD E1          POP IY
	278D 3E 3F          LD A,3F												3F ; Stop 0x0X noise
	278F 32 AD 24       LD (Other_sound_ID),A								update Other_sound_ID
	2792 3A AC 24       LD A,(Saved_Objects_List_index)						get Saved_Objects_List_index
	2795 CD C1 39       CALL SetObjList
	2798 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	279B CD A3 1C       CALL StoreObjExtents
	279E 21 8F 24       LD HL,248F
	27A1 7E             LD A,(HL)
	27A2 A7             AND A
	27A3 28 53          JR Z,br_27F8
	27A5 3A AC 24       LD A,(Saved_Objects_List_index)						get Saved_Objects_List_index
	27A8 A7             AND A
	27A9 28 04          JR Z,br_27AF
	27AB 36 00          LD (HL),00
	27AD 18 49          JR br_27F8

br_27AF
	27AF 35             DEC (HL)
	27B0 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	27B3 CD 31 2E       CALL ChkSatOn
	27B6 38 0A          JR C,br_27C2
	27B8 FD 35 07       DEC (IY+O_Z)
	27BB 3E 84          LD A,84												84 ; TODO: Repeated rising sequence
	27BD CD 21 2B       CALL SetOtherSound
	27C0 18 11          JR br_27D3

br_27C2
	27C2 08             EX AF,AF
	27C3 3E 88          LD A,88												88   ; TODO: Menu blip
	27C5 FD CB 0B 66    BIT 4,(IY+0B)
	27C9 FD CB 0B E6    SET 4,(IY+0B)
	27CD CC 21 2B       CALL Z,SetOtherSound
	27D0 08             EX AF,AF
	27D1 28 0B          JR Z,br_27DE
br_27D3
	27D3 FD CB 0B A6    RES 4,(IY+0B)
	27D7 FD CB 0B EE    SET 5,(IY+0B)
	27DB FD 35 07       DEC (IY+O_Z)
br_27DE
	27DE 3A 84 24       LD A,(selected_characters)							get selected_characters
	27E1 E6 02          AND 02
	27E3 20 06          JR NZ,br_27EB
br_27E5
	27E5 3A AB 24       LD A,(character_direction)							get character_direction
	27E8 C3 59 28       JP HandleMove

br_27EB
	27EB 3A 12 01       LD A,(Current_Direction)							get Current_Direction
	27EE 1F             RRA
	27EF CD 0F 44       CALL Get_dir_code_LRDU_bitmap
	27F2 3C             INC A
	27F3 C2 55 28       JP NZ,br_2855
	27F6 18 ED          JR br_27E5

br_27F8
	27F8 FD CB 0B E6    SET 4,(IY+0B)
	27FC FD CB 0C EE    SET 5,(IY+0C)
	2800 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	2803 3A 58 46       LD A,(access_new_room_code)							get access_new_room_code
	2806 A7             AND A												test
	2807 20 09          JR NZ,br_2812
	2809 CD 64 2C       CALL DoorContact
	280C D2 14 29       JP NC,CharThing23
	280F C2 02 29       JP NZ,CharThing22
br_2812
	2812 3A 58 46       LD A,(access_new_room_code)							get access_new_room_code
	2815 17             RLA
	2816 30 04          JR NC,br_281C
	2818 FD 36 0C FF    LD (IY+0C),FF
br_281C
	281C 3E 86          LD A,86
	281E FD CB 0B 6E    BIT 5,(IY+0B)
	2822 FD CB 0B EE    SET 5,(IY+0B)
	2826 CC 21 2B       CALL Z,SetOtherSound
	2829 FD CB 0C 66    BIT 4,(IY+0C)
	282D FD CB 0C E6    SET 4,(IY+0C)
	2831 20 18          JR NZ,br_284B
	2833 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	2836 CD 31 2E       CALL ChkSatOn
	2839 30 09          JR NC,EPIC_40
	283B 20 07          JR NZ,EPIC_40
	283D 3E 88          LD A,88												88   ; TODO Menu blip
	283F CD 21 2B       CALL SetOtherSound
	2842 18 07          JR br_284B

EPIC_40:
	2844 FD 35 07       DEC (IY+O_Z)
	2847 FD CB 0B A6    RES 4,(IY+0B)
br_284B
	284B AF             XOR A
	284C 32 8E 24       LD (248E),A
	284F CD 8A 2A       CALL DoCarry
	2852 CD 10 2A       CALL DoJump
br_2855
	2855 3A 12 01       LD A,(Current_Direction)							get Current_Direction
	2858 1F             RRA
.HandleMove:																;; Do the movement with direction in A.
	2859 CD 78 29       CALL MoveChar
	285C CD 64 29       CALL Orient
	285F 08             EX AF,AF
	2860 3A 90 24       LD A,(IsStill)
	2863 3C             INC A
	2864 20 26          JR NZ,br_288C
	;; Character-is-still case.
    ;; Reset the animation loops for whichever Character is running now.
	2866 AF             XOR A
	2867 21 84 24       LD HL,selected_characters							points on selected_characters
	286A CB 46          BIT 0,(HL)
	286C 28 06          JR Z,br_2874
	286E 32 D4 24       LD (HeelsLoop),A									HeelsLoop anim index
	2871 32 DA 24       LD (HeelsBLoop),A									HeelsBLoop anim index
br_2874
	2874 CB 4E          BIT 1,(HL)
	2876 28 06          JR Z,br_287E
	2878 32 E0 24       LD (HeadLoop),A										HeadLoop anim index
	287B 32 E6 24       LD (HeadBLoop),A									HeadBLoop anim index
br_287E
	;; If Head is facing towards us, do blink. Set BC appropriately.
	287E 08             EX AF,AF
	287F 01 21 1B       LD BC,1B21											BC,SPR_HEELSB1 << 8 | SPR_HEADB1
	2882 38 38          JR C,br_28BC
	2884 CD F0 28       CALL DoBlinkHeadEyes
	2887 01 1F 18       LD BC,181F											BC,SPR_HEELS1 << 8 | SPR_HEAD2
	288A 18 30          JR br_28BC

br_288C
	;; Choose animation frame for movement.
    ;; A' carry -> facing away.
	288C 08             EX AF,AF
	288D 21 D4 24       LD HL,HeelsLoop										HeelsLoop anim index
	2890 11 E0 24       LD DE,HeadLoop										HeadLoop anim index
	2893 30 06          JR NC,br_289B
	2895 21 DA 24       LD HL,HeelsBLoop									HeelsBLoop anim index
	2898 11 E6 24       LD DE,HeadBLoop										HeadBLoop anim index
br_289B
	289B D5             PUSH DE
	289C 3A 84 24       LD A,(selected_characters)							get selected_characters
	289F 1F             RRA
	28A0 30 06          JR NC,br_28A8
	28A2 CD 6F 44       CALL Read_Loop_byte
	28A5 32 B8 24       LD (Heels_variables+O_SPRITE),A
br_28A8
	28A8 E1             POP HL
	;; Update Head sprite (Head_variables+O_SPRITE) if Character contains Head.
	28A9 3A 84 24       LD A,(selected_characters)							get selected_characters
	28AC E6 02          AND 02
	28AE 28 06          JR Z,br_28B6
	28B0 CD 6F 44       CALL Read_Loop_byte
	28B3 32 CA 24       LD (Head_variables+O_SPRITE),A
br_28B6
	28B6 FD CB 0B EE    SET 5,(IY+0B)
	28BA 18 18          JR UpdateChar
br_28BC
	28BC FD CB 0B EE    SET 5,(IY+0B)
;; Update the character animation frames to values in BC, and then
;; call UpdateChar.
.UpdateCharFrame:
	28C0 3A 84 24       LD A,(selected_characters)							get selected_characters
	28C3 1F             RRA
	28C4 30 03          JR NC,br_28C9
	; Heels case.
	28C6 FD 70 08       LD (IY+08),B
br_28C9
	28C9 3A 84 24       LD A,(selected_characters)							get selected_characters
	28CC E6 02          AND 02
	28CE 28 04          JR Z,UpdateChar
	; Head case.
	28D0 79             LD A,C
	28D1 32 CA 24       LD (Head_variables+O_SPRITE),A
;; Actually resort and redraw the character in IY.
.UpdateChar:
	28D4 3A AF 24       LD A,(Movement)
	28D7 FD 77 0C       LD (IY+0C),A
	28DA CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	28DD CD E9 3A       CALL Relink
	28E0 CD 32 2C       CALL SaveObjListIdx
	28E3 AF             XOR A
	28E4 CD C1 39       CALL SetObjList 									; Switch to default object list
	28E7 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	28EA CD EB 1C       CALL UnionAndDraw
	28ED C3 28 2B       JP Play_other_sound

;; -----------------------------------------------------------------------------------------------------------
;; Update the blink counter, checks it, and blink or unblink Head's eyes.
.DoBlinkHeadEyes:
	28F0 21 05 25       LD HL,BlinkEyesCounter
	28F3 35             DEC (HL)											; fecrease blink counter
	28F4 3E 03          LD A,03
	28F6 96             SUB (HL)
	28F7 D8             RET C												; if blink couter > 3, RET with Carry set, else:

	28F8 28 05          JR Z,do_blink										; if blink couter == 3, jump to do_blink, else:
	28FA FE 03          CP 03												; that's "compare blink counter to 0"
	28FC C0             RET NZ												; no? RET Z reset, else:
	28FD 36 40          LD (HL),40											; this resets blink counter and "unblink" by recalling do_blink:
do_blink:
	28FF C3 06 25       JP BlinkEyes										; Blink Head's eyes (or unblink if done again).

;; -----------------------------------------------------------------------------------------------------------
CharThing22:
	2902 21 8E 24       LD HL,248E
	2905 7E             LD A,(HL)
	2906 A7             AND A
	2907 36 FF          LD (HL),FF
	2909 28 0E          JR Z,CharThing24
	290B CD 8A 2A       CALL DoCarry
	290E CD 10 2A       CALL DoJump
	2911 AF             XOR A
	2912 18 05          JR CharThing24

CharThing23:
	2914 AF             XOR A
	2915 32 8E 24       LD (248E),A
	2918 3C             INC A
CharThing24:
	2919 4F             LD C,A
	291A CD 0A 2A       CALL ResetTickTock
	291D FD CB 0B AE    RES 5,(IY+0B)
	2921 3A 84 24       LD A,(selected_characters)							get selected_characters
	2924 E6 02          AND 02
	2926 20 06          JR NZ,br_292E
	2928 0D             DEC C
	2929 20 1B          JR NZ,br_2946
	292B FD 34 07       INC (IY+07)
br_292E
	292E FD 34 07       INC (IY+07)
	2931 A7             AND A
	2932 20 15          JR NZ,br_2949
	2934 3E 82          LD A,82												82   ; TODO: Faster falling noise
	2936 CD 21 2B       CALL SetOtherSound
	2939 21 83 24       LD HL,jump_force____to_be_checked
	293C 7E             LD A,(HL)
	293D A7             AND A
	293E 28 15          JR Z,br_2955
	2940 35             DEC (HL)
	2941 3A AB 24       LD A,(character_direction)							get character_direction
	2944 18 0C          JR br_2952

br_2946
	2946 FD 34 07       INC (IY+07)
br_2949
	2949 3E 83          LD A,83												83   ; TODO: Slower falling noise
	294B CD 21 2B       CALL SetOtherSound
	294E 3A 12 01       LD A,(Current_Direction)							get Current_Direction
	2951 1F             RRA
br_2952
	2952 CD 78 29       CALL MoveChar
br_2955
	2955 CD 64 29       CALL Orient
	2958 01 21 1B       LD BC,1B21											SPR_HEELSB1 << 8 | SPR_HEADB1
	295B DA C0 28       JP C,UpdateCharFrame
	295E 01 4D 18       LD BC,184D											SPR_HEELS1 << 8 | SPR_HEAD_FLYING
	2961 C3 C0 28       JP UpdateCharFrame

;; Sets bit 4 of offset 4 if $02 bit is set (sprite needs flip),
;; returns with carry if facing away.
.Orient:
	2964 3A AB 24       LD A,(character_direction)							get character_direction
	2967 CD 0F 44       CALL Get_dir_code_LRDU_bitmap
	296A 1F             RRA
	296B FD CB 04 A6    RES 4,(IY+O_FLAGS)
	296F 1F             RRA
	2970 38 04          JR C,br_2976
	2972 FD CB 04 E6    SET 4,(IY+O_FLAGS)
br_2976
	2976 1F             RRA
	2977 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Move the character.
.MoveChar:
	2978 F6 F0          OR F0
	297A FE FF          CP FF
	297C 32 90 24       LD (IsStill),A
	297F 28 12          JR Z,br_2993
	2981 08             EX AF,AF
	2982 AF             XOR A
	2983 32 90 24       LD (IsStill),A
	2986 3E 80          LD A,80												80 ; Slower walking sound
	2988 CD 21 2B       CALL SetOtherSound
	298B 08             EX AF,AF
	298C 21 AB 24       LD HL,character_direction							points on character_direction
	298F BE             CP (HL)
	2990 77             LD (HL),A
	2991 28 05          JR Z,br_2998
br_2993
	2993 CD 0A 2A       CALL ResetTickTock
	2996 3E FF          LD A,FF
br_2998
	2998 F5             PUSH AF
	2999 FD A6 0C       AND (IY+0C)
	299C CD 0F 44       CALL Get_dir_code_LRDU_bitmap
	299F FE FF          CP FF
	29A1 28 13          JR Z,br_29B6
	29A3 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	29A6 CD 5C 46       CALL Move
	29A9 30 15          JR NC,Sub_Move_Char
	29AB FD 7E 0B       LD A,(IY+0B)
	29AE F6 F0          OR F0
	29B0 3C             INC A
	29B1 3E 88          LD A,88												88   ; TODO: Menu blip
	29B3 C4 21 2B       CALL NZ,SetOtherSound
br_29B6
	29B6 F1             POP AF
	29B7 FD 7E 0B       LD A,(IY+0B)
	29BA F6 0F          OR 0F
	29BC FD 77 0B       LD (IY+0B),A
	29BF C9             RET

;; -----------------------------------------------------------------------------------------------------------
.Sub_Move_Char
    ;; Direction bitmask is on stack. "Move" has been called.
    ;; Update position and do the speed-related movement when when
    ;; TickTock hits zero.
	29C0 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	29C3 CD 55 44       CALL UpdatePos
	29C6 C1             POP BC
	29C7 21 91 24       LD HL,TickTock
	29CA 7E             LD A,(HL)
	29CB A7             AND A
	29CC 28 02          JR Z,Slide
	29CE 35             DEC (HL)
	29CF C9             RET

;; -----------------------------------------------------------------------------------------------------------
.Slide:
	;; Do a bit more movement if we're Heels or have speed.
    ;; Direction bitmask is in B
	29D0 21 7C 24       LD HL,Speed
	29D3 3A 84 24       LD A,(selected_characters)							get selected_characters
	29D6 E6 01          AND 01
	29D8 B6             OR (HL)
	29D9 C8             RET Z
	29DA 21 89 24       LD HL,SpeedModulo
	29DD 35             DEC (HL)
	29DE C5             PUSH BC
	29DF 20 0D          JR NZ,br_29EE
	29E1 36 02          LD (HL),02
	29E3 3A 84 24       LD A,(selected_characters)							get selected_characters
	29E6 1F             RRA
	29E7 38 05          JR C,br_29EE
	; Use up speed if heels not present
	29E9 3E 00          LD A,00
	29EB CD 43 41       CALL Decrement_counter_and_display
br_29EE
	29EE 3E 81          LD A,81												$81 ; TODO: Running sound.
	29F0 CD 21 2B       CALL SetOtherSound
	; Convert bitmap to direction.
	29F3 F1             POP AF
	29F4 CD 0F 44       CALL Get_dir_code_LRDU_bitmap
	; Return if not moving...
	29F7 FE FF          CP FF
	29F9 C8             RET Z
	; And do a bit of movement.
	29FA CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	29FD E5             PUSH HL
	29FE CD 5C 46       CALL Move
	2A01 E1             POP HL
	2A02 D2 55 44       JP NC,UpdatePos
	;; Failing to move...
	2A05 3E 88          LD A,88												Sound_Id $88 ; TODO: Menu blip
	2A07 C3 21 2B       JP SetOtherSound

;; -----------------------------------------------------------------------------------------------------------
; The TickTock counter cycles down from 2. Reset it.
.ResetTickTock:
	2A0A 3E 02          LD A,02
	2A0C 32 91 24       LD (TickTock),A
	2A0F C9             RET

;; -----------------------------------------------------------------------------------------------------------
.DoJump:
	2A10 3A 84 24       LD A,(selected_characters)							get selected_characters
	;; Zero if it's Heels
	2A13 47             LD B,A
	2A14 3D             DEC A												if selected_characters was not Heels (not 2b01)
	2A15 20 04          JR NZ,djmp_skip										then skip, else (Head):
	2A17 AF             XOR A												A = 0
	2A18 32 83 24       LD (jump_force____to_be_checked),A					reset jump force
djmp_skip:
	2A1B 3A AC 24       LD A,(Saved_Objects_List_index)						get Saved_Objects_List_index
	2A1E A7             AND A
	2A1F C0             RET NZ
	; Return if jump not pressed.
	2A20 3A 12 01       LD A,(Current_Direction)							get Current_Direction
	2A23 1F             RRA
	2A24 D8             RET C
	;; Jump button handling case
	2A25 0E 00          LD C,00
	2A27 FD 6E 0D       LD L,(IY+0D)
	2A2A FD 66 0E       LD H,(IY+0E)
	2A2D 7C             LD A,H
	2A2E B5             OR L
	2A2F 28 22          JR Z,br_2A53
	2A31 E5             PUSH HL
	2A32 DD E1          POP IX
	2A34 DD CB 09 46    BIT 0,(IX+O_SPRFLAGS)
	2A38 28 07          JR Z,br_2A41
	2A3A DD 7E 0B       LD A,(IX+0B)
	2A3D F6 CF          OR CF
	2A3F 3C             INC A
	2A40 C0             RET NZ
br_2A41
	2A41 DD 7E 08       LD A,(IX+O_SPRITE)
	2A44 E6 7F          AND 7F
	2A46 FE 57          CP 57												SPR_TELEPORT + jump will Teleport
	2A48 28 35          JR Z,OnTeleport										???jumping while on a teleporter: teleport????
	2A4A FE 2B          CP 2B												SPR_SPRING
	2A4C 28 04          JR Z,br_2A52
	2A4E FE 2C          CP 2C												SPR_SPRUNG
	2A50 20 01          JR NZ,br_2A53
br_2A52
	2A52 0C             INC C
br_2A53
	2A53 3A 84 24       LD A,(selected_characters)							get selected_characters
	2A56 E6 02          AND 02												test if Head
	2A58 20 09          JR NZ,br_2A63										if Head skip, else (Heels)
	; No Head - use up a spring
	2A5A C5             PUSH BC
	2A5B 3E 01          LD A,01												Spring index
	2A5D CD 43 41       CALL Decrement_counter_and_display					Use one Spring
	2A60 C1             POP BC
	2A61 28 01          JR Z,br_2A64
br_2A63
	;; Head
	2A63 0C             INC C
br_2A64
	2A64 79             LD A,C
	2A65 87             ADD A,A
	2A66 87             ADD A,A
	2A67 C6 04          ADD A,04
	2A69 FE 0C          CP 0C
	2A6B 20 02          JR NZ,br_2A6F
	2A6D 3E 0A          LD A,0A
br_2A6F
	2A6F 32 8F 24       LD (248F),A
	2A72 3E 85          LD A,85
	2A74 05             DEC B
	2A75 20 05          JR NZ,br_2A7C
	2A77 21 83 24       LD HL,jump_force____to_be_checked
	2A7A 36 07          LD (HL),07											Head's Jump force?
br_2A7C
	2A7C C3 21 2B       JP SetOtherSound

;; -----------------------------------------------------------------------------------------------------------
OnTeleport:
	2A7F 21 0C 08       LD HL,080C											Teleport_up_anim_length and Teleport_down_anim_length
	2A82 22 86 24       LD (Teleport_up_anim_length),HL						init 2 lengths of the teleport vape anim, beaming up and down
	2A85 06 C7          LD B,C7												Sound_ID $C7 ; Teleporter beam up noise
	2A87 C3 91 0D       JP Play_Sound	 									will RET

;; -----------------------------------------------------------------------------------------------------------
.DoCarry:
	2A8A 3A 13 01       LD A,(CarryObject_Pressed)							; get CarryObject_Pressed
	2A8D 1F             RRA													; Carry key pressed?
	2A8E D0             RET NC												; no : leave with NC, else:
	2A8F 3A 7B 24       LD A,(Inventory)									; get inventory ; Check if we have the purse
	2A92 1F             RRA													; do we have the Purse?
purseNope:
	2A93 D2 71 02       JP NC,Play_Sound_NoCanDo							; no then leave to Play_Sound_NoCanDo, else:
	2A96 3A 84 24       LD A,(selected_characters)							; get selected_characters
	2A99 E6 01          AND 01												; Heels?
	2A9B 28 F6          JR Z,purseNope										; No, then jump back to purseNope (Play Nope sound and leave)
	2A9D 3E 87          LD A,87												; else: Sound ID Sweep down and up
	2A9F CD 21 2B       CALL SetOtherSound									;
	2AA2 3A 98 24       LD A,(Carrying+1)
	2AA5 A7             AND A												; test
	2AA6 20 1B          JR NZ,DropCarried									; If holding something, drop it
	2AA8 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	2AAB CD 02 2E       CALL GetStoodUpon
	2AAE 30 E3          JR NC,purseNope
	2AB0 DD 7E 08       LD A,(IX+O_SPRITE)									; Load sprite of thing carried
	2AB3 E5             PUSH HL
	2AB4 22 97 24       LD (Carrying),HL
	2AB7 01 B0 D8       LD BC,D8B0											CARRY_POSN = 216 << 8 | 176
	2ABA F5             PUSH AF
	2ABB CD F3 45       CALL Draw_sprite_3x24								; Draw the item now carried
	2ABE F1             POP AF
	2ABF E1             POP HL
	2AC0 C3 CA 44       JP RemoveObject

;; -----------------------------------------------------------------------------------------------------------
.DropCarried:
	2AC3 3A AC 24       LD A,(Saved_Objects_List_index)						get Saved_Objects_List_index
	2AC6 A7             AND A
	2AC7 C2 71 02       JP NZ,Play_Sound_NoCanDo							if NZ Play_Sound_NoCanDo
	2ACA FD 4E 07       LD C,(IY+07)
	2ACD 06 03          LD B,03
carryLoop:
	2ACF CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	2AD2 C5             PUSH BC
	2AD3 CD 31 2E       CALL ChkSatOn
	2AD6 C1             POP BC
	2AD7 38 3D          JR C,NoDrop
	2AD9 FD 35 07       DEC (IY+07)
	2ADC FD 35 07       DEC (IY+07)
	2ADF 10 EE          DJNZ carryLoop
	2AE1 2A 97 24       LD HL,(Carrying)
	2AE4 E5             PUSH HL
	2AE5 11 07 00       LD DE,0007
	2AE8 19             ADD HL,DE
	2AE9 E5             PUSH HL
	2AEA CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	2AED 11 06 00       LD DE,0006											curr Char variables+6 = V coord
	2AF0 19             ADD HL,DE
	2AF1 EB             EX DE,HL											; CharObj + 6 (V) in DE
	2AF2 E1             POP HL												; Object + 7 in HL
	2AF3 71             LD (HL),C											; Overwrite id thing with C...
	2AF4 EB             EX DE,HL
	2AF5 1B             DEC DE
	2AF6 ED A8          LDD
	2AF8 ED A8          LDD
	2AFA E1             POP HL
	2AFB CD FE 44       CALL InsertObject
	2AFE 21 00 00       LD HL,0000
	2B01 22 97 24       LD (Carrying),HL
	2B04 01 B0 D8       LD BC,D8B0											ARRY_POSN = 216 << 8 | 176
	2B07 CD 11 46       CALL Clear_3x24										; Clear out the what's-carried display
	2B0A CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	2B0D CD 64 2C       CALL DoorContact
	2B10 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	2B13 C3 A3 1C       JP StoreObjExtents

.NoDrop:
	2B16 FD 71 07       LD (IY+07),C										Restore old value
	2B19 C3 71 02       JP Play_Sound_NoCanDo								; will RET

.SetSound:
	2B1C 21 AE 24       LD HL,Sound_ID										pointer on Sound_ID
	2B1F 18 03          JR BumpUp

.SetOtherSound:
	2B21 21 AD 24       LD HL,Other_sound_ID								pointer on Other_sound_ID
.BumpUp:
	2B24 BE             CP (HL)												compare A and (HL)
	2B25 D8             RET C												if A < (HL) leave, else (A >= 5):
	2B26 77             LD (HL),A											update (HL) with A
	2B27 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.Play_other_sound:
	2B28 3A AD 24       LD A,(Other_sound_ID)								get Other_sound_ID
	2B2B F6 80          OR 80												bit7 set
	2B2D 47             LD B,A
	2B2E FE 85          CP 85												>= #85? (some bip and blips)
	2B30 D2 91 0D       JP NC,Play_Sound									yes, then play (will RET), else (#80 to #84 = movement sounds):
	2B33 3A 86 2F       LD A,(Sound_menu_data)								get Sound_menu_data
	2B36 A7             AND A												test
	2B37 C0             RET NZ												if Sound_menu_data != 0 leave, else play sound in B (movement sounds)
	2B38 C3 91 0D       JP Play_Sound										will RET

;; -----------------------------------------------------------------------------------------------------------
;; Get a pointer in HL on the selected character's variables
;; ie. if Heels selected HL = Heels_variables else Head_variables
.Get_curr_Char_variables:
	2B3B 21 84 24       LD HL,selected_characters							; points on selected_characters
	2B3E CB 46          BIT 0,(HL)											; is Heels selected?
	2B40 21 B0 24       LD HL,Heels_variables								; prepare return HL = Heels var
	2B43 C0             RET NZ												; if Heels selected then return pointer on Heels_variables
	2B44 21 C2 24       LD HL,Head_variables								;
	2B47 C9             RET													; else return pointer on Head_variables

;; -----------------------------------------------------------------------------------------------------------
CharThing15:
	2B48 AF             XOR A												A=0
	2B49 32 EC 24       LD (Vapeloop1),A									set anim index of "Vapeloop1" to 0
	2B4C 32 86 24       LD (Teleport_up_anim_length),A						set Teleport_up_anim_length to 0
	2B4F 32 FA 24       LD (VapeLoop2),A									set anim index of "Vapeloop2" to 0
	2B52 3E 08          LD A,08
	2B54 32 A8 24       LD (24A8),A											set ??? to 8 Fired_Obj+#0F
	2B57 CD 28 03       CALL Set_Character_Flags
	2B5A 3A 84 24       LD A,(selected_characters)							get selected_characters
	2B5D 32 96 24       LD (2496),A											update
	2B60 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	2B63 E5             PUSH HL
	2B64 E5             PUSH HL
	2B65 E5             PUSH HL
	2B66 FD E1          POP IY
	2B68 3A 58 46       LD A,(access_new_room_code)							get access_new_room_code
	2B6B 32 92 24       LD (2492),A											update
	2B6E F5             PUSH AF
	2B6F D6 01          SUB 01
	2B71 F5             PUSH AF
	2B72 FE 04          CP 04												if access_new_room_code >=5 ...
	2B74 30 17          JR NC,EPIC_86										...then jump EPIC_86, else (A 0 to 3 correspond to access_new_room_code 1 to 4):
	2B76 EE 01          XOR 01												flip bit0 (invert direction?)
	2B78 5F             LD E,A
	2B79 16 00          LD D,00												DE=A
	2B7B 21 EE 1E       LD HL,DoorHeights
	2B7E 19             ADD HL,DE											HL = DoorHeights+offset, with offset=A
	2B7F 4E             LD C,(HL)
	2B80 21 5E 2C       LD HL,WallSideBitmap								point on WallSideBitmap
	2B83 19             ADD HL,DE											HL = WallSideBitmap+offset, with offset=A
	2B84 3A C0 1E       LD A,(Has_no_wall)									get walls status
	2B87 A6             AND (HL)											apply bitmask
	2B88 20 03          JR NZ,EPIC_86										NZ jump EPIC_86
	2B8A FD 71 07       LD (IY+07),C
EPIC_86:
	2B8D CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	2B90 11 05 00       LD DE,0005
	2B93 19             ADD HL,DE											Curr Char Variable+5 (U coord)
	2B94 EB             EX DE,HL											in DE
	2B95 F1             POP AF
	2B96 38 4A          JR C,EPIC_93
	2B98 FE 06          CP 06
	2B9A 28 2E          JR Z,EPIC_90
	2B9C 30 3F          JR NC,EPIC_92
	2B9E FE 04          CP 04
	2BA0 30 13          JR NC,EPIC_88
	2BA2 21 C2 1E       LD HL,Max_min_UV_Table								pointer on MinU
	2BA5 0E FD          LD C,FD
	2BA7 1F             RRA
	2BA8 30 02          JR NC,EPIC_87
	2BAA 13             INC DE
	2BAB 23             INC HL
EPIC_87:
	2BAC 1F             RRA
	2BAD 38 3E          JR C,EPIC_95
	2BAF 0E 03          LD C,03
	2BB1 23             INC HL
	2BB2 23             INC HL
	2BB3 18 38          JR EPIC_95

EPIC_88:
	2BB5 13             INC DE
	2BB6 13             INC DE
	2BB7 1F             RRA
	2BB8 3E 84          LD A,84
	2BBA 30 0A          JR NC,EPIC_89
	2BBC 3A 6E 23       LD A,(236E)
	2BBF A7             AND A
	2BC0 3E BA          LD A,BA
	2BC2 28 02          JR Z,EPIC_89
	2BC4 3E B4          LD A,B4
EPIC_89:
	2BC6 12             LD (DE),A
	2BC7 F1             POP AF
	2BC8 18 32          JR EPIC_97

EPIC_90:
	2BCA 13             INC DE
	2BCB 13             INC DE
	2BCC 3A 6E 23       LD A,(236E)
	2BCF A7             AND A
	2BD0 28 04          JR Z,EPIC_91
	2BD2 1A             LD A,(DE)
	2BD3 D6 06          SUB 06
	2BD5 12             LD (DE),A
EPIC_91:
	2BD6 06 C8          LD B,C8												Sound_ID $C8 ; Teleport beam down noise
	2BD8 CD 91 0D       CALL Play_Sound
	2BDB 18 13          JR EPIC_96

EPIC_92:
	2BDD 21 5E 42       LD HL,UVZ_coord_Set_UVZ
	2BE0 18 03          JR EPIC_94

EPIC_93:
	2BE2 21 54 2C       LD HL,2C54											DE points on the curr Char U (*_variables+5)
EPIC_94:
	2BE5 ED A0          LDI													copy U ; do : LD (DE),(HL); DE++, HL++, BC--
	2BE7 ED A0          LDI													copy V
	2BE9 ED A0          LDI													copy Z
	2BEB 18 03          JR EPIC_96

EPIC_95:
	2BED 7E             LD A,(HL)
	2BEE 81             ADD A,C
	2BEF 12             LD (DE),A
EPIC_96:
	2BF0 F1             POP AF
	2BF1 C6 57          ADD A,57											2C57 & #00FF + offset
	2BF3 6F             LD L,A
	2BF4 CE 2C          ADC A,2C											(2C57 & #FF00 ) >> 8
	2BF6 95             SUB L
	2BF7 67             LD H,A
	2BF8 7E             LD A,(HL)
	2BF9 32 AB 24       LD (character_direction),A							update character_direction
EPIC_97:
	2BFC 3E 80          LD A,80
	2BFE 32 58 46       LD (access_new_room_code),A							update access_new_room_code
	2C01 E1             POP HL
	2C02 11 05 00       LD DE,0005
	2C05 19             ADD HL,DE
	2C06 11 93 24       LD DE,EntryPosn
	2C09 01 03 00       LD BC,0003
	2C0C ED B0          LDIR												repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	2C0E FD 36 0D 00    LD (IY+0D),00
	2C12 FD 36 0E 00    LD (IY+0E),00
	2C16 FD 36 0B FF    LD (IY+0B),FF
	2C1A FD 36 0C FF    LD (IY+0C),FF
	2C1E E1             POP HL
	2C1F CD 3B 3A       CALL Enlist
	2C22 CD 32 2C       CALL SaveObjListIdx
	2C25 AF             XOR A
	2C26 32 59 46       LD (DyingAnimFrameIndex),A							reset DyingAnimFrameIndex
	2C29 32 5A 46       LD (Dying),A										reset Dying
	2C2C 32 6E 23       LD (236E),A
	2C2F C3 C1 39       JP SetObjList										Switch to default object list

.SaveObjListIdx:
	2C32 3A A2 39       LD A,(ObjListIdx)
	2C35 32 AC 24       LD (Saved_Objects_List_index),A						update Saved_Objects_List_index
	2C38 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.DrawCarriedObject:
	2C39 3A 84 24       LD A,(selected_characters)							get selected_characters
	2C3C 21 85 24       LD HL,both_in_same_room								points on both_in_same_room ; InSameRoom
	2C3F 1F             RRA
	2C40 B6             OR (HL)
	2C41 1F             RRA
	2C42 D0             RET NC												Return if low bit not set on InSameRoom and not head
	2C43 2A 97 24       LD HL,(Carrying)
	2C46 24             INC H
	2C47 25             DEC H
	2C48 C8             RET Z												Return if high byte zero...
	2C49 11 08 00       LD DE,0008
	2C4C 19             ADD HL,DE
	2C4D 7E             LD A,(HL)											Get sprite from object pointed to...
	2C4E 01 B0 D8       LD BC,D8B0											CARRY_POSN = 216 << 8 | 176
	2C51 C3 F3 45       JP Draw_sprite_3x24

??? ;; UVZ for ???
	2C54 DATABYTE 28 28 C0

???Table something to do with charac direction:
	2C57 DATABYTE FD FD FB FE F7 FD FD										-3,-3,-5,-2,-9,-3,-3 ???

WallSideBitmap: 															index 0 = 8 = bit3, index 1 = 4 = bit2 etc.
	2C5E DATAWORD 08 04 02 01

.ObjContact:
	2C62 DATAWORD 00 00

; Takes object (character?) in IY
.DoorContact:
	2C64 CD 6E 2C       CALL GetDoorHeight
	2C67 FD 7E 07       LD A,(IY+O_Z)
	2C6A 91             SUB C
	; Call with A containing height above door.
	2C6B C3 FB 2C       JP DoContac

;; Takes object in IY, returns height of relevant door.
.GetDoorHeight:
    ;; Return $C0 if SavedObjListIdx == 0.
	2C6E 0E C0          LD C,C0
	2C70 3A AC 24       LD A,(Saved_Objects_List_index)						get Saved_Objects_List_index
	2C73 A7             AND A												test
	2C74 C8             RET Z												if index = 0 leave, else:
	2C75 DD 21 EE 1E    LD IX,DoorHeights
	2C79 DD 4E 00       LD C,(IX+00) 										return IX+$00 if near MaxV
	2C7C 3A C5 1E       LD A,(Max_min_UV_Table+3)							MaxV
	2C7F D6 03          SUB 03
	2C81 FD BE 06       CP (IY+O_V)
	2C84 D8             RET C
	2C85 DD 4E 02       LD C,(IX+02)										return IX+$02 if near MinV
	2C88 3A C3 1E       LD A,(Max_min_UV_Table+1)							MinV
	2C8B C6 02          ADD A,02
	2C8D FD BE 06       CP (IY+O_V)
	2C90 D0             RET NC
	2C91 DD 4E 01       LD C,(IX+01)										Return IX+$01 if near MaxU
	2C94 3A C4 1E       LD A,(Max_min_UV_Table+2)							MaxU
	2C97 D6 03          SUB 03
	2C99 FD BE 05       CP (IY+O_U)
	2C9C D8             RET C
	2C9D DD 4E 03       LD C,(IX+03)										Otherwise, return IX+$03
	2CA0 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.NearHitFloor:
	2CA1 FE FF          CP FF												This way, only get the start.
	;; A is zero. We've hit, or nearly hit, the floor.
.HitFloor:
	2CA3 37             SCF
	2CA4 FD 77 0D       LD (IY+0D),A
	2CA7 FD 77 0E       LD (IY+0E),A
	2CAA C0             RET NZ
	; Called HitFloor, not NearHitFloor.
	2CAB FD CB 09 46    BIT 0,(IY+O_SPRFLAGS)								sprite flag bit0
	2CAF 28 38          JR Z,FloorCheck					 					Floor check for non-player objects
    ;; Right, player has hit floor.
	2CB1 3A AC 24       LD A,(Saved_Objects_List_index)						get Saved_Objects_List_index ; SavedObjListIdx
	2CB4 A7             AND A												test
	2CB5 20 2F          JR NZ,RetZero_Cset									not 0 the leave with NZ and C, else:
	2CB7 3A BB 1E       LD A,(FloorCode)
	2CBA FE 06          CP 06												Deadly floor?
	2CBC 28 1F          JR Z,DeadlyFloorCase
	2CBE FE 07          CP 07												No floor?
	2CC0 20 24          JR NZ,RetZero_Cset
	; Code to handle no floor...
	2CC2 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	2CC5 FD E5          PUSH IY
	2CC7 D1             POP DE
	2CC8 A7             AND A
	2CC9 ED 52          SBC HL,DE
	2CCB 28 09          JR Z,HF_1
	2CCD 21 14 01       LD HL,SwopChara_Pressed								point on SwopChara_Pressed; SwopPressed
	2CD0 7E             LD A,(HL)
	2CD1 F6 03          OR 03												force Swop????
	2CD3 77             LD (HL),A
	2CD4 18 10          JR RetZero_Cset

HF_1:
	2CD6 3E 05          LD A,05												Next room below.
	2CD8 32 58 46       LD (access_new_room_code),A							update access_new_room_code
	2CDB A7             AND A
	2CDC C9             RET

;; -----------------------------------------------------------------------------------------------------------
.DeadlyFloorCase:
	2CDD FD 4E 09       LD C,(IY+O_SPRFLAGS)
	2CE0 FD 46 04       LD B,(IY+O_FLAGS)
	2CE3 CD 38 47       CALL DeadlyContact
;; Return with 0 in A, Z set and carry flag set.
.RetZero_Cset:
	2CE6 AF             XOR A
	2CE7 37             SCF
	2CE8 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; A non-player object has hit the floor...
.FloorCheck:
	2CE9 3A BB 1E       LD A,(FloorCode)
	2CEC FE 07          CP 07												No floor?
	2CEE 20 F6          JR NZ,RetZero_Cset
	2CF0 FD 36 0A 22    LD (IY+O_FUNC),22									Func = OBJFN_DISAPPEAR ; Then it disappears.
	2CF3 18 F0       	JR RetZero_Cset

;; -----------------------------------------------------------------------------------------------------------
;; Object (character?) in IY.
.DoContact2:
	2CF6 FD 7E 07       LD A,(IY+O_Z)
	2CF9 D6 C0          SUB C0
;; A contains height difference
.DoContact:
	; Clear what's on character so far.
	2CFB 01 00 00       LD BC,0000
	2CFE ED 43 62 2C    LD (ObjContact),BC
	; If we've hit the floor, go to that case
	2D02 28 9F          JR Z,HitFloor
	; Just above floor? Still call through
	2D04 3C             INC A
	2D05 28 9A          JR Z,NearHitFloor
	; Set C to high-Z plus one (i.e. what we're resting on)
	2D07 CD 24 3B       CALL GetUVZExtentsE
	2D0A 48             LD C,B
	2D0B 0C             INC C
	;; Looks like we use what we were on previously as our current
    ;; "on" object - avoid recomputation and keeps the object
    ;; consistent?
    ;;
    ;; Load the object character's on into IX. Go to ChkSitOn if null.
	2D0C D9             EXX
	2D0D FD 7E 0E       LD A,(IY+0E)
	2D10 A7             AND A
	2D11 28 41          JR Z,ChkSitOn
	2D13 67             LD H,A
	2D14 FD 6E 0D       LD L,(IY+0D)
	2D17 E5             PUSH HL
	2D18 DD E1          POP IX
	; Various other tests where we switch over to ChkSitOn.
	2D1A DD CB 04 7E    BIT 7,(IX+O_FLAGS)
	2D1E 20 34          JR NZ,ChkSitOn
	;; Check we're still on it.
	2D20 DD 7E 07       LD A,(IX+O_Z)
	2D23 D6 06          SUB 06
	2D25 D9             EXX
	2D26 B8             CP B
	2D27 D9             EXX
	2D28 20 2A          JR NZ,ChkSitOn
	2D2A CD C3 2E       CALL CheckWeOverlap
	2D2D 30 25          JR NC,ChkSitOn
;; We're still standing on the object
;; Deal with contact between a character and a thing.
;; IY is the character, IX is what it's resting on.
.DoObjContact:
    ;; If it's the second part of a double-height...
	2D2F DD CB 09 4E    BIT 1,(IX+O_SPRFLAGS)
	2D33 28 09          JR Z,DOC_1
	; Reset bit 5 of Offset C
	2D35 DD CB FA AE    RES 5,(IX+FA)										(IX-06)
	;; Load Offset B
	2D39 DD 7E F9       LD A,(IX+F9)										(IX-07)
	2D3C 18 07          JR DOC_2

;; Otherwise, do the same, but single-height.
DOC_1:
	2D3E DD CB 0C AE    RES 5,(IX+0C)
	2D42 DD 7E 0B       LD A,(IX+0B)
;; Mask Offset C of IY with top 3 bits of Offset C of stood-on object.
DOC_2:
	2D45 F6 E0          OR E0
	2D47 4F             LD C,A
	2D48 FD 7E 0C       LD A,(IY+0C)
	2D4B A1             AND C
	2D4C FD 77 0C       LD (IY+0C),A
.DoAltContact:
	2D4F AF             XOR A
	2D50 37             SCF
	2D51 C3 FF 46       JP Contact

;; -----------------------------------------------------------------------------------------------------------
;; Run through all the objects in the main object list and check their
;; contact with our object in IY, see if it's sitting on them or
;; touching them.
;;
;; Object extents should be in primed registers.
.ChkSitOn:
	2D54 21 AB 39       LD HL,ObjectLists + 2
CSIT_1:
	2D57 7E             LD A,(HL)
	2D58 23             INC HL
	2D59 66             LD H,(HL)
	2D5A 6F             LD L,A
	2D5B B4             OR H
	2D5C 28 38          JR Z,CSIT_4											Done - exit list.
	2D5E E5             PUSH HL
	2D5F DD E1          POP IX
	2D61 DD CB 04 7E    BIT 7,(IX+O_FLAGS)
	2D65 20 F0          JR NZ,CSIT_1										Bit set? Skip this item
	2D67 DD 7E 07       LD A,(IX+O_Z)										Check Z coord of top of obj against bottom of IY
	2D6A D6 06          SUB 06
	2D6C D9             EXX
	2D6D B8             CP B
	2D6E 20 10          JR NZ,CSIT_3										Go to differing height case.
	2D70 D9             EXX
	2D71 E5             PUSH HL
	2D72 CD C3 2E       CALL CheckWeOverlap
	2D75 E1             POP HL
	2D76 30 DF          JR NC,CSIT_1										Same height, overlap? Skip
CSIT_2:
	2D78 FD 75 0D       LD (IY+0D),L										Record what we're sitting on.
	2D7B FD 74 0E       LD (IY+0E),H
	2D7E 18 AF          JR DoObjContact 									Hit!

CSIT_3:
	2D80 B9             CP C
	2D81 D9             EXX
	2D82 20 D3          JR NZ,CSIT_1										Differs other way? Continue.
	; Same height instead.
	2D84 3A 63 2C       LD A,(ObjContact+1)
	2D87 A7             AND A
	2D88 20 CD          JR NZ,CSIT_1										Some test makes us skip...
	2D8A E5             PUSH HL
	2D8B CD C3 2E       CALL CheckWeOverlap
	2D8E E1             POP HL
	2D8F 30 C6          JR NC,CSIT_1										If we don't overlap, skip
	2D91 22 62 2C       LD (ObjContact),HL									; Store the object we're touching, carry on.
	2D94 18 C1          JR CSIT_1

	;; Completed object list traversal
CSIT_4:
	2D96 3A AC 24       LD A,(Saved_Objects_List_index)						get Saved_Objects_List_index
	2D99 A7             AND A
	2D9A 28 3B          JR Z,CSIT_7
	2D9C CD 9F 2E       CALL GetCharObjIX
	; Get Z coord of top of the character into A.
	2D9F 3A 84 24       LD A,(selected_characters)							get selected_characters
	2DA2 FE 03          CP 03
	2DA4 3E F4          LD A,F4												-12
	2DA6 28 02          JR Z,CSIT_5
	2DA8 3E FA          LD A,FA												-6
CSIT_5:
	2DAA DD 86 07       ADD A,(IX+O_Z)
	2DAD D9             EXX
	; Compare against bottom of us.
	2DAE B8             CP B
	2DAF 20 0A          JR NZ,CSIT_6
	;; We're on it, if we overlap.
	2DB1 D9             EXX
	2DB2 E5             PUSH HL
	2DB3 CD C3 2E       CALL CheckWeOverlap
	2DB6 E1             POP HL
	2DB7 30 1E          JR NC,CSIT_7
	2DB9 18 BD          JR CSIT_2

CSIT_6:
	2DBB B9             CP C
	2DBC D9             EXX
	2DBD 20 18          JR NZ,CSIT_7
	; Same height, making it pushable.
	2DBF 3A 63 2C       LD A,(ObjContact+1)
	2DC2 A7             AND A
	2DC3 20 12          JR NZ,CSIT_7										Give up if already in contact.
	2DC5 CD 9F 2E       CALL GetCharObjIX
	2DC8 CD C3 2E       CALL CheckWeOverlap
	2DCB 30 0A          JR NC,CSIT_7
	2DCD FD 36 0D 00    LD (IY+0D),00
	2DD1 FD 36 0E 00    LD (IY+0E),00
	2DD5 18 27          JR CSIT_11

CSIT_7:
	2DD7 2A 62 2C       LD HL,(ObjContact)
	2DDA FD 36 0D 00    LD (IY+0D),00
	2DDE FD 36 0E 00    LD (IY+0E),00
	2DE2 7C             LD A,H
	2DE3 A7             AND A
	2DE4 C8             RET Z
	2DE5 E5             PUSH HL
	2DE6 DD E1          POP IX
	2DE8 DD CB 09 4E    BIT 1,(IX+O_SPRFLAGS)
	2DEC 28 06          JR Z,CSIT_9
	2DEE DD CB F9 66    BIT 4,(IX+F9)											(IX-07)
	2DF2 18 04          JR CSIT_10
CSIT_9:
	2DF4 DD CB 0B 66    BIT 4,(IX+0B)
CSIT_10:
	2DF8 20 04          JR NZ,CSIT_11
	2DFA FD CB 0C A6    RES 4,(IY+0C)
CSIT_11:
	2DFE AF             XOR A
	2DFF D6 01          SUB 01
	2E01 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Called by the purse routine to find something to pick up.
;; Carry flag set if something is found, and thing returned in HL.
;;
;; Loop through all items, finding ones which match on B or C
;; Then call CheckWeOverlap to see if ok candidate. Return it
;; in HL if it is.
.GetStoodUpon:
	2E02 CD 24 3B       CALL GetUVZExtentsE									Perhaps getting height as a filter?
	2E05 78             LD A,B
	2E06 C6 06          ADD A,06
	2E08 47             LD B,A
	2E09 3C             INC A
	2E0A 4F             LD C,A
	2E0B D9             EXX
	;; Traverse list of objects in main object list
	2E0C 21 AB 39       LD HL,ObjectLists + 2
gsu_1:
	2E0F 7E             LD A,(HL)
	2E10 23             INC HL
	2E11 66             LD H,(HL)
	2E12 6F             LD L,A
	2E13 B4             OR H
	2E14 C8             RET Z
	2E15 E5             PUSH HL
	2E16 DD E1          POP IX
	2E18 DD CB 04 76    BIT 6,(IX+O_FLAGS)
	2E1C 28 F1          JR Z,gsu_1
	2E1E DD 7E 07       LD A,(IX+O_Z)
	2E21 D9             EXX
	2E22 B8             CP B
	2E23 28 01          JR Z,gsu_2
	2E25 B9             CP C
gsu_2:
	2E26 D9             EXX
	2E27 20 E6          JR NZ,gsu_1
	2E29 E5             PUSH HL
	2E2A CD C3 2E       CALL CheckWeOverlap
	2E2D E1             POP HL
	2E2E 30 DF          JR NC,gsu_1
	2E30 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Object in IY, extents in primed registers.
;; Very similar to ChkSitOn. Checks to see if stuff is on us.
.ChkSatOn:
    ;; Put top of object in B'
	2E31 CD 24 3B       CALL GetUVZExtentsE
	2E34 41             LD B,C
	2E35 05             DEC B
	2E36 D9             EXX
	;; Clear the thing on top of us
	2E37 AF             XOR A
	2E38 32 62 2C       LD (ObjContact),A
	2E3B 21 AB 39       LD HL,ObjectLists + 2
CSAT_1:
	2E3E 7E             LD A,(HL)
	2E3F 23             INC HL
	2E40 66             LD H,(HL)
	2E41 6F             LD L,A
	2E42 B4             OR H
	2E43 28 42          JR Z,CSAT_4											Reached end?
	2E45 E5             PUSH HL
	2E46 DD E1          POP IX
	2E48 DD CB 04 7E    BIT 7,(IX+O_FLAGS)
	2E4C 20 F0          JR NZ,CSAT_1										Skip if bit set
	2E4E DD 7E 07       LD A,(IX+O_Z)
	2E51 D9             EXX
	2E52 B9             CP C												Compare IY top with bottom of this object.
	2E53 20 1A          JR NZ,CSAT_3										Jump if not at same height
	2E55 D9             EXX
	2E56 E5             PUSH HL
	2E57 CD C3 2E       CALL CheckWeOverlap
	2E5A E1             POP HL
	2E5B 30 E1          JR NC,CSAT_1
    ;; Top of us = bottom of them, we have a thing on top.
    ;; Copy our movement over to the block on top.
CSAT_2:
	2E5D FD 7E 0B       LD A,(IY+0B)
	2E60 F6 E0          OR E0
	2E62 E6 EF          AND EF
	2E64 4F             LD C,A
	2E65 DD 7E 0C       LD A,(IX+0C)
	2E68 A1             AND C
	2E69 DD 77 0C       LD (IX+0C),A
	2E6C C3 4F 2D       JP DoAltContact

;; Not stacked
CSAT_3:
	2E6F B8             CP B
	2E70 D9             EXX
	2E71 20 CB          JR NZ,CSAT_1
	;; Same height instead
	2E73 3A 62 2C       LD A,(ObjContact)
	2E76 A7             AND A
	2E77 20 C5          JR NZ,CSAT_1										Continue if we're already in contact
	2E79 E5             PUSH HL
	2E7A CD C3 2E       CALL CheckWeOverlap
	2E7D E1             POP HL
	2E7E 30 BE          JR NC,CSAT_1
	2E80 3E FF          LD A,FF
	2E82 32 62 2C       LD (ObjContact),A									Set ObjContact to $FF and carry on.
	2E85 18 B7          JR CSAT_1

;; Finished traversing list. Check the character object.
CSAT_4:
	2E87 3A AC 24       LD A,(Saved_Objects_List_index)						get Saved_Objects_List_index; Are we in the same list?
	2E8A A7             AND A
	2E8B 28 2F          JR Z,CSAT_7									 		If not, give up.
	2E8D CD 9F 2E       CALL GetCharObjIX 									Is the character sitting on us?
	2E90 DD 7E 07       LD A,(IX+O_Z)
	2E93 D9             EXX
	2E94 B9             CP C
	2E95 20 0F          JR NZ,CSAT_5										If no, go to CSAT_5
	2E97 D9             EXX
	2E98 CD C3 2E       CALL CheckWeOverlap
	2E9B 30 1F          JR NC,CSAT_7										Nothing on top
	2E9D 18 BE          JR CSAT_2											Thing is on top.

.GetCharObjIX:
	2E9F CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	2EA2 E5             PUSH HL
	2EA3 DD E1          POP IX
	2EA5 C9             RET

CSAT_5:
	2EA6 B8             CP B
	2EA7 D9             EXX
	2EA8 20 12          JR NZ,CSAT_7										Nothing on top case
	2EAA 3A 62 2C       LD A,(ObjContact)
	2EAD A7             AND A
	2EAE 20 0C          JR NZ,CSAT_7										Nothing on top case.
	2EB0 CD 9F 2E       CALL GetCharObjIX
	2EB3 CD C3 2E       CALL CheckWeOverlap
	2EB6 30 04          JR NC,CSAT_7
	2EB8 3E FF          LD A,FF
	2EBA 18 03          JR CSAT_8

CSAT_7:
	2EBC 3A 62 2C       LD A,(ObjContact)
CSAT_8:
	2EBF A7             AND A												Rather than setting ObjContact, we return it?
	2EC0 C8             RET Z
	2EC1 37             SCF
	2EC2 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Takes object point in IX and checks to see if we overlap with it.
;; Assumes our extents are in DE',HL'.
.CheckWeOverlap:
	2EC3 CD D6 2E       CALL GetUVExt
;; Assuming X and Y extents in DE,HL and DE',HL', check two boundaries overlap.
;; Sets carry flag if they do.
.CheckOverlap:
    ;; Check E < D' and E' < D
	2EC6 7B             LD A,E
	2EC7 D9             EXX
	2EC8 BA             CP D
	2EC9 7B             LD A,E
	2ECA D9             EXX
	2ECB D0             RET NC
	2ECC BA             CP D
	2ECD D0             RET NC
	; Check L < H' and L' < H
	2ECE 7D             LD A,L
	2ECF D9             EXX
	2ED0 BC             CP H
	2ED1 7D             LD A,L
	2ED2 D9             EXX
	2ED3 D0             RET NC
	2ED4 BC             CP H
	2ED5 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Given an object in IX, returns its U and V extents.
;; Very like GetUVZExtents... but different?!
;;
;; D = high U, E = low U
;; H = high V, L = low V
;;
;; Values are based on the bottom 2 flag bits
;; Flag   U      V
;; 0     0 -6  +0 -6
;; 1    +0 -8  +0 -8
;; 2    +4 -4  +1 -1
;; 3    +1 -1  +4 -4
.GetUVExt:
    ;; Check bit 1 of object Dimensions.
	2ED6 DD 7E 04       LD A,(IX+O_FLAGS)
	2ED9 CB 4F          BIT 1,A
	2EDB 20 16          JR NZ,Sub_GetUV_Ext
	;; Bit was reset: Case 0/1
    ;; C = 3 + bottom bit of object Dimensions
	2EDD 1F             RRA
	2EDE 3E 03          LD A,03
	2EE0 CE 00          ADC A,00
	2EE2 4F             LD C,A
	;; D = U coord, E = U coord - 2 * C
	2EE3 DD 86 05       ADD A,(IX+O_U)
	2EE6 57             LD D,A
	2EE7 91             SUB C
	2EE8 91             SUB C
	2EE9 5F             LD E,A
	;; H = V coord, L = V coord - 2 * C
	2EEA 79             LD A,C
	2EEB DD 86 06       ADD A,(IX+O_V)
	2EEE 67             LD H,A
	2EEF 91             SUB C
	2EF0 91             SUB C
	2EF1 6F             LD L,A
	2EF2 C9             RET

;; -----------------------------------------------------------------------------------------------------------
Sub_GetUV_Ext:
    ;; Jump if bottom bit set.
	2EF3 1F             RRA
	2EF4 38 10          JR C,Sub_GetUV_Ext_2
    ;; Case 2
    ;; D = U coord + 4, E = U coord - 4
	2EF6 DD 7E 05       LD A,(IX+O_U)
	2EF9 C6 04          ADD A,04
	2EFB 57             LD D,A
	2EFC D6 08          SUB 08
	2EFE 5F             LD E,A
	;; L = V coord - 1, H = V coord + 1
	2EFF DD 6E 06       LD L,(IX+O_V)
	2F02 65             LD H,L
	2F03 24             INC H
	2F04 2D             DEC L
	2F05 C9             RET

Sub_GetUV_Ext_2:
    ;; Case 3
    ;; H = V coord + 4, L = V coord - 4
	2F06 DD 7E 06       LD A,(IX+O_V)
	2F09 C6 04          ADD A,04
	2F0B 67             LD H,A
	2F0C D6 08          SUB 08
	2F0E 6F             LD L,A
	;; D = U coord + 1, E = U coord - 1
	2F0F DD 5E 05       LD E,(IX+O_U)
	2F12 53             LD D,E
	2F13 14             INC D
	2F14 1D             DEC E
	2F15 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Menu global variables (cursor position)
MenuCursor:
	2F16 DATAWORD 00 00     												; Variable : Location of the menu cursor pointer (row,col)

;; -----------------------------------------------------------------------------------------------------------
;; Defines the sprites ID and position to be used on some of the pages:
;;	* Main Menu page (only the first two entries are used (Head and Heels)).
;;  * The Emperor proclamation page (all 4, (Head, Heels and 2 crowns) are used).
.EmperorPageSpriteList:
.MainMenuSpriteList:
	2F18 DATABYTE 1E 60 60		     										; Sprite_Head_1; pos x,y #60,#60
	2F1B DATABYTE 98 8C 60													; Sprite_Heels_1 | Sprite_Flipped; pos x,y
	2F1E DATABYTE 2F 60 48													; Sprite_Crown; pos x,y
	2F21 DATABYTE AF 8C 48													; Sprite_Crown | Sprite_Flipped; pos x,y

;; -----------------------------------------------------------------------------------------------------------
;; This is the Main Menu
;; Return with Carry set if new game or with Carry reset for "Continue"
.Main_Screen:
	2F24 3E 99          LD A,99												; String ID #99 is the GameOver title screen Id
	2F26 CD C2 4A       CALL Print_String
	2F29 DD 21 62 2F    LD IX,Main_menu_data								; IX points on first data in Main_menu_data
	2F2D DD 36 00 00    LD (IX+MENU_CURR_SEL),00							; Current selected item in menu : the first one
	2F31 CD 5A 2F       CALL Blit_Head_Heels_on_menu      					; Draw Head and Heels sprites
	2F34 CD BC 30       CALL Draw_Menu
fms_1:
	2F37 CD 97 44       CALL Random_gen										; Shuffle the Random Gen
	2F3A CD 9F 30       CALL Step_Menu										; Wait for a new selected menu item
	2F3D 38 F8          JR C,fms_1											; loop until we moved to next menu item
	2F3F DD 7E 00       LD A,(IX+MENU_CURR_SEL)								; get currently selected item in menu
	2F42 FE 01          CP 01												; Compare with 1
	2F44 DA F6 2F       JP C,Play_Game_menu									; if A < 1 then go to Play_Game_menu which will RET
	2F47 20 05          JR NZ,fms_2											; else if A > 1 go fms_2 (Sound or Sensitivity), else:
	2F49 CD 8B 2F       CALL Control_menu									; A == 1 so call Control_menu
	2F4C 18 D6          JR Main_Screen										; loop
fms_2:
	2F4E FE 03          CP 03												; test current selection with the value 3
	2F50 21 24 2F       LD HL,Main_Screen									; put Main_Screen address ...
	2F53 E5             PUSH HL												; ... on stack so that the next RET in the jump below returns to Main_Screen
	2F54 CA DA 2F       JP Z,Sensitivity_Menu								; if A == 3 then Sensitivity_Menu ; will RET
	2F57 C3 67 2F       JP Sound_Menu										; else Sound_Menu ; will RET

;; -----------------------------------------------------------------------------------------------------------
;; This will blit Head and Heels sprites on the Main Menu page.
.Blit_Head_Heels_on_menu:
	2F5A 1E 03          LD E,03												; bit mask for 1st (bit0) and 2nd (bit1) in the list, in other words draw them both
	2F5C 21 18 2F       LD HL,MainMenuSpriteList							; Sprite list to use (Head and Heels)
	2F5F C3 AF 45       JP Draw_sprites_from_list							; call Draw_sprites_from_list (3x24); will RET

;; -----------------------------------------------------------------------------------------------------------
;; Data for the Menu "Main"
;; This is the "Play/Controls/sound/Sensitivity" menu
.Main_menu_data:
	2F62 DATABYTE 00     													; MENU_CURR_SEL : Which_selected in menu ; 0 = first
	2F63 DATABYTE 04    													; MENU_NB_ITEMS : Number of items
	2F64 DATABYTE 05    													; MENU_INIT_COL : Initial column
	2F65 DATABYTE 89    													; MENU_INIT_ROW : Initial row
	2F66 DATABYTE 9A														; MENU_SEL_STRINGID : Selected item; default: String ID STR_PLAY_THE_GAME

;; -----------------------------------------------------------------------------------------------------------
;; This handle the Sound Menu
.Sound_Menu:
	2F67 3E A9          LD A,A9												; String ID #A9 is the Sound Menu
	2F69 CD C2 4A       CALL Print_String
	2F6C DD 21 86 2F    LD IX,Sound_menu_data								; IX points on Sound_menu_data
	2F70 CD BC 30       CALL Draw_Menu
smstp_1:
	2F73 CD 9F 30       CALL Step_Menu										; Wait for a new selected menu item
	2F76 38 FB          JR C,smstp_1										; if selection moved then:
	2F78 3A 86 2F       LD A,(Sound_menu_data)								; get current selected menu item from Sound_menu_data
	2F7B FE 02          CP 02												; compare with value 2
	2F7D 21 54 10       LD HL,Sound_channels_enable							; HL points on Sound_channels_enable
	2F80 CB FE          SET 7,(HL)											; set bit7 of the Sound volume/amount
	2F82 C0             RET NZ												; if sound menu item was not the 3rd one, then RET
	2F83 CB BE          RES 7,(HL)											; else ("PARDON" option selected), reset bit7 of the Sound volume/amount (kills sounds)
	2F85 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Data for the Menu "Sound"
.Sound_menu_data:
	2F86 DATABYTE 00     													; MENU_CURR_SEL : Which_selected_in_menu ; 0 = first
	2F87 DATABYTE 03    													; MENU_NB_ITEMS : Number of items
	2F88 DATABYTE 07    													; MENU_INIT_COL : Initial column
	2F89 DATABYTE 08    													; MENU_INIT_ROW : Initial row
	2F8A DATABYTE 96														; MENU_SEL_STRINGID : Current Selected item; default String ID STR_LOTS

;; -----------------------------------------------------------------------------------------------------------
;; Handle the Controls Menu
.Control_menu:
	2F8B 3E A6          LD A,A6												; String for the first selected item
	2F8D CD C2 4A       CALL Print_String
	2F90 DD 21 D5 2F    LD IX,Control_menu_data							    ; IX points on Control_menu_data
	2F94 CD BC 30       CALL Draw_Menu
	2F97 06 08          LD B,08												; 8 times
ctrlme_loop:
	2F99 C5             PUSH BC
	2F9A 78             LD A,B
	2F9B 3D             DEC A
	2F9C CD 7E 30       CALL PrepCtrlEdit									; Edit Controls
	2F9F C1             POP BC
	2FA0 C5             PUSH BC
	2FA1 78             LD A,B
	2FA2 3D             DEC A
	2FA3 CD 56 0A       CALL ListControls									; Display list of current Controls
	2FA6 C1             POP BC
	2FA7 10 F0          DJNZ ctrlme_loop
cmloop:
	2FA9 CD 94 30       CALL Menu_step_Control_Edit
	2FAC 38 FB          JR C,cmloop											; Wait that a control is selected
	2FAE C0             RET NZ
	2FAF 3E A8          LD A,A8												; String ID #A8
	2FB1 CD C2 4A       CALL Print_String
	2FB4 DD 7E 00       LD A,(IX+MENU_CURR_SEL)								; get selected item
	2FB7 DD 86 04       ADD A,(IX+MENU_SEL_STRINGID)						; update the String ID with the Base value
	2FBA CD C2 4A       CALL Print_String
	2FBD 3E 02          LD A,02												; Blank end fo line
	2FBF CD C2 4A       CALL Print_String
	2FC2 DD 7E 00       LD A,(IX+MENU_CURR_SEL)								; get selected item
	2FC5 CD 7E 30       CALL PrepCtrlEdit
	2FC8 DD 7E 00       LD A,(IX+MENU_CURR_SEL)								; get selected item
	2FCB CD 85 0A       CALL Edit_control
	2FCE 3E A7          LD A,A7												; String ID #A7 "PRESS SHIFT TO FINISH"
	2FD0 CD C2 4A       CALL Print_String
	2FD3 18 D4          JR cmloop

;; -----------------------------------------------------------------------------------------------------------
;; Data for the Menu "Controls"
.Control_menu_data:
	2FD5 DATABYTE 00     													; MENU_CURR_SEL : Which_selected in menu ; 0 = first
	2FD6 DATABYTE 08    													; MENU_NB_ITEMS : Number of items
	2FD7 DATABYTE 00    													; MENU_INIT_COL : Initial column
	2FD8 DATABYTE 85    													; MENU_INIT_ROW : Initial row (05|80)
	2FD9 DATABYTE 8E														; MENU_SEL_STRINGID : Selected item String ID

;; -----------------------------------------------------------------------------------------------------------
;; Handle the Sensitivity Menu
.Sensitivity_Menu:
	2FDA 3E AA          LD A,AA												; String ID #AA of first selected item
	2FDC CD C2 4A       CALL Print_String
	2FDF DD 21 F1 2F    LD IX,Sensitivity_menu_data							; IX points on Sensitivity_menu_data
	2FE3 CD BC 30       CALL Draw_Menu
sensmenu_1
	2FE6 CD 9F 30       CALL Step_Menu										; Wait for a new selected menu item
	2FE9 38 FB          JR C,sensmenu_1										; When a new item selected do:
	2FEB DD 7E 00       LD A,(IX+MENU_CURR_SEL)								; get selected menu item (0 = High, 1 = Low)
	2FEE C3 05 02       JP Sub_Update_Sensitivity							; jump Sub_Update_Sensitivity on will RET

;; -----------------------------------------------------------------------------------------------------------
;; Data for the Menu "Sensitivity"
.Sensitivity_menu_data:
	2FF1 DATABYTE 01     													; MENU_CURR_SEL : Which_selected in menu ; 0 = first
	2FF2 DATABYTE 02    													; MENU_NB_ITEMS : Number of items
	2FF3 DATABYTE 05    													; MENU_INIT_COL : Initial column
	2FF4 DATABYTE 09    													; MENU_INIT_ROW : Initial row
	2FF5 DATABYTE 9E														; MENU_SEL_STRINGID : Selected item String ID

;; -----------------------------------------------------------------------------------------------------------
;; Menu "Old game/New game/Main menu"; only available if we consumed
;; a living fish in a previous game. (RET if Save_point_value = 0)
;; Output: Z reset: No saved game (go to new Game)
;;         Z set and C reset : Play Old game (saved game)
;;         Z set and C set : Play New game (even though a save exists)
.Play_Game_menu:
	2FF6 3A 94 41       LD A,(Save_point_value)								; Get the "Fish" value (current Save point)
	2FF9 FE 01          CP 01												; compare with 1
	2FFB D8             RET C												; If A=0, then we do not have an old game to reload, hence no need to display this menu, can go straight to a new game, RET C and NZ
	2FFC 3E AB          LD A,AB												; else draw menu, String ID #AB is the PLAY saved point game menu
	2FFE CD C2 4A       CALL Print_String
	3001 DD 21 1B 30    LD IX,Play_Game_menu_data							; IX = pointer on Play_Game_menu_data
	3005 DD 36 00 00    LD (IX+MENU_CURR_SEL),00							; set current selected item to the first
	3009 CD BC 30       CALL Draw_menu
pgmen_1:
	300C CD 9F 30       CALL Step_menu										; Wait for a new selected menu item
	300F 38 FB          JR C,pgmen_1										; when a new item has been selected:
	3011 DD 7E 00       LD A,(IX+MENU_CURR_SEL)								; get current selected item
	3014 FE 02          CP 02												; If selected 3rd item, then...
	3016 CA 24 2F       JP Z,Main_Screen	 								; ...return to main menu
	3019 1F             RRA													; else bit0 of (0=old or 1=new) is put in Carry, Z set.
	301A C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Data for the Menu "Play" (only shown if a previous game has been saved = "Fish")
.Play_Game_menu_data:
	301B DATABYTE 00     													; MENU_CURR_SEL : Which_selected in menu ; 0 = first
	301C DATABYTE 03    													; MENU_NB_ITEMS : Number of items
	301D DATABYTE 09    													; MENU_INIT_COL : Initial column
	301E DATABYTE 09    													; MENU_INIT_ROW : Initial row
	301F DATABYTE A0														; MENU_SEL_STRINGID : Selected item ; default String ID (#A0 = "OLD GAME")

;; -----------------------------------------------------------------------------------------------------------
;; Game over Screen
;; Note on the score: After GetScore it is saved in HL as a BCD value without the
;; rightmost 0 (ie. score/10):
;;   value:    0 to  999 = Dummy, index 0 (score 0 to 9990)
;;   value: 1000 to 2999 = Novice, index 1 (score 10000 to 29990)
;;   value: 3000 to 4999 = Spy, index 2 (score 30000 to 49990)
;;   value: 5000 to 6999 = Master Spy, index 3 (score 50000 to 69990)
;;   value: 7000 to 8999 = Hero, index 4 (score 70000 to 89990)
;;   value: 9000 and above = Emperor, index 5 (score 90000 and above)
;; Independently of the score, we are Emperor if all 5 crowns have been picked up.
.Game_over_screen:
	3020 CD A5 0B       CALL Play_HoH_Tune									; Play main tune
	3023 CD 65 08       CALL Draw_wipe_and_Clear_Screen						; do the Wipe effect to clear the screen
	3026 3E BA          LD A,BA												; Draw the Title
	3028 CD C2 4A       CALL Print_String
	302B CD 5A 2F       CALL Blit_Head_Heels_on_menu						; Draw Head and Heels sprites
	302E CD CF 43       CALL GetScore										; get the score (in HL BCD value, without the last 0 (score/10))
	3031 E5             PUSH HL												; save score on stack
	3032 3A EA 3D       LD A,(saved_World_Mask)								; get saved_World_Mask
	3035 F6 E0          OR E0												; force higher bits of ~$1F
	3037 3C             INC A												; if all 5 world are saved, this would make A=0
	3038 3E C4          LD A,C4												; prepare string STR_EMPEROR
	303A 28 0D          JR Z,goverscr_2										; if Z set then all worlds saved, jump goverscr_2
	303C 7C             LD A,H												; get high byte of score ; A = int(score / 256)
	303D C6 10          ADD A,10											; Add 16 (ou Add BCD 10)
	303F 30 01          JR NC,goverscr_1									; if no overflow keep that new value
	3041 7C             LD A,H												; else take back the real value
goverscr_1:
	3042 07             RLCA												; these 4 lines (with the +#10)...
	3043 07             RLCA												; ...convert the score high byte
	3044 07             RLCA												; ...to a index value 0 to 5
	3045 E6 07          AND 07												; 0:Dummy, 1:Novice, 2:Spy, 3:Master, 4:Hero or 5:Emperor
	3047 C6 BF          ADD A,BF											; Get String for the rank
goverscr_2:
	3049 CD C2 4A       CALL Print_String									; print rank, double size, rainbow mode
	304C 3E BB          LD A,BB												; String "EXPLORED"
	304E CD C2 4A       CALL Print_String
	3051 CD 9E 43       CALL RoomCount										; get number of visited rooms
	3054 CD B3 4B       CALL Print_4Digits_LeftAligned						; and (value in DE) print it
	3057 3E BC          LD A,BC												; String "ROOMS" and "SCORE"
	3059 CD C2 4A       CALL Print_String
	305C D1             POP DE												; get back score from stack
	305D CD B3 4B       CALL Print_4Digits_LeftAligned						; print BCD score value in DE (in fact score/10 ; the final 0 will be hard coded in the string below)
	3060 3E BD          LD A,BD												; String "0|LIBERATED"
	3062 CD C2 4A       CALL Print_String
	3065 CD 99 43       CALL SavedWorldCount								; count number of saved worlds
	3068 7B             LD A,E												; get number from E
	3069 CD C4 4B       CALL Print_2Digits_LeftAligned						; print value in A (left aligned)
	306C 3E BE          LD A,BE												; String "PLANETS
	306E CD C2 4A       CALL Print_String
goverscr_3
	3071 CD A5 0B       CALL Play_HoH_Tune									; Play main Theme
	3074 CD 3C 0A       CALL Test_Enter_Shift_keys							; wait key press : Carry=1 (no key pressed), else Carry=0
	3077 38 F8          JR C,goverscr_3										; when a key was pressed:
	3079 06 C0          LD B,C0												; Sound ID #C0 Silence
	307B C3 91 0D       JP Play_Sound										; will RET

;; -----------------------------------------------------------------------------------------------------------
;; Clear out the screen area and move the cursor for editing a
;; keyboard control setting
.PrepCtrlEdit:
	307E 87             ADD A,A
	307F DD 86 03       ADD A,(IX+MENU_INIT_ROW)
	3082 E6 7F          AND 7F
	3084 47             LD B,A
	3085 0E 0B          LD C,0B
	3087 C5             PUSH BC
	3088 CD 7C 4B       CALL Set_Cursor_position
	308B 3E 02          LD A,02												; blank the end of line
	308D CD C2 4A       CALL Print_String
	3090 C1             POP BC
	3091 C3 7C 4B       JP Set_Cursor_position 								; will have a RET

;; -----------------------------------------------------------------------------------------------------------
.Menu_step_Control_Edit:
	3094 CD 3C 0A       CALL Test_Enter_Shift_keys							; output : Carry=1 : no key pressed, else Carry=0 and C=0:Enter, C=1:Shift, C=2:other
	3097 D8             RET C
	3098 79             LD A,C
	3099 FE 01          CP 01
	309B 20 07          JR NZ,MenuStepCore									; Call if the key pressed /wasn't/ Enter
	309D A7             AND A
	309E C9             RET

;; -----------------------------------------------------------------------------------------------------------
.Step_Menu:
	309F CD 3C 0A       CALL Test_Enter_Shift_keys							; output : Carry=1 : no key pressed, else Carry=0 and C=0:Enter, C=1:Shift, C=2:other
	30A2 D8             RET C
	30A3 79             LD A,C
.MenuStepCore:
	30A4 A7             AND A
	30A5 C8             RET Z
	30A6 DD 7E 00       LD A,(IX+MENU_CURR_SEL)
	30A9 3C             INC A
	30AA DD BE 01       CP (IX+MENU_NB_ITEMS)								; if reached last then
	30AD 38 01          JR C,mstepc_1
	30AF AF             XOR A												; loop over
mstepc_1
	30B0 DD 77 00       LD (IX+MENU_CURR_SEL),A
	30B3 DD E5          PUSH IX
	30B5 06 88          LD B,88												; #88 Menu blip
	30B7 CD 91 0D       CALL Play_Sound
	30BA DD E1          POP IX
.Draw_Menu:
	30BC DD 46 03       LD B,(IX+MENU_INIT_ROW)								; B = row number
	30BF CB B8          RES 7,B												; make sure bit 7 is 0
	30C1 DD 4E 02       LD C,(IX+MENU_INIT_COL)								; C = col number
	30C4 ED 43 16 2F    LD (2F16),BC										; store current cursor position
	30C8 CD 7C 4B       CALL Set_Cursor_position
	30CB DD 46 01       LD B,(IX+MENU_NB_ITEMS)								; number of menu items
	30CE DD 4E 00       LD C,(IX+MENU_CURR_SEL)								; currently selected item
	30D1 0C             INC C
drwmen_loop:
	30D2 3E AF          LD A,AF												; STR_ARROW_NONSEL
	30D4 0D             DEC C
	30D5 C5             PUSH BC
	30D6 20 16          JR NZ,br_30EE
	30D8 DD CB 03 7E    BIT 7,(IX+MENU_INIT_ROW)
	30DC 20 09          JR NZ,br_30E7
	30DE 3E 04          LD A,04												; Text_double_size
	30E0 CD C2 4A       CALL Print_String
	30E3 3E AE          LD A,AE												; Arrows for Selected item
	30E5 18 07          JR br_30EE

br_30E7
	30E7 3E 03          LD A,03												; Text_single_size
	30E9 CD C2 4A       CALL Print_String
	30EC 3E AE          LD A,AE												; Arrows for Selected item
br_30EE
	30EE CD C2 4A       CALL Print_String
	30F1 DD 7E 01       LD A,(IX+MENU_NB_ITEMS)
	30F4 C1             POP BC
	30F5 C5             PUSH BC
	30F6 90             SUB B
	30F7 DD 86 04       ADD A,(IX+MENU_SEL_STRINGID)						; Currently selected item String
	30FA CD C2 4A       CALL Print_String
	30FD E1             POP HL
	30FE E5             PUSH HL
	30FF ED 4B 16 2F    LD BC,(2F16)										; restore current cursor position
	3103 7D             LD A,L
	3104 A7             AND A
	3105 20 07          JR NZ,br_310E
	3107 DD CB 03 7E    BIT 7,(IX+MENU_INIT_ROW)
	310B 20 01          JR NZ,br_310E
	310D 04             INC B
br_310E
	310E 04             INC B
	310F C5             PUSH BC
	3110 CD 7C 4B       CALL Set_Cursor_position
	3113 3E 03          LD A,03												; Text_single_size
	3115 CD C2 4A       CALL Print_String
	3118 DD CB 03 7E    BIT 7,(IX+MENU_INIT_ROW)
	311C 20 05          JR NZ,br_3123
	311E 3E 02          LD A,02												; String ID 02 = Clear end of line
	3120 CD C2 4A       CALL Print_String
br_3123
	3123 C1             POP BC
	3124 04             INC B
	3125 ED 43 16 2F    LD (2F16),BC										; next cursor position
	3129 CD 7C 4B       CALL Set_Cursor_position
	312C C1             POP BC
	312D 10 A3          DJNZ drwmen_loop
	312F 37             SCF
	3130 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Main Strings data
.String_Table_1:
	3131 DATABYTE FF             							; Delimiter (ID #80)
	3132 STRING 50 4C 41 59									; String "PLAY"
	3136 DATABYTE FF             							; Delimiter (ID #81)
	3137 DATABYTE 05										; String Attribute 2
	3138 DATABYTE 01										; Color_code_1
	3139 DATABYTE FF										; Delimiter (ID #82)
	313A DATABYTE 05       									; String Attribute 2
	313B DATABYTE 02             							; Color_code_2
	313C DATABYTE FF             							; Delimiter (ID #83)
	313D DATABYTE 05 										; String Attribute 2
	313E DATABYTE 03             							; Color_code_3
	313F DATABYTE FF             							; Delimiter (ID #84)
	3140 STRING 20 54 48 45 20								; String " THE "
	3145 DATABYTE FF          								; Delimiter (ID #85)
	3146 STRING 47 41 4D 45             					; String "GAME"
	314A DATABYTE FF             							; Delimiter (ID #86)
	314B STRING 53 45 4C 45 43 54             				; String "SELECT"
	3151 DATABYTE FF             							; Delimiter (ID #87)
	3152 STRING 4B 45 59                        			; String "KEY"
	3155 DATABYTE FF             							; Delimiter (ID #88)
	3156 STRING 41 4E 59 20                     			; String "ANY "
	315A DATABYTE 87										; Pointer of string ID #87 ("KEY")
	315B DATABYTE FF             							; Delimiter (ID #89)
	315C STRING 53 45 4E 53 49 54 49 56 49 54 59    		; String "SENSITIVITY"
	3167 DATABYTE FF										; Delimiter (ID #8A)
	3168 DATABYTE 82										; Pointer on item ID #82
	3169 STRING 50 52 45 53 53 20							; String "PRESS "
	316F DATABYTE FF 										; Delimiter (ID #8B)
    3170 DATABYTE 82										; Pointer on item ID #82
	3171 STRING 20 54 4F 20									; String " TO "
	3175 DATABYTE FF          								; Delimiter (ID #8C)
	3176 DATABYTE 83             							; Pointer on item ID #83
	3177 DATABYTE E0             							; Pointer of string ID #E0 ("RETURN")
	3178 DATABYTE FF  										; Delimiter (ID #8D)
	3179 DATABYTE 83										; Pointer on item ID #83
	317A STRING 53 48 49 46 54             	    			; String "SHIFT"
	317F DATABYTE FF             							; Delimiter (ID #8E)
	3180 STRING 4C 45 46 54             					; String "LEFT"
	3184 DATABYTE FF             							; Delimiter (ID #8F)
	3185 STRING 52 49 47 48 54             					; String "RIGHT"
	318A DATABYTE FF             							; Delimiter (ID #90)
	318B STRING 44 4F 57 4E             					; String "DOWN"
	318F DATABYTE FF             							; Delimiter (ID #91)
	3190 STRING 55 50             							; String "UP"
	3192 DATABYTE FF             							; Delimiter (ID #92)
	3193 STRING 4A 55 4D 50             					; String "JUMP"
	3197 DATABYTE FF             							; Delimiter (ID #93)
	3198 STRING 43 41 52 52 59             					; String "CARRY"
	319D DATABYTE FF             							; Delimiter (ID #94)
	319E STRING 46 49 52 45             					; String "FIRE"
	31A2 DATABYTE FF             							; Delimiter (ID #95)
	31A3 STRING 53 57 4F 50             					; String "SWOP"    ; Note: it is "SWOP" not "SWAP"!
	31A7 DATABYTE FF             							; Delimiter (ID #96)
	31A8 STRING 4C 4F 54 53 20 4F 46 20 49 54   			; String "LOTS OF IT"
	31B2 DATABYTE FF             							; Delimiter (ID #97)
	31B3 STRING 4E 4F 54 20 53 4F 20 4D 55 43 48    		; String "NOT SO MUCH"
	31BE DATABYTE FF             							; Delimiter (ID #98)
	31BF STRING 50 41 52 44 4F 4E             				; String "PARDON"
	31C5 DATABYTE FF             							; Delimiter (ID #99)
	31C6 DATABYTE 00             							; Screen_Wipe_Code
	31C7 DATABYTE C5             							; Title_Screen_Code
	31C8 DATABYTE A3             							; String Code "Presd...."
	31C9 DATABYTE FF             							; Delimiter (ID #9A)
	31CA DATABYTE 80             							; Pointer on the ID #80 string ("PLAY")
	31CB DATABYTE 84             							; Pointer on the ID #84 string (" THE ")
	31CC DATABYTE 85             							; Pointer on the ID #85 string ("GAME")
	31CD DATABYTE FF             							; Delimiter (ID #9B)
	31CE DATABYTE 86             							; Pointer on the ID #86 string ("SELECT")
	31CF DATABYTE 84             							; Pointer on the ID #84 string (" THE ")
	31D0 DATABYTE 87             							; Pointer on the ID #87 string ("KEY")
	31D1 STRING 53             								; String "S"
	31D2 DATABYTE FF             							; Delimiter (ID #9C)
	31D3 STRING 41 44 4A 55 53 54     						; String "ADJUST"
	31D9 DATABYTE 84										; Pointer on the ID #84 string (" THE ")
	31DA STRING 53 4F 55 4E 44     							; String "SOUND"
	31DF DATABYTE FF             							; Delimiter (ID #9D)
	31E0 STRING 43 4F 4E 54 52 4F 4C 20          			; String "CONTROL "
	31E8 DATABYTE 89										; Pointer on the ID #89 string ("SENSITIVITY")
	31E9 DATABYTE FF             							; Delimiter (ID #9E)
	31EA STRING 48 49 47 48 20          					; String "HIGH "
	31EF DATABYTE 89										; Pointer on the ID #89 string ("SENSITIVITY")
	31F0 DATABYTE FF             							; Delimiter (ID #9F)
	31F1 STRING 4C 4F 57 20          						; String "LOW "
	31F5 DATABYTE 89										; Pointer on the ID #89 string ("SENSITIVITY")
	31F6 DATABYTE FF             							; Delimiter (ID #A0)
	31F7 STRING 4F 4C 44 20          						; String "OLD "
	31FB DATABYTE 85										; Pointer on the ID #85 string ("GAME")
	31FC DATABYTE FF             							; Delimiter (ID #A1)
	31FD STRING 4E 45 57 20          						; String "NEW "
	3201 DATABYTE 85										; Pointer on the ID #85 string ("GAME")
	3202 DATABYTE FF             							; Delimiter (ID #A2)
	3203 STRING 4D 41 49 4E 20 4D 45 4E 55          		; String "MAIN MENU"
	320C DATABYTE FF             							; Delimiter (ID #A3)
	320D DATABYTE B9             							; Pointer on item ID #B9
	320E DATABYTE 02										; Text_col
	320F DATABYTE 15             							; Text_row
	3210 DATABYTE 8A             							; Pointer on the ID #8A string ("|PRESS")
	3211 DATABYTE 83             							; Pointer on item ID #83
	3212 DATABYTE 88             							; Pointer on the ID #88 string ("ANY " + "KEY")
	3213 DATABYTE 8B             							; Pointer on the ID #8B string (" TO ")
	3214 STRING 4D 4F 56 45 20 43 55 52 53 4F 52    		; String "MOVE CURSOR"
	321F DATABYTE 06										; Set_Text_Position
	3220 DATABYTE 01          								; Text_col
	3221 DATABYTE 17             							; Text_row
	3222 STRING 20											; String " "
	3223 DATABYTE 8A             							; Pointer on the ID #8A string ("|PRESS")
	3224 DATABYTE 8C             							; Pointer on the ID #8C string ("|RETURN")
	3225 DATABYTE 8B             							; Pointer on the ID #8B string (" TO ")
	3226 DATABYTE 86             							; Pointer on the ID #86 string ("SELECT")
	3227 STRING 20 4F 50 54 49 4F 4E						; String " OPTION"
	322E DATABYTE 02             							; Ctrl_Blanks ??
	322F DATABYTE FF             							; Delimiter (ID #A4)
	3230 DATABYTE 06										; Set_Text_Position
	3231 DATABYTE 05         								; Text_col
	3232 DATABYTE 03         								; Text_row
	3233 DATABYTE 8A             							; Pointer on the ID #8A string ("|PRESS")
	3234 DATABYTE 8D             							; Pointer on the ID #8D string ("|SHIFT")
	3235 DATABYTE 8B             							; Pointer on the ID #8B string (" TO ")
	3236 DATABYTE C8             							; Pointer on the ID #C8 string ("FINISH")
	3237 DATABYTE 02             							; Ctrl_Blanks ??
	3238 DATABYTE FF             							; Delimiter (ID #A5)
	3239 DATABYTE 06										; Set_Text_Position
	323A DATABYTE 05         								; Text_col
	323B DATABYTE 03         								; Text_row
	323C DATABYTE 8A             							; Pointer on the ID #8A string ("|PRESS")
	323D DATABYTE 8C             							; Pointer on the ID #8C string ("|RETURN")
	323E DATABYTE 8B             							; Pointer on the ID #8B string (" TO ")
	323F DATABYTE C8             							; Pointer on the ID #C8 string ("FINISH")
	3240 DATABYTE 02             							; Ctrl_Blanks ??
	3241 DATABYTE FF             							; Delimiter (ID #A6)
	3242 DATABYTE B0										; Pointer on the ID #B0
	3243 DATABYTE 08										; Text_col
	3244 DATABYTE 00										; Text_row
	3245 DATABYTE 81             							; Pointer on the ID #81
	3246 DATABYTE 9B             							; Pointer on the ID #8C string ("SELECT THE KEYS")
	3247 DATABYTE A3             							; Pointer on the ID #A7
	3248 DATABYTE FF             							; Delimiter (ID #A7)
	3249 DATABYTE A3             							; Pointer on the ID #A3
	324A DATABYTE 06										; Set_Text_Position
	324B DATABYTE 05         								; Text_col
	324C DATABYTE 03         								; Text_row
	324D DATABYTE 8A             							; Pointer on the ID #8A string ("|PRESS")
	324E DATABYTE 81             							; Pointer on the ID #81
	324F DATABYTE 8D             							; Pointer on the ID #8D string ("|SHIFT")
	3250 DATABYTE 8B             							; Pointer on the ID #8B string (" TO ")
	3251 DATABYTE C8             							; Pointer on the ID #C8 string ("FINISH")
	3252 DATABYTE 02             							; Ctrl_Blanks ??
	3253 DATABYTE FF             							; Delimiter (ID #A8)
	3254 DATABYTE 06										; Set_Text_Position
	3255 DATABYTE 05         								; Text_col
	3256 DATABYTE 03         								; Text_row
	3257 DATABYTE 02             							; Ctrl_Blanks ??
	3258 DATABYTE 06										; Set_Text_Position
	3259 DATABYTE 01         								; Text_col
	325A DATABYTE 15         								; Text_row
	325B DATABYTE 02             							; Ctrl_Blanks ??
	325C DATABYTE 06										; Set_Text_Position
	325D DATABYTE 01         								; Text_col
	325E DATABYTE 17         								; Text_row
	325F DATABYTE 8A             							; Pointer on the ID #8A string ("|PRESS")
	3260 DATABYTE 83             							; Pointer on item ID #83
	3261 DATABYTE 87             							; Pointer on the ID #87 string ("KEY")
	3262 STRING 53											; String "S"
	3263 DATABYTE 82             							; Pointer on item ID #82
	3264 STRING 20 52 45 51 55 49 52 45 44 20				; String " REQUIRED "
	326E STRING 46 4F 52 20									; String "FOR "
	3272 DATABYTE 83             							; Pointer on item ID #83
	3273 DATABYTE FF             							; Delimiter (ID #A9)
	3274 DATABYTE B0										; Pointer on item ID #B0
	3275 DATABYTE 08         								; Text_col
	3276 DATABYTE 00         								; Text_row
	3277 DATABYTE 82             							; Pointer on item ID #82
	3278 DATABYTE 9C             							; Pointer on the ID #9C string ("ADJUST THE SOUND")
	3279 DATABYTE A3             							; Pointer on item ID #A3
	327A DATABYTE 06										; Set_Text_Position
	327B DATABYTE 06         								; Text_col
	327C DATABYTE 03         								; Text_row
	327D DATABYTE 05             							; Color_code
	327E DATABYTE 00             							; Color_code_Rainbow
	327F STRING 4D 55 53 49 43 20 42 59 20					; String "MUSIC BY "
	3288 STRING 47 55 59 20 53 54 45 56 45 4E 53			; String "GUY STEVENS"
	3293 DATABYTE FF             							; Delimiter (ID #AA)
	3294 DATABYTE B0										; Pointer on item ID #B0
	3295 DATABYTE 06         								; Text_col
	3296 DATABYTE 00         								; Text_row
	3297 DATABYTE 82             							; Pointer on item ID #82
	3298 DATABYTE 9D             							; Pointer on item ID #9D ("CONTROL SENSITIVITY")
	3299 DATABYTE A3             							; Pointer on item ID #A3
	329A DATABYTE FF             							; Delimiter (ID #AB)
	329B DATABYTE B0										; Pointer on item ID #B0
	329C DATABYTE 09         								; Text_col
	329D DATABYTE 00         								; Text_row
	329E DATABYTE 82             							; Pointer on item ID #82
	329F DATABYTE 9A             							; Pointer on item ID #9A ("PLAY THE GAME")
	32A0 DATABYTE A3             							; Pointer on item ID #A3
String_ID_Paused: ;;		EQU	AC
	32A1 DATABYTE FF             							; Delimiter (ID #AC = Paused Game message)
	32A2 DATABYTE 04             							; Text_double_size
	32A3 DATABYTE 82              							; Pointer on item ID #82
	32A4 DATABYTE 06										; Set_Text_Position
	32A5 DATABYTE 03										; Text_col
	32A6 DATABYTE 03										; Text_row
	32A7 DATABYTE 8A             							; Pointer on item ID #8A ("|PRESS")
	32A8 DATABYTE 83              							; Pointer on item ID #83
	32A9 DATABYTE 8D             							; Pointer on item ID #8A ("|SHIFT")
	32AA DATABYTE 8B             							; Pointer on the ID #8B string (" TO ")
	32AB DATABYTE C8             							; Pointer on the ID #C8 string ("FINISH")
	32AC STRING 20											; String " "
	32AD DATABYTE 85										; Pointer on the ID #85 string ("GAME")
	32AE DATABYTE 06										; Set_Text_Position
	32AF DATABYTE 04										; Text_col
	32B0 DATABYTE 06										; Text_row
	32B1 DATABYTE 8A             							; Pointer on item ID #8A ("|PRESS")
	32B2 DATABYTE 83             							; Pointer on item ID #83
	32B3 DATABYTE 88             							; Pointer on the ID #88 string ("ANY " + "KEY")
	32B4 DATABYTE 8B             							; Pointer on the ID #8B string (" TO ")
	32B5 STRING 52 45 53 54 41 52 54             			; String "RESTART"
	32BC DATABYTE FF             							; Delimiter (ID #AD) : Spaces
	32BD STRING 20 20 20									; String "   "
	32C0 DATABYTE FF             							; Delimiter (ID #AE) : Arrows for Selected item
	32C1 DATABYTE 83             							; Pointer on item ID #83
	32C2 DATABYTE 21										; Arrow1_code
	32C3 DATABYTE 22										; Arrow2_code
	32C4 DATABYTE AD             							; Pointer on item ID #AD String ("   ")
	32C5 DATABYTE FF             							; Delimiter (ID #AF) : Arrows for non-selected items
	32C6 DATABYTE 03										; Text_single_size
	32C7 DATABYTE 81             							; Pointer on item ID #81
	32C8 DATABYTE 23										; Arrow3_code
	32C9 DATABYTE 24										; Arrow4_code
	32CA DATABYTE AD             							; Pointer on item ID #AD String ("   ")
	32CB DATABYTE FF             							; Delimiter (ID #B0)
	32CC DATABYTE 00             							; Screen_Wipe_Code
	32CD DATABYTE 07             							; Select color scheme:
	32CE DATABYTE 09             							; nb 09
	32CF DATABYTE 04             							; Text_double_size
	32D0 DATABYTE 06										; Set_Text_Position
	32D1 DATABYTE FF             							; Delimiter (ID #B1)
	32D2 DATABYTE B9             							; Pointer on item ID #B9
	32D3 DATABYTE 05										; Text_col
	32D4 DATABYTE 14										; Text_row
	32D5 DATABYTE FF             							; Delimiter (ID #B2)
	32D6 DATABYTE B9             							; Pointer on item ID #B9
	32D7 DATABYTE 19										; Text_col
	32D8 DATABYTE 14										; Text_row
	32D9 DATABYTE FF             							; Delimiter (ID #B3)
	32DA DATABYTE B9             							; Pointer on item ID #B9
	32DB DATABYTE 19										; Text_col
	32DC DATABYTE 17										; Text_row
	32DD DATABYTE FF             							; Delimiter (ID #B4)
	32DE DATABYTE B9             							; Pointer on item ID #B9
	32DF DATABYTE 05										; Text_col
	32E0 DATABYTE 17										; Text_row
	32E1 DATABYTE FF             							; Delimiter (ID #B5)
	32E2 DATABYTE 04             							; Text_double_size
	32E3 DATABYTE 06										; Set_Text_Position
	32E4 DATABYTE 12          								; Text_col
	32E5 DATABYTE 16										; Text_row
	32E6 DATABYTE FF             							; Delimiter (ID #B6)
	32E7 DATABYTE 04             							; Text_double_size
	32E8 DATABYTE 06										; Set_Text_Position
	32E9 DATABYTE 0C										; Text_col
	32EA DATABYTE 16										; Text_row
	32EB DATABYTE FF             							; Delimiter (ID #B7)
	32EC DATABYTE B9             							; Pointer on item ID #B9
	32ED DATABYTE 01										; Text_col
	32EE DATABYTE 11										; Text_row
	32EF DATABYTE FF             							; Delimiter (ID #B8)
	32F0 DATABYTE 03										; Text_single_size
	32F1 DATABYTE 82             							; Pointer on item ID #82
	32F2 DATABYTE 06										; Set_Text_Position
	32F3 DATABYTE 1A										; Text_col
	32F4 DATABYTE 13										; Text_row
	32F5 DATABYTE 26										; Item_Spring_code
	32F6 DATABYTE 06										; Set_Text_Position
	32F7 DATABYTE 1A										; Text_col
	32F8 DATABYTE 16										; Text_row
	32F9 DATABYTE 82             							; Pointer on item ID #82
	32FA DATABYTE 27										; Item_Shield_code
	32FB DATABYTE 06										; Set_Text_Position
	32FC DATABYTE 06										; Text_col
	32FD DATABYTE 13										; Text_row
	32FE DATABYTE 82             							; Pointer on item ID #82
	32FF DATABYTE 25										; Item_LightningSpeed_code
	3300 DATABYTE 06										; Set_Text_Position
	3301 DATABYTE 06										; Text_col
	3302 DATABYTE 16										; Text_row
	3303 DATABYTE 82             							; Pointer on item ID #82
	3304 DATABYTE 27										; Item_Shield_code
	3305 DATABYTE FF             							; Delimiter (ID #B9)
	3306 DATABYTE 03										; Text_single_size
	3307 DATABYTE 06										; Set_Text_Position
	3308 DATABYTE FF             							; Delimiter (ID #BA)
	3309 DATABYTE C5             							; Pointer on item ID #C5 : Title_Screen_Code
	330A DATABYTE 06										; Set_Text_Position
	330B DATABYTE 0A										; Text_col
	330C DATABYTE 08										; Text_row
	330D DATABYTE 82             							; Pointer on item ID #82
	330E DATABYTE 04             							; Text_double_size
	330F DATABYTE 05										; Color_code
	3310 DATABYTE 00             							; Color_Rainbow
	3311 DATABYTE FF             							; Delimiter (ID #BB)
	3312 DATABYTE B9             							; Pointer on item ID #B9
	3313 DATABYTE 06										; Set_Text_Position
	3314 DATABYTE 11										; Text_col
	3315 DATABYTE 81										; Text_row
	3316 STRING 45 58 50 4C 4F 52 45 44 20					; String "EXPLORED "
	331F DATABYTE FF             							; Delimiter (ID #BC)
	3320 STRING 20 52 4F 4F 4D 53             				; String " ROOMS"
	3326 DATABYTE 06										; Set_Text_Position
	3327 DATABYTE 09										; Text_col
	3328 DATABYTE 0E										; Text_row
	3329 DATABYTE 82             							; Pointer on item ID #82
	332A STRING 53 43 4F 52 45 20							; String "SCORE "
	3330 DATABYTE FF             							; Delimiter (ID #BD)
	3331 STRING 30											; String "0"
	3332 DATABYTE 06										; Set_Text_Position
	3333 DATABYTE 05										; Text_col
	3334 DATABYTE 14										; Text_row
	3335 DATABYTE 83             							; Pointer on item ID #83
	3336 STRING 4C 49 42 45 52 41 54 45 44 20				; String "LIBERATED "
	3340 DATABYTE FF             							; Delimiter (ID #BE)
	3341 STRING 20 50 4C 41 4E 45 54 53             		; String " PLANETS"
	3349 DATABYTE FF             							; Delimiter (ID #BF)
	334A STRING 20 20 44 55 4D 4D 59             			; String "  DUMMY"
	3351 DATABYTE FF             							; Delimiter (ID #C0)
	3352 STRING 20 20 4E 4F 56 49 43 45             		; String "  NOVICE"
	335A DATABYTE FF             							; Delimiter (ID #C1)
	335B STRING 20 20 20 53 50 59 20 20 20 20       		; String "   SPY    "
	3365 DATABYTE FF             							; Delimiter (ID #C2)
	3366 STRING 4D 41 53 54 45 52 20 53 50 59       		; String "MASTER SPY"
	3370 DATABYTE FF             							; Delimiter (ID #C3)
	3371 STRING 20 20 20 48 45 52 4F             			; String "   HERO"
	3378 DATABYTE FF             							; Delimiter (ID #C4)
	3379 STRING 20 45 4D 50 45 52 4F 52             		; String " EMPEROR"
	3381 DATABYTE FF             							; Delimiter (ID #C5)
	3382 DATABYTE 07										; Select color scheme
	3383 DATABYTE 0A										; nb 0A
	3384 DATABYTE 04             							; Text_double_size
	3385 DATABYTE 06										; Set_Text_Position
	3386 DATABYTE 08										; Text_col
	3387 DATABYTE 00										; Text_row
	3388 DATABYTE 82             							; Pointer on item ID #82
	3389 STRING 48 45 41 44 20 20 20 20 20 20				; String "HEAD      "
	3393 STRING 48 45 45 4C 53								; String "HEELS"
	3398 DATABYTE B9             							; Pointer on item ID #B9
	3399 DATABYTE 0C										; Text_col
	339A DATABYTE 01										; Text_row
	339B DATABYTE 05										; Color_attr_code
	339C DATABYTE 00										; Color_rainbow
	339D STRING 20 4F 56 45 52 20            				; String " OVER "
	33A3 DATABYTE 06										; Set_Text_Position
	33A4 DATABYTE 01										; Text_col
	33A5 DATABYTE 00										; Text_row
	33A6 STRING 20 4A 4F 4E             					; String " JON"
	33AA DATABYTE 06										; Set_Text_Position
	33AB DATABYTE 01										; Text_col
	33AC DATABYTE 02										; Text_row
	33AD STRING 52 49 54 4D 41 4E             				; String "RITMAN"
	33B3 DATABYTE 06										; Set_Text_Position
	33B4 DATABYTE 19										; Text_col
	33B5 DATABYTE 00										; Text_row
	33B6 STRING 42 45 52 4E 49 45             				; String "BERNIE"
	33BC DATABYTE 06										; Set_Text_Position
	33BD DATABYTE 18										; Text_col
	33BE DATABYTE 02										; Text_row
	33BF STRING 44 52 55 4D 4D 4F 4E 44             		; String "DRUMMOND"
	33C7 DATABYTE FF             							; Delimiter (ID #C6)
	33C8 DATABYTE 00  			           					; Screen_Wipe_Code
	33C9 DATABYTE 07										; Select color scheme
	33CA DATABYTE 06										; nb 06
	33CB DATABYTE 06										; Set_Text_Position
	33CC DATABYTE 05										; Text_col
	33CD DATABYTE 00										; Text_row
	33CE DATABYTE 04             							; Text_double_size
	33CF DATABYTE 83             							; Pointer on item ID #83
	33D0 DATABYTE 84										; Pointer on item ID #84 : String " THE "
	33D1 DATABYTE C7             							; Pointer on item ID #C7 : String "BLACKTOOTH"
	33D2 STRING 20 45 4D 50 49 52 45						; String " EMPIRE"
	33D9 DATABYTE 03										; Text_single_size
	33DA DATABYTE 06										; Set_Text_Position
	33DB DATABYTE 03										; Text_col
	33DC DATABYTE 09										; Text_row
	33DD DATABYTE 81             							; Pointer on item ID #81
	33DE STRING 45 47 59 50 54 55 53             			; String "EGYPTUS"
	33E5 DATABYTE 06										; Set_Text_Position
	33E6 DATABYTE 15										; Text_col
	33E7 DATABYTE 17										; Text_row
	33E8 STRING 42 4F 4F 4B 20 57 4F 52 4C 44       		; String "BOOK WORLD"
	33F2 DATABYTE 06										; Set_Text_Position
	33F3 DATABYTE 03										; Text_col
	33F4 DATABYTE 17										; Text_row
	33F5 STRING 53 41 46 41 52 49             				; String "SAFARI"
	33FB DATABYTE 06										; Set_Text_Position
	33FC DATABYTE 14										; Text_col
	33FD DATABYTE 09										; Text_row
	33FE STRING 50 45 4E 49 54 45 4E 54 49 41 52 59 		; String "PENITENTIARY"
	340A DATABYTE 06										; Set_Text_Position
	340B DATABYTE 0B										; Text_col
	340C DATABYTE 10										; Text_row
	340D DATABYTE C7             							; Pointer on item ID #C7 : String "BLACKTOOTH"
	340E DATABYTE FF             							; Delimiter (ID #C7)
	340F STRING 42 4C 41 43 4B 54 4F 4F 54 48  				; String "BLACKTOOTH"
String_ID_Finish:	;; EQU C8
	3419 DATABYTE FF             							; Delimiter (ID #C8)
	341A STRING 46 49 4E 49 53 48             				; String "FINISH"
String_ID_Freedom:	;; EQU C9
	3420 DATABYTE FF             							; Delimiter (ID #C9)
	3421 DATABYTE B6										; Pointer on item ID #B6
	3422 DATABYTE 05										; Color_attr_code
	3423 DATABYTE 00             							; Color_Rainbow
	3424 STRING 46 52 45 45 44 4F 4D 20						; String "FREEDOM "
String_ID_Wipe_Salute:	;; EQU CA
	342C DATABYTE FF             							; Delimiter (ID #CA)
	342D DATABYTE 00  			           					; Screen_Wipe_Code
	342E DATABYTE 07										; Select color scheme
	342F DATABYTE 06										; nb 06
	3430 DATABYTE B9          								; Pointer on item ID #B9
	3431 DATABYTE 00										; Text_col
	3432 DATABYTE 0A             							; Text_row
	3433 DATABYTE 82             							; Pointer on item ID #82
	3434 DATABYTE 84										; Pointer on item ID #84 : String " THE "
	3435 STRING 50 45 4F 50 4C 45 20      					; String "PEOPLE "
	343C STRING 53 41 4C 55 54 45      						; String "SALUTE"
	3442 STRING 20 59 4F 55 52 20          					; String " YOUR "
	3448 STRING 48 45 52 4F 49 53 4D          				; String "HEROISM"
	344F DATABYTE 06										; Set_Text_Position
	3450 DATABYTE 08										; Text_col
	3451 DATABYTE 0C										; Text_row
	3452 STRING 41 4E 44 20									; String "AND "
	3456 STRING 50 52 4F 43 4C 41 49 4D            			; String "PROCLAIM"
	345E STRING 20 59 4F 55             					; String " YOU"
	3462 DATABYTE 04   										; Text_double_size
	3463 DATABYTE 06										; Set_Text_Position
	3464 DATABYTE 0B										; Text_col
	3465 DATABYTE 10										; Text_row
	3466 DATABYTE 05										; Color_attr_code
	3467 DATABYTE 00             							; Color_Rainbow
	3468 DATABYTE C4										; Pointer on item ID #C4 : String " EMPEROR"
	3469 DATABYTE FF             							; Delimiter (ID #CB)

;; -----------------------------------------------------------------------------------------------------------
; Swap RoomId with the room at the other end of the teleport.
.Teleport_swap_room:
	346A ED 4B 0E 01    LD BC,(current_Room_ID)  							; get current_Room_ID in BC
	346E 21 90 34       LD HL,Sprite4x28									; HL points on Teleport_data
	3471 CD 79 34       CALL Scan_teleport_pairs							; Scan_teleport_pairs, DE will have the destination room ID
	3474 ED 53 0E 01    LD (current_Room_ID),DE								; update current_Room_ID with teleport destination room ID
	3478 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Scans array from HL, looking for BC, scanning in pairs. If the
;; first is equal, it returns the second in DE. If the second is equal,
;; it returns the first.
.Scan_teleport_pairs:
    ;; match current room with teleport_data "left" room,
	;; return "right" room if match
	3479 CD 86 34       CALL get_teleport_pair_in_DE						; compare_teleport "left" room
	347C 28 08          JR Z,get_teleport_pair_in_DE						; if match, get_teleport_pair_in_DE, will RET, else (no match):
	;; match current room with teleport_data "right" room,
	;; return "left" room if match
	347E D5             PUSH DE												; store current scanned room
	347F CD 86 34       CALL get_teleport_pair_in_DE						; compare_teleport
	3482 D1             POP DE												; restore previous scanned room
	;; still no match continue searching, else DE has the destination
	3483 20 F4          JR NZ,Scan_teleport_pairs							; loop Scan_teleport_pairs if no match else found!
	3485 C9             RET													; DE has the destination room

;; Loads (HL) into DE, incrementing HL.
;; Compares BC with DE, sets Z if equal.
get_teleport_pair_in_DE:													; look for the BC room ID in the Teleport_data table at HL
	3486 79             LD A,C
	3487 5E             LD E,(HL)
	3488 23             INC HL												; next databyte
	3489 56             LD D,(HL)											; DE has the scanned room ID in the table
	348A 23             INC HL												; next databyte
	348B BB             CP E												; E = C?
	348C C0             RET NZ												; if lowbyte not what we are looking for Z=0 and exit (no need to go further)
	348D 78             LD A,B												; D = B?
	348E BA             CP D												; else compare highbyte
	348F C9             RET													; Z=1 if match, DE=destination-room, Z=0 if no match

;; -----------------------------------------------------------------------------------------------------------
;; TELEPORT pairs
;; The room ID is [grid on 8 axis][grid on V axis][grid in Z (increase going down)]
;; for exemple Head and Heels inital rooms are respectively 8,A,8 and 8,9,8 (these rooms are next to each other)
Teleport_data:
	3490 DATAWORD 40 8A 50 71				; Room ID 8A40 end up at Room ID 7150 : Head's first room (prison) to first escape room (both way)
	3494 DATAWORD 40 89 80 04				; Room ID 8940 end up at Room ID 0480 : Heels' first room (prison) to first escape room (both way)
	3498 DATAWORD 70 BA 00 13				; Room ID BA70 end up at Room ID 1300 : Market to Moonbase () and then Moonbase to Moonbase Upper ???
	349C DATAWORD 00 41 80 29				; Room ID 4100 end up at Room ID 2980 : Blacktooth to Moonbase (2 in one room) (heels only) (both way)
	34A0 DATAWORD 00 A1 00 26				; Room ID A100 end up at Room ID 2600 : Moonbase to Moonbase Main (both way)
	34A4 DATAWORD 00 81 80 E9				; Room ID 8100 end up at Room ID E980 : Blacktooth to Moonbase (head only) (both way)
	34A8 DATAWORD 00 84 00 B1				; Room ID 8400 end up at Room ID B100 : Moonbase Main to Penitentiary (both way)
	34AC DATAWORD 00 85 20 EF				; Room ID 8500 end up at Room ID EF20 : Moonbase Main to Bookworld (both way)
	34B0 DATAWORD 00 A4 F0 00				; Room ID A400 end up at Room ID 00F0 : Moonbase Main to Safari (both way)
	34B4 DATAWORD 00 A5 D0 88				; Room ID A500 end up at Room ID 88D0 : Moonbase Main to Egyptus (both way)
	34B8 DATAWORD D0 BC D0 DE				; Room ID BCD0 end up at Room ID DED0 : Egyptus mid to Egyptus early
	34BC DATAWORD B0 2D D0 8B				; Room ID 2DB0 end up at Room ID 8BD0 : Egyptus just before crown to Egyptus beginning
	34C0 DATAWORD 90 11 C0 E1				; Room ID 1190 end up at Room ID E1C0 : Penitentiary Crown room () to Penitentiary mid1
	34C4 DATAWORD B0 00 C0 E2				; Room ID 00B0 end up at Room ID E2C0 : Penitentiary Far in () to Penitentiary mid2
	34C8 DATAWORD B0 10 00 C1				; Room ID 10B0 end up at Room ID C100 : Penitentiary just before crown to Begining Penitentiary
	34CC DATAWORD F0 8B F0 00				; Room ID 8BF0 end up at Room ID 00F0 : Safari (Egyptus???) Far room to Safari begining
	34D0 DATAWORD 30 97 20 EF				; Room ID 9730 end up at Room ID EF20 : Bookworld just before crown to Bookworld beginning
	34D4 DATAWORD 00 1D 00 A8				; Room ID 1D00 end up at Room ID A800 : Moonbase Main to Moonbase Upper (both way)
	34D8 DATAWORD 70 BA 00 4E				; Room ID BA70 end up at Room ID 4E00 : Moonbase Upper to Market (both way)
	34DC DATAWORD 00 88 30 1B				; Room ID 8800 end up at Room ID 1B30 : Moonbase Main to Castle (both way)
	34E0 DATAWORD 00 4C 30 39				; Room ID 4C00 end up at Room ID 3930 : Moonbase Upper to Castle (both way)
	34E4 DATAWORD 30 8B 30 8D				; Room ID 8B30 end up at Room ID 8D30 : Castle to Freedom (Victory room! 8D30 game over)

;; -----------------------------------------------------------------------------------------------------------
;; Takes sprite codes in HL and a height in A, and applies truncation
;; of the third column A * 2 + from the top of the column. This
;; performs removal of the bits of the door hidden by the walls.
;; If the door is raised, more of the frame is visible, so A is
;; the height of the door.
.OccludeDoorway:
    ;; Copy the sprite (and mask) indexed by L to DoorwayBuf
	34E8 F5             PUSH AF
	34E9 7D             LD A,L
	34EA 26 00          LD H,00
	34EC 32 38 35       LD (Sprite_Code),A									update sprite code
	34EF CD FA 35       CALL Sprite3x56
	34F2 EB             EX DE,HL
	34F3 11 C0 B9       LD DE,DoorwayBuf
	34F6 D5             PUSH DE
	34F7 01 50 01       LD BC,0150											56 * 3 * 2
	34FA ED B0          LDIR												repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	34FC E1             POP HL
	34FD F1             POP AF
	; A = Min(A * 2 + 8, 0x38)
	34FE 87             ADD A,A
	34FF C6 08          ADD A,08
	3501 FE 39          CP 39
	3503 38 02          JR C,occdw_1
	3505 3E 38          LD A,38
	; A *= 3
occdw_1:
	3507 47             LD B,A
	3508 87             ADD A,A
	3509 80             ADD A,B
	;; DE = Top of sprite + A
    ;; HL = Top of mask + A
	350A 5F             LD E,A
	350B 16 00          LD D,00
	350D 19             ADD HL,DE
	350E EB             EX DE,HL
	350F 21 A8 00       LD HL,00A8											56 * 3
	3512 19             ADD HL,DE
	3513 78             LD A,B
	3514 ED 44          NEG
	3516 C6 39          ADD A,39
	3518 47             LD B,A												; B = $39 - A
	3519 0E FC          LD C,FC												; C = ~$03
	351B 18 13          JR occdw_2

	;; This loop then cuts off a wedge from the right-hand side,
    ;; presumably to give a nice trunction of the image?
occdw_3:
	351D 1A             LD A,(DE)
	351E A1             AND C
	351F 12             LD (DE),A
	3520 13             INC DE
	3521 13             INC DE
	3522 13             INC DE
	3523 79             LD A,C
	3524 2F             CPL
	3525 B6             OR (HL)
	3526 77             LD (HL),A
	3527 23             INC HL
	3528 23             INC HL
	3529 23             INC HL
	352A A7             AND A
	352B CB 11          RL C
	352D A7             AND A
	352E CB 11          RL C
occdw_2:
	3530 10 EB          DJNZ occdw_3
	;; Clear the flipped flag for this copy.
	3532 AF             XOR A
	3533 32 ED 36       LD (DoorwayFlipped),A
	3536 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.Sprite_Width:
	3537 DATABYTE 04														width of sprite in bytes

.Sprite_Code:
	3538 DATABYTE 00             											Variable for sprite code

;; -----------------------------------------------------------------------------------------------------------
;; This will init another table in 6900-69FF used as a look-up table
;; for byte reverses (RevTable).
;; The final table is:
;;  6900 : 00 80 40 C0 20 A0 60 E0 10 90 50 D0 30 B0 70 F0
;;  6910 : 08 88 48 C8    ....                       78 F8
;;  6920 : 04 84 44 C4    ....                       74 F4
;;  ...    ...            ....                       ...
;;  69E0 : 07 87 47 C7    ....                       77 F7
;;  69F0 : 0F 8F 4F CF 2F AF 6F EF 1F 9F 5F DF 3F BF 7F FF
.Init_table_rev:
	3539 21 00 69       LD HL,6900											; RevTable addr
table2_next_idx:
	353C 4D             LD C,L												; C = current table index (L = 0 to 255)
	353D 3E 01          LD A,01												; A=1
	353F A7             AND A												; Clear Carry
table2_decomp:
	3540 1F             RRA													; bit shifting between A...
	3541 CB 11          RL C												; ...and C (via Carry)
	3543 20 FB          JR NZ,table2_decomp									; C not 0, loop
	3545 77             LD (HL),A											; else write resulting A in current HL
	3546 2C             INC L												; next HL
	3547 20 F3          JR NZ,table2_next_idx								; loop until L goes back to 0
	3549 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; For a given sprite code, generates the X and Y extents, and sets
;; the current sprite code and sprite width.
;;
;; Parameters: Sprite code is passed in in A.
;;             X coordinate in C, Y coordinate in B
;; Returns: X extent in BC, Y extent in HL
.GetSprExtents:
	354A 32 38 35       LD (Sprite_Code),A									update sprite code
	354D E6 7F          AND 7F
	354F FE 10          CP 10
	3551 38 34          JR C,Case3x56										; Codes < $10 are 3x56 so go Case3x56, else:
	3553 11 06 06       LD DE,0606											; 3x24 or 3x32 (3x32 will be modified)
	3556 26 12          LD H,12
	3558 FE 54          CP 54
	355A 38 05          JR C,gsext_1
	355C 11 08 08       LD DE,0808					 						; Codes >= $54 are 4x28
	355F 26 14          LD H,14
gsext_1:
	3561 FE 18          CP 18
	3563 30 0F          JR NC,SSW_2
	3565 3A A2 1C       LD A,(SpriteFlags)
	3568 E6 02          AND 02
	356A 16 04          LD D,04
	356C 26 0C          LD H,0C
	356E 28 04          JR Z,SSW_2
	3570 16 00          LD D,00
	3572 26 10          LD H,10
    ;; All cases but 3x56 join up here:
    ;; D is Y extent down, H is Y extent up
    ;; E is half-width (in double-pixels)
    ;;
    ;; 4x28: D = 8, E = 8, H = 20
    ;; 3x24: D = 6, E = 6, H = 18
    ;; 3x32: D = 0, E = 6, H = 16 if flags & 2
    ;; 3x32: D = 4, E = 6, H = 12 otherwise
    ;;
    ;; The 3x32 case is split into 2 parts of height 16 each.
SSW_2:
	3574 78             LD A,B
	3575 82             ADD A,D
	3576 6F             LD L,A
	3577 92             SUB D
	3578 94             SUB H
	3579 67             LD H,A
	357A 79             LD A,C
	357B 83             ADD A,E
	357C 4F             LD C,A
	357D 93             SUB E
	357E 93             SUB E
	357F 47             LD B,A						 						B = C - 2*E
	3580 7B             LD A,E
	3581 A7             AND A
	3582 1F             RRA													; And save width in bytes to SpriteWidth
	3583 32 37 35       LD (Sprite_Width),A									update Sprite_Width
	3586 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.Case3x56:
    ;; Horrible hack to get the current object - we're usually
    ;; called via Blit_Objects, which sets this.
    ;;
    ;; However, IntersectObj is also called via AddObject, so err...
    ;; either something clever's going on, or the extents can be
    ;; slightly wrong in the AddObject case for doors.
    ;;
    ;; TODO: Tie these into the object definitions and flags
	3587 2A 71 1D       LD HL,(smc_CurrObject2+1)
	358A 23             INC HL
	358B 23             INC HL
	358C CB 6E          BIT 5,(HL)											; Bit 5 = is LHS door
	358E 08             EX AF,AF
	358F 7E             LD A,(HL)
	3590 D6 10          SUB 10												; NC for < 9 or > 30 - ie near doors
	3592 FE 20          CP 20
	3594 2E 04          LD L,04
	3596 30 02          JR NC,br_359A
	3598 2E 08          LD L,08
br_359A
	359A 78             LD A,B					 							L = (Flag - $10) >= $20 ? 8 : 4
	359B 85             ADD A,L
	359C 6F             LD L,A
	359D D6 38          SUB 38
	359F 67             LD H,A
	35A0 08             EX AF,AF
	35A1 79             LD A,C
	35A2 06 08          LD B,08
	35A4 20 02          JR NZ,br_35A8
	35A6 06 04          LD B,04
br_35A8
	; Use 8 for left doors, 4 for right.
	35A8 80             ADD A,B												B = (Flag & 0x20) ? 8 : 4
	35A9 4F             LD C,A
	35AA D6 0C          SUB 0C
	35AC 47             LD B,A
	35AD 3E 03          LD A,03												; Always 3 bytes wide.
	35AF 32 37 35       LD (Sprite_Width),A									update Sprite_Width
	35B2 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Looks up based on SpriteCode. Top bit set means flip horizontally.
;; Return height in B, image in DE, mask in HL.
.Load_sprite_image_address_into_DE:
	35B3 3A 38 35       LD A,(Sprite_Code)									get sprite code
	35B6 E6 7F          AND 7F												; Top bit holds 'reverse?'. Ignore.
	35B8 FE 54          CP 54												; >= 0x54 -> 4x28 (#54 is the SPR_DOORSTEP, the first of the 4x28 sprites)
	35BA D2 7C 36       JP NC,Sprite4x28
	35BD FE 18          CP 18												; >= 0x18 -> 3x24 (#18 is the SPR_HEELS1, the first of the 3x24 sprites)
	35BF 30 7E          JR NC,Sprite3x24
	35C1 FE 10          CP 10												; >= 0x10 -> 3x32
	35C3 26 00          LD H,00
	35C5 30 4B          JR NC,Sprite3x32
	35C7 6F             LD L,A
	35C8 ED 5B 71 1D    LD DE,(smc_CurrObject2+1)
	35CC 13             INC DE
	35CD 13             INC DE
	; Normal case if the object's flag & 3 != 3
	35CE 1A             LD A,(DE)
	35CF F6 FC          OR FC												~$03
	35D1 3C             INC A
	35D2 20 26          JR NZ,Sprite3x56
	;; flag & 3 == 3 case:
	35D4 3A 38 35       LD A,(Sprite_Code)									get sprite code
	35D7 4F             LD C,A
	35D8 17             RLA
	35D9 3A B9 1E       LD A,(RoomDimensionsIdx)
	35DC 38 04          JR C,br_35E2											; Flip bit set?
	35DE FE 06          CP 06												Narrow-in-U-direction room?
	35E0 18 02          JR br_35E4

br_35E2
	35E2 FE 03          CP 03												Narrow-in-V-direction room?
br_35E4
	35E4 28 14          JR Z,Sprite3x56
	; Use DoorwayBuf.
	35E6 3A ED 36       LD A,(DoorwayFlipped)
	35E9 A9             XOR C
	35EA 17             RLA
	35EB 11 C0 B9       LD DE,DoorwayBuf									DoorwayBuf
	35EE 21 68 BA       LD HL,DoorwayMaskBuf								DoorwayMaskBuf : DoorwayBuf + 56 * 3
	35F1 D0             RET NC
	; And flip it if necessary.
	35F2 79             LD A,C
	35F3 32 ED 36       LD (DoorwayFlipped),A
	35F6 06 70          LD B,70												56*2
	35F8 18 66          JR FlipSprite3

;; Deal with a 3 byte x sprite 56 pixels high.
;; Same parameters/return as Load_sprite_image_address_into_DE.
.Sprite3x56:
	35FA 7D             LD A,L
	35FB 5F             LD E,A												*1
	35FC 87             ADD A,A												*2
	35FD 87             ADD A,A												*4
	35FE 83             ADD A,E												*5
	35FF 87             ADD A,A												*10
	3600 6F             LD L,A
	3601 29             ADD HL,HL											*20
	3602 29             ADD HL,HL											*40
	3603 29             ADD HL,HL											80x
	3604 7B             LD A,E												*1
	3605 84             ADD A,H												*256
	3606 67             LD H,A												finally 336x = 3x56x2x
	3607 11 70 82       LD DE,8270											IMG_3x56
	360A 19             ADD HL,DE
	360B 11 A8 00       LD DE,00A8											56*3 ; Point to mask
	360E 06 70          LD B,70												56*2 ; Height of image + height of mask
	3610 18 46          JR Sprite3Wide

;; Deal with a 3 byte x 32 pixel high sprite.
;; Same parameters/return as Load_sprite_image_address_into_DE.
;;
;; Returns a half-height offset sprite if bit 2 is not set, since the
;; 3x32 sprites are broken into 2 16-bit-high chunks.
.Sprite3x32:
	3612 D6 10          SUB 10
	3614 6F             LD L,A
	3615 87             ADD A,A
	3616 85             ADD A,L
	3617 6F             LD L,A
	3618 29             ADD HL,HL
	3619 29             ADD HL,HL
	361A 29             ADD HL,HL
	361B 29             ADD HL,HL
	361C 29             ADD HL,HL
	361D 29             ADD HL,HL											; 3x32x2x
	361E 11 50 8A       LD DE,8A50											IMG_3x32
	3621 19             ADD HL,DE
	3622 11 60 00       LD DE,0060											32*3 : number of bytes in image
	3625 06 40          LD B,40												32*2 : height image + height mask
	3627 EB             EX DE,HL
	3628 19             ADD HL,DE
	3629 D9             EXX
	362A CD BE 36       CALL NeedsFlip
	362D D9             EXX
	362E D4 60 36       CALL NC,FlipSprite3
	;; If bit 2 is not set, move half a sprite down.
	3631 3A A2 1C       LD A,(SpriteFlags)
	3634 E6 02          AND 02
	3636 C0             RET NZ
	3637 01 30 00       LD BC,0030
	363A 09             ADD HL,BC
	363B EB             EX DE,HL
	363C 09             ADD HL,BC
	363D EB             EX DE,HL
	363E C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Deal with a 3 byte x 24 pixel high sprite
;; Same parameters/return as Load_sprite_image_address_into_DE.
;; Return : height image+mask in B, image in DE, mask in HL.
.Sprite3x24:
	363F D6 18          SUB 18												Sprite code was >= #18, realign number at #00 for 1st sprite (SPR_HEELS1) and so on
	3641 57             LD D,A												A = D = sprite number in img_3x24 table
	3642 1E 00          LD E,00												DE = sprite number * 256
	3644 63             LD H,E												init H = E = 0
	3645 87             ADD A,A												*2
	3646 87             ADD A,A												*4
	3647 6F             LD L,A												L=A
	3648 29             ADD HL,HL											*8
	3649 29             ADD HL,HL											HL = sprite number x16
	364A CB 3A          SRL D												Carry=Dbit0 ; int(D/2);
	364C CB 1B          RR E												Ebit7=Carry; these 2 lines do a DE/2, DE= sprite number * 128
	364E 19             ADD HL,DE											HL = sprite number * 144 ; 144x = 2x3x24
	364F 11 D0 8B       LD DE,8BD0											IMG_3x24 base addr
	3652 19             ADD HL,DE											from base addr, add the offset of the sprite we want
	3653 11 48 00       LD DE,0048											#48=72=24*3 (offset for mask = number of bytes in image)
	3656 06 30          LD B,30												#30=48=24*2 (height image + height mask)
.Sprite3Wide:
	3658 EB             EX DE,HL											HL = offset mask, DE = img addr
	3659 19             ADD HL,DE											HL = mask addr
	365A D9             EXX													DE = mask addr, HL = img addr, save BC
	365B CD BE 36       CALL NeedsFlip
	365E D9             EXX													HL = mask addr, DE = img addr, restore B=height*2
	365F D8             RET C												if Carry set, no need to flip, else flip
;; Flip a 3-character-wide sprite. Height in B, source in DE.
.FlipSprite3:
	3660 E5             PUSH HL
	3661 D5             PUSH DE
	3662 EB             EX DE,HL
	3663 16 69          LD D,69												RevTable >> 8
fspr3_loop:
	3665 4E             LD C,(HL)
	3666 22 71 36       LD (smc_flipsprite3+1),HL							; Self-modifying code! will put the value in the "LD (???),A"
	3669 23             INC HL
	366A 5E             LD E,(HL)
	366B 1A             LD A,(DE)
	366C 77             LD (HL),A
	366D 23             INC HL
	366E 5E             LD E,(HL)
	366F 1A             LD A,(DE)
smc_flipsprite3:
	3670 32 00 00		LD (0000),A											; Target of self-modifying code. value is set at #3666
	;;3671 DATAWORD 00 00
	3673 59             LD E,C
	3674 1A             LD A,(DE)
	3675 77             LD (HL),A
	3676 23             INC HL
	3677 10 EC          DJNZ fspr3_loop
	3679 D1             POP DE
	367A E1             POP HL
	367B C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Looks up a 4x28 sprite.
;; Same parameters/return as Load_sprite_image_address_into_DE.
.Sprite4x28:
	367C D6 54          SUB 54												SPR_DOORSTEP ID #54 becaome id 0 and so on
	367E 57             LD D,A
	367F 07             RLCA
	3680 07             RLCA
	3681 26 00          LD H,00
	3683 6F             LD L,A
	3684 5C             LD E,H
	3685 29             ADD HL,HL
	3686 29             ADD HL,HL
	3687 29             ADD HL,HL
	3688 EB             EX DE,HL
	3689 ED 52          SBC HL,DE											; 224x = 4x28x2x
	368B 11 30 AA       LD DE,AA30											IMG_4x28
	368E 19             ADD HL,DE
	368F 11 70 00       LD DE,0070											28*4 = number of bytes in image
	3692 06 38          LD B,38												28*2 = height of image + height of mask
	3694 EB             EX DE,HL
	3695 19             ADD HL,DE
	3696 D9             EXX
	3697 CD BE 36       CALL NeedsFlip
	369A D9             EXX
	369B D8             RET C
;; Flip a 4-character-wide sprite. Height in B, source in DE.
flipSprite4:
	369C E5             PUSH HL
	369D D5             PUSH DE
	369E EB             EX DE,HL
	369F 16 69          LD D,69												RevTable >> 8
fspr4_loop:
	36A1 4E             LD C,(HL)
	36A2 22 B3 36       LD (smc_fs_addr+1),HL								; Self-modifying code at 3683
	36A5 23             INC HL
	36A6 5E             LD E,(HL)
	36A7 23             INC HL
	36A8 1A             LD A,(DE)
	36A9 5E             LD E,(HL)
	36AA 77             LD (HL),A
	36AB 2B             DEC HL
	36AC 1A             LD A,(DE)
	36AD 77             LD (HL),A
	36AE 23             INC HL
	36AF 23             INC HL
	36B0 5E             LD E,(HL)
	36B1 1A             LD A,(DE)
smc_fs_addr:
	36B2 32 00 00       LD (0000),A											; Target of self-modifying code
	;;3683 DATAWORD 00 00													; modified at addr 36A2
	36B5 59             LD E,C
	36B6 1A             LD A,(DE)
	36B7 77             LD (HL),A
	36B8 23             INC HL
	36B9 10 E6          DJNZ fspr4_loop
	36BB D1             POP DE
	36BC E1             POP HL
	36BD C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Look up the sprite in the bitmap, returns with C set if the top bit of
;; SpriteCode matches the bitmap, otherwise updates the bitmap (assumes
;; that the caller will flip the sprite if we return NC). In effect, a
;; simple cache.
.NeedsFlip:
	36BE 3A 38 35       LD A,(Sprite_Code)									get sprite code
	36C1 4F             LD C,A
	36C2 E6 07          AND 07
	36C4 3C             INC A
	36C5 47             LD B,A
	36C6 3E 01          LD A,01
ndflp_1:
	36C8 0F             RRCA												right shift B times
	36C9 10 FD          DJNZ ndflp_1
	36CB 47             LD B,A												; B now contains bitmask from low 3 bits of SpriteCode
	36CC 79             LD A,C
	36CD 1F             RRA
	36CE 1F             RRA
	36CF 1F             RRA
	36D0 E6 0F          AND 0F
	36D2 5F             LD E,A
	36D3 16 00          LD D,00
	36D5 21 E0 70       LD HL,SpriteFlips_buffer							buffer 16 bytes to flip sprite
	36D8 19             ADD HL,DE
	36D9 78             LD A,B
	36DA A6             AND (HL)											; Perform bit-mask look-up
	36DB 28 08          JR Z,SubNeedsFlip											; Bit set?
	36DD CB 11          RL C												; Bit was non-zero
	36DF D8             RET C
	36E0 78             LD A,B
	36E1 2F             CPL
	36E2 A6             AND (HL)
	36E3 77             LD (HL),A											; If top bit of SpriteCode wasn't set, reset bit mask
	36E4 C9             RET

.SubNeedsFlip:
	36E5 CB 11          RL C												; Bit was zero
	36E7 3F             CCF
	36E8 D8             RET C
	36E9 78             LD A,B
	36EA B6             OR (HL)
	36EB 77             LD (HL),A											; If top bit of SpriteCode was set, set bit mask
	36EC C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Are the contents of DoorwayBuf flipped?
.DoorwayFlipped:
	36ED DATABYTE 00
.CurrObject:
	36EE DATAWORD 0B 23
.ObjDir:
	36F0 DATABYTE FF

;; The sprite used in the bottom half of a double-height sprite.
.BottomSprite:
	36F1 DATABYTE 00
;; In the ObjDefns, if the 2nd byte ("function") bits [7:6] are not 0, then the object
;; has amother one attached to it.
.Bottoms_array:
	36F2 DATABYTE 3D							; SPR_TAP		top 2 bits of ObjDefns "function" byte = 2b'01
	36F3 DATABYTE 8E							; ANIM_VAPE3	top 2 bits of ObjDefns "function" byte = 2b'10
	36F4 DATABYTE 3D							; SPR_TAP		top 2 bits of ObjDefns "function" byte = 2b'11

;; -----------------------------------------------------------------------------------------------------------
;; Takes an object pointer in IY, an object code in A, and initialises it.
;; Doesn't set flags, direction code, or coordinates.
;; Must then call AddObject to copy it into the room.
.InitObj:
	36F5 FD 36 09 00    LD (IY+O_SPRFLAGS),00								; Sprite flags
	; Look up A in the ObjDefns table.
	36F9 6F             LD L,A
	36FA 5F             LD E,A
	36FB 16 00          LD D,00												; DE = object code
	36FD 62             LD H,D												; HL=DE=object id code
	36FE 29             ADD HL,HL											; *2
	36FF 19             ADD HL,DE											; *3 : HL = offset = 3 * object id
	3700 11 C9 38       LD DE,ObjDefns										; DE = pointer on Object definition Table (ObjDefns: 3 bytes per entry : <sprite-code> <function> <flag>)
	3703 19             ADD HL,DE											; HL = pointer on ObjDefns + (objectid * 3)
	3704 46             LD B,(HL)											; get sprite code in B
	3705 23             INC HL												; next byte
	3706 7E             LD A,(HL)											; A = double height flag + object function
	3707 E6 3F          AND 3F												; keep object function (in bits[5:0])
	3709 FD 77 0A       LD (IY+O_FUNC),A
	370C 7E             LD A,(HL)											; get byte again
	370D 23             INC HL												; prepare for next byte (flagq)
	370E 07             RLCA
	370F 07             RLCA												; rotate to get 2 upper bits (double height code) in [1:0]
	3710 E6 03          AND 03												; get them
	3712 28 13          JR Z,initobj_1										; if they are 0 (normal height), skip to initobj_1, else:
	3714 C6 F1          ADD A,F1											; (Bottoms_array-1) & $00FF
	3716 5F             LD E,A
	3717 CE 36          ADC A,36											; DE = (Bottoms_array-1) >> 8 + offset ; #36F1 + offset (can be +1, 2 or 3, this is why we have "Bottoms_array-1")
	3719 93             SUB E
	371A 57             LD D,A
	371B 1A             LD A,(DE)											; get bottom sprite in A
	371C FD CB 09 EE    SET 5,(IY+O_SPRFLAGS)								; Sprite flag bit5 = double sprites
	;; if bit 2 of the third byte is set, swap A and B.
    ;; (i.e. Stash current sprite in the bottom, and use bottom
    ;; sprite for the current object.)
	3720 CB 56          BIT 2,(HL)											; 3rd byte (flags), bit2
	3722 28 03          JR Z,initobj_1										; if 0, skip initobj_1, else:
	3724 48             LD C,B
	3725 47             LD B,A												; swap sprites codes
	3726 79             LD A,C
initobj_1:
	3727 32 F1 36       LD (BottomSprite),A									; save sprite code as bottom
	372A 78             LD A,B												; get the other sprite code
	372B CD 4E 37       CALL SetObjSprite
	372E 7E             LD A,(HL)											; 3rd byte in ObjDefns array (flags)
	372F F6 9F          OR 9F												; ~$60
	3731 3C             INC A												; test if value was #60 (SWITCHED)
	3732 7E             LD A,(HL)											; reread the byte
	3733 20 06          JR NZ,initobj_2										; if is not #60 the jump initobj_2, else:
	3735 FD CB 09 FE    SET 7,(IY+O_SPRFLAGS)								; set sprite flag bit 7
	3739 E6 BF          AND BF												; reset bit6 of the value from ObjDefns (it should be #20 now)
initobj_2:
	373B E6 FB          AND FB												; reset bit3 of the value from ObjDefns
	373D FE 80          CP 80												; compare to #80
	373F CB BF          RES 7,A												; reset bit7 from ObjDefns
	3741 FD 77 FF       LD (IY+FF),A										; TmpObj_variables-1 = BaseFlags+1
	3744 FD 36 FE 02    LD (IY+FE),02										; TmpObj_variables-2 = BaseFlags
	3748 D8             RET C												; if was < #80 leave, else:
	3749 FD CB 09 E6    SET 4,(IY+O_SPRFLAGS)								; set sprite flag bit4
	374D C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Set the sprite or animation up for an object.
;; Object pointer in IY, sprite/animation code in A
.SetObjSprite:
    ;; Clear animation code, and set sprite code.
	374E FD 36 0F 00    LD (IY+O_ANIM),00									; anim reset
	3752 FD 77 08       LD (IY+O_SPRITE),A									; set sprite code
	3755 FE 80          CP 80												; test bit7 of sprite code
	3757 D8             RET C												; if anim bit not set then leave, else if anim bit set (sprite code > #80 = not a static sprite, but an animation)
	3758 87             ADD A,A
	3759 87             ADD A,A
	375A 87             ADD A,A												; anim code << 3
	375B FD 77 0F       LD (IY+O_ANIM),A									; put the current sprite ID in [7:3] (anim code) and frame [2:0] = 0
	375E E5             PUSH HL
	375F CD AB 37       CALL Animate										; Animate
	3762 E1             POP HL
	3763 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Takes an object pointer in DE, and index the object function in A.
;; Note that the function ID starts at 1, so to align on the ObjFnTbl
;; table, need to do a -1.
;; The object is of the same format that TmpObj_variables.
.CallObjFn:
	3764 ED 53 EE 36    LD (CurrObject),DE									; update curr object
	3768 D5             PUSH DE
	3769 FD E1          POP IY												; current object pointer in IY
	376B 3D             DEC A												; Function ID (-1 to align on table)
	376C 87             ADD A,A												; *2 (word align as it is addr that are stored in this table)
	376D C6 7F          ADD A,7F											; ObjFnTbl & $00FF
	376F 6F             LD L,A
	3770 CE 38          ADC A,38											; ObjFnTbl >> 8	; #387F+object_num_offset
	3772 95             SUB L
	3773 67             LD H,A												; HL = pointer on the function pointer
	3774 7E             LD A,(HL)											; get the function pointer...
	3775 23             INC HL
	3776 66             LD H,(HL)
	3777 6F             LD L,A												; ...(function address) in HL
	3778 AF             XOR A												; A=0
	3779 32 E8 4B       LD (DrawFlags),A									; reset drawing flags
	377C FD 7E 0B       LD A,(IY+0B)										; ??TODO?? get object facing direction
	377F 32 F0 36       LD (ObjDir),A										; current Object is flipped or not?
	3782 FD 36 0B FF    LD (IY+0B),FF										; reset the object direction
	3786 FD CB 09 76    BIT 6,(IY+O_SPRFLAGS)								; test object flag bit6
	378A C0             RET NZ												; if bit6 is 1 leave, else call object function
	378B E9             JP (HL)												; if SpriteFlags bit6 is 0, then call the object function

;; -----------------------------------------------------------------------------------------------------------
.AnimateObj:
	378C FD CB 09 6E    BIT 5,(IY+O_SPRFLAGS)								; test object sprite flag bit5
	3790 28 19          JR Z,Animate										; if 0 Animate and RET (single sprite), else:
	3792 CD AB 37       CALL Animate										; Need to Move and Animate both stacked sprites (double height)
	3795 08             EX AF,AF											; save flags (carry)
	3796 FD 4E 10       LD C,(IY+O_DIRECTION)								; C=facing direction
	3799 11 12 00       LD DE,0012											; points on ...
	379C FD E5          PUSH IY
	379E FD 19          ADD IY,DE											; ...next object (the 2nd object in the double stacked/height)
	37A0 CD 9D 50       CALL SetFacingDir
	37A3 CD AB 37       CALL Animate
	37A6 FD E1          POP IY												; get back curr object pointer
	37A8 D8             RET C												; Animate returned with Carry set if anim, else NC
	37A9 08             EX AF,AF											; get flags -carry) of first sprite and return Carry set (anim) or NC (not anim)
	37AA C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Update the animation. IY points to an object.
;; Returns with carry flag set if it's an animation. (NC if not)
.Animate:
    ;; Extract the animation id (top 5 bits)
	37AB FD 4E 0F       LD C,(IY+O_ANIM)									; get anim code
	37AE 79             LD A,C												; save full anim code
	37AF E6 F8          AND F8												; sprite is in [7:3]; frame index in [2:0]
	37B1 FE 08          CP 08												; compare with the value 8
	37B3 3F             CCF													; invert Carry
	37B4 D0             RET NC												; if value < 8 (which means value == 0 here due to the AND F8), leave (no anim) with NC, else:
	37B5 0F             RRCA												; Right shift twice,  values from 08 to F8
	37B6 0F             RRCA												; become from 02 to 3E
	37B7 D6 02          SUB 02												; minus 2 gives : 00 to 3C, which is anim ID (0 to 1E) multiplied by 2
	37B9 C6 F3          ADD A,F3											; AnimTable & $00FF
	37BB 6F             LD L,A
	37BC CE 37          ADC A,37											; (AnimTable >> 8) + anim code * 2	; #37F3+offset
	37BE 95             SUB L
	37BF 67             LD H,A												; HL = points on the anim pointer
	37C0 79             LD A,C												; get back the full anim code
	37C1 3C             INC A												; frame_nb + 1
	37C2 E6 07          AND 07												; frame_nb MOD 8
	37C4 47             LD B,A												; B = (frame_nb + 1) MOD 8
	37C5 86             ADD A,(HL)											; This does: ...
	37C6 5F             LD E,A
	37C7 23             INC HL
	37C8 8E             ADC A,(HL)
	37C9 93             SUB E
	37CA 57             LD D,A												; ... DE = (HL) + A, which points on the new current animation sprite ID in AnimTable_data
	37CB 1A             LD A,(DE)											; get current anim sprite
	37CC A7             AND A												; test
	37CD 20 07          JR NZ,Anim1											; if not 0, jump Anim1, else value = 0 : reached the end of the animation sprite list, so need to restart from the begining:
	37CF 06 00          LD B,00												; frame_nb = 0
	37D1 7E             LD A,(HL)											; From the pointer on the AnimTable_data pointer ...
	37D2 2B             DEC HL
	37D3 6E             LD L,(HL)
	37D4 67             LD H,A												; ... get in HL the AnimTable_data pointer (first image on the anim list)
	37D5 7E             LD A,(HL)											; A = 1st sprite in the anim list
.Anim1:
	37D6 FD 77 08       LD (IY+O_SPRITE),A									; update sprite value
	37D9 78             LD A,B												; current frame_nb
	37DA A9             XOR C
	37DB E6 07          AND 07
	37DD A9             XOR C												; insert the anim code to the frame_nb
	37DE FD 77 0F       LD (IY+O_ANIM),A									; and update the O_ANIM
	; the AND F0 and CP 80 checks for :
	; ANIM_ROBOMOUSE (#0E)  #80 : 1000.0|000 = #10|0, #10-2 = #0E and
	; ANIM_ROBOMOUSEB (#0F) #81 : 1000.1|000 = #11|0, #11-2 = #0F
	; because of the AND #F0 both anim codes #0E and #0F match #80
	37E1 E6 F0          AND F0
	37E3 FE 80          CP 80
	37E5 0E 02          LD C,02												; ROBOMOUSE sound set to Sound ID #02
	37E7 28 04          JR Z,anim_setsound									; if match ROBOMOUSE then go set the sound, else:
	; In the same way, #90 will match ANIM_BEE and ANIM_BEEB
	37E9 FE 90          CP 90
	37EB 0E 01          LD C,01												; in that case set Sound ID #01
.anim_setsound:
	37ED 79             LD A,C
	37EE CC 1C 2B       CALL Z,SetSound
	37F1 37             SCF													; Return with Carry set (anim updated)
	37F2 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Note : The 'B' version is the moving-away-from-viewers version (Back/rear view).
.AnimTable:
	37F3 DATAWORD 31 38						; ANIM_VAPE1:     	$81 AnimVape1	3831
	37F5 DATAWORD 36 38						; ANIM_VISORO:    	$82 AnimVisorO	3836
	37F7 DATAWORD 38 38						; ANIM_VISORC:    	$83 AnimVisorC	3838
	37F9 DATAWORD 3A 38						; ANIM_VAPE2:     	$84 AnimVape2	383A
	37FB DATAWORD 3A 38						; ANIM_VAPE2B:    	$85 AnimVape2	383A
	37FD DATAWORD 3F 38						; ANIM_FISH:      	$86 AnimFish	383F
	37FF DATAWORD 3F 38						; ANIM_FISHB:     	$87 AnimFish	383F
	3801 DATAWORD 44 38						; ANIM_TELEPORT:  	$88 AnimTeleport	3844
	3803 DATAWORD 44 38						; ANIM_TELEPORTB: 	$89 AnimTeleport	3844
	3805 DATAWORD 47 38						; ANIM_SPRING:    	$8A AnimSpring	3847
	3807 DATAWORD 47 38						; ANIM_SPRINGB:   	$8B AnimSpring	3847
	3809 DATAWORD 4D 38						; ANIM_MONOCAT:   	$8C AnimMonocat	384D
	380B DATAWORD 52 38						; ANIM_MONOCATB:  	$8D AnimMonocatB	3852
	380D DATAWORD 57 38						; ANIM_VAPE3:     	$8E AnimVape3	3857
	380F DATAWORD 57 38						; ANIM_VAPE3B:    	$8F AnimVape3	3857
	3811 DATAWORD 5E 38						; ANIM_ROBOMOUSE: 	$90 AnimRobomouse	385E
	3813 DATAWORD 60 38						; ANIM_ROBOMOUSEB:	$91 AnimRobomouseB	3860
	3815 DATAWORD 62 38						; ANIM_BEE:       	$92 AnimBee	3862
	3817 DATAWORD 62 38						; ANIM_BEEB:      	$93 AnimBee	3862
	3819 DATAWORD 67 38						; ANIM_BEACON:    	$94 AnimBeacon	3867
	381B DATAWORD 67 38						; ANIM_BEACONB:   	$95 AnimBeacon	3867
	381D DATAWORD 6A 38						; ANIM_FACE:      	$96 AnimFace	386A
	381F DATAWORD 6C 38						; ANIM_FACEB:     	$97 AnimFaceB	386C
	3821 DATAWORD 6E 38						; ANIM_CHIMP:     	$98 AnimChimp	386E
	3823 DATAWORD 70 38						; ANIM_CHIMPB:    	$99 AnimChimpB	3870
	3825 DATAWORD 72 38						; ANIM_CHARLES:   	$9A AnimCharles	3872
	3827 DATAWORD 74 38						; ANIM_CHARLESB:  	$9B AnimCharlesB	3874
	3829 DATAWORD 76 38						; ANIM_TRUNK:     	$9C AnimTrunk	3876
	382B DATAWORD 78 38						; ANIM_TRUNKB:    	$9D AnimTrunkB	3878
	382D DATAWORD 7A 38						; ANIM_HELIPLAT:    #9E AnimHeliplat 3874	387A
	382F DATAWORD 7A 38						; ANIM_HELIPLATB:   #9F AnimHeliplat 3874	387A

;; -----------------------------------------------------------------------------------------------------------
.AnimTable_data:
	3831 DATABYTE A4 24 25 26 00   			; AnimVape1: $80|SPR_VAPE1,SPR_VAPE1,SPR_VAPE2,SPR_VAPE3,$00
	3836 DATABYTE 10 00						; AnimVisorO: SPR_VISOROHALF,$00
	3838 DATABYTE 11 00						; AnimVisorC: SPR_VISORCHALF,$00
	383A DATABYTE 24 25 25 24 00        	; AnimVape2: SPR_VAPE1,SPR_VAPE2,SPR_VAPE2,SPR_VAPE1,$00
	383F DATABYTE 2D 2D 2E 2E 00        	; AnimFish: SPR_FISH1,SPR_FISH1,SPR_FISH2,SPR_FISH2,$00
	3844 DATABYTE 57 D7 00             		; AnimTeleport: SPR_TELEPORT,$80|SPR_TELEPORT,$00
	3847 DATABYTE 2B 2B 2C 2B 2C 00			; AnimSpring: SPR_SPRING,SPR_SPRING,SPR_SPRUNG,SPR_SPRING,SPR_SPRUNG,$00
	384D DATABYTE 32 32 33 33 00        	; AnimMonocat: SPR_MONOCAT1,SPR_MONOCAT1,SPR_MONOCAT2,SPR_MONOCAT2,$00
	3852 DATABYTE 34 34 35 35 00        	; AnimMonocatB: SPR_MONOCATB1,SPR_MONOCATB1,SPR_MONOCATB2,SPR_MONOCATB2,$00
	3857 DATABYTE 26 25 26 A6 A5 A6 00  	; AnimVape3: SPR_VAPE3,SPR_VAPE2,SPR_VAPE3,$80|SPR_VAPE3,$80|SPR_VAPE2,$80|SPR_VAPE3,$00
	385E DATABYTE 36 00         			; AnimRobomouse: SPR_ROBOMOUSE,$00
	3860 DATABYTE 37 00             		; AnimRobomouseB: SPR_ROBOMOUSEB,$00
	3862 DATABYTE 38 39 B9 B8 00       		; AnimBee: SPR_BEE1,SPR_BEE2,$80|SPR_BEE2,$80|SPR_BEE1,$00
	3867 DATABYTE 3A BA 00       			; AnimBeacon: SPR_BEACON,$80|SPR_BEACON,$00
	386A DATABYTE 3B 00          			; AnimFace: SPR_FACE,$00
	386C DATABYTE 3C 00          			; AnimFaceB: SPR_FACEB,$00
	386E DATABYTE 3E 00          			; AnimChimp: SPR_CHIMP,$00
	3870 DATABYTE 3F 00          			; AnimChimpB: SPR_CHIMPB,$00
	3872 DATABYTE 40 00          			; AnimCharles: SPR_CHARLES,$00
	3874 DATABYTE 41 00          			; AnimCharlesB: SPR_CHARLESB,$00
	3876 DATABYTE 42 00          			; AnimTrunk: SPR_TRUNK,$00
	3878 DATABYTE 43 00          			; AnimTrunkB: SPR_TRUNKB,$00
	387A DATABYTE 44 45 C5 C4 00			; AnimHeliplat:  SPR_HELIPLAT1,SPR_HELIPLAT2,$80|SPR_HELIPLAT2,$80|SPR_HELIPLAT1,$00

;; -----------------------------------------------------------------------------------------------------------
;; Table has base index of 1 in CallObjFn
.ObjFnTbl:
	387F DATAWORD DC 4D						; OBJFN_PUSHABLE: 	01 ObjFnPushable   4DDC
	3881 DATAWORD 46 4D						; OBJFN_ROLLERS1: 	02 ObjFnRollers1	4D46
	3883 DATAWORD 4A 4D						; OBJFN_ROLLERS2: 	03 ObjFnRollers2	4D4A
	3885 DATAWORD 4E 4D						; OBJFN_ROLLERS3: 	04 ObjFnRollers3	4D4E
	3887 DATAWORD 52 4D						; OBJFN_ROLLERS4: 	05 ObjFnRollers4	4D52
	3889 DATAWORD F3 4D						; OBJFN_VISOR1:   	06 ObjFnVisor1	4DF3
	388B DATAWORD F8 4D						; OBJFN_MONOCAT:  	07 ObjFnMonocat	4DF8
	388D DATAWORD FD 4D						; OBJFN_ANTICLOCK:	08 ObjFnAnticlock	4DFD
	388F DATAWORD 11 4E						; OBJFN_RANDB:    	09 ObjFnRandB	4E11
	3891 DATAWORD 86 4C						; OBJFN_BALL:     	0A ObjFnBall	4C86
	3893 DATAWORD 02 4E						; OBJFN_BEE:      	0B ObjFnBee	4E02
	3895 DATAWORD 07 4E						; OBJFN_RANDQ:    	0c ObjFnRandQ	4E07
	3897 DATAWORD 0C 4E						; OBJFN_RANDR:    	0d ObjFnRandR	4E0C
	3899 DATAWORD D6 4C						; OBJFN_SWITCH:   	0e ObjFnSwitch	4CD6
	389B DATAWORD 16 4E						; OBJFN_HOMEIN:   	0f ObjFnHomeIn 4E16
	389D DATAWORD 82 4E						; OBJFN_HELIPLAT3:	10 ObjFnHeliplat3 4E82
	389F DATAWORD 80 4D						; OBJFN_FADE:     	11 ObjFnFade 4D80
	38A1 DATAWORD 31 4D						; OBJFN_HELIPLAT: 	12 ObjFnHeliplat 4D31
	38A3 DATAWORD 3B 4D						; OBJFN_19:       	13 ObjFn19 4D3B
	38A5 DATAWORD 66 4D						; OBJFN_DISSOLVE2:	14 ObjFnDissolve2 4D66
	38A7 DATAWORD ED 4D						; OBJFN_21:       	15 ObjFn21 4DED
	38A9 DATAWORD E7 4D						; OBJFN_22:       	16 ObjFn22 4DE7
	38AB DATAWORD 2E 4D						; OBJFN_HELIPLAT2:	17 ObjFnHeliplat2 4D2E
	38AD DATAWORD 63 4D						; OBJFN_DISSOLVE: 	18 ObjFnDissolve 4D63
	38AF DATAWORD 76 4C						; OBJFN_FIRE:     	19 ObjFnFire 4C76
	38B1 DATAWORD CF 4D						; OBJFN_26:       	1a ObjFn26 4DCF
	38B3 DATAWORD 18 4C						; OBJFN_TELEPORT: 	1b ObjFnTeleport 4C18
	38B5 DATAWORD 98 4D						; OBJFN_SPRING:   	1c ObjFnSpring 4D98
	38B7 DATAWORD FB 4B						; OBJFN_ROBOT:    	1d ObjFnRobot 4BFB
	38B9 DATAWORD EB 4B						; OBJFN_JOYSTICK: 	1e ObjFnJoystick 4BEB
	38BB DATAWORD 5C 4D						; OBJFN_HUSHPUPPY:	1f ObjFnHushPuppy 4D5C
	38BD DATAWORD 5E 4C						; OBJFN_32:       	20 ObjFn32 4C5E
	38BF DATAWORD 36 4F						; OBJFN_33:       	21 ObjFn33 4F36
	38C1 DATAWORD 92 4D						; OBJFN_DISAPPEAR:	22 ObjFnDisappear 4D92
	38C3 DATAWORD 3F 4C						; OBJFN_35:       	23 ObjFn35 4C3F
	38C5 DATAWORD 29 4C						; OBJFN_CANNONBALL: 24 ObjFnCannonFire 4C29 (victory room)
	38C7 DATAWORD 1B 4E						; OBJFN_CROWNY:   	25 ObjFnCrowny	4E1B

;; Flags for double-height stuff
;; DBL_HEIGHT_1:           EQU $40   ; 1st in Bottoms_array
;; DBL_HEIGHT_2:           EQU $80   ; 2nd
;; DBL_HEIGHT_3:           EQU $C0   ; 3rd
;;
;; Guessing the flags...
;; SWAPPED:        EQU $04
;; H_FLIP:		   EQU #10 (to be confirmed)
;; DEADLY:         EQU $20
;; PORTABLE:       EQU $40
;; SWITCHED:       EQU $60
;; Still unknown: $01, $02, $08

; Define the objects that can appear in a room definition
.ObjDefns:							;; <sprite code> 		<function> 						<flag>
	38C9 DATAWORD 88 1B 01			; $00 ANIM_TELEPORT, 	OBJFN_TELEPORT,           		$01
	38CC DATAWORD 2B 1C 40			; $01 SPR_SPRING,    	OBJFN_SPRING,             		PORTABLE
	38CF DATAWORD 31 00 02			; $02 SPR_GRATING,   	0,                        		$02
	38D2 DATAWORD 4A 01 40			; $03 SPR_TRUNKS,    	OBJFN_PUSHABLE,           		PORTABLE
	38D5 DATAWORD 9E 17 00			; $04 ANIM_HELIPLAT, 	OBJFN_HELIPLAT2,          		0
	38D8 DATAWORD 5D 00 01			; $05 SPR_BOOK,      	0,                        		$01
	38DB DATAWORD 56 02 11			; $06 SPR_ROLLERS,   	OBJFN_ROLLERS1,           		H_FLIP | $01
	38DE DATAWORD 56 03 11			; $07 SPR_ROLLERS,   	OBJFN_ROLLERS2,           		H_FLIP | $01
	38E1 DATAWORD 56 04 01			; $08 SPR_ROLLERS,   	OBJFN_ROLLERS3,           		$01
	38E4 DATAWORD 56 05 01			; $09 SPR_ROLLERS,   	OBJFN_ROLLERS4,           		$01
	38E7 DATAWORD 46 01 40			; #0A SPR_BONGO,      	OBJFN_PUSHABLE,           		PORTABLE
	38EA DATAWORD 4B 01 40			; #0B SPR_DECK,       	OBJFN_PUSHABLE,           		PORTABLE
	38ED DATAWORD 90 8F 6C			; #0C ANIM_ROBOMOUSE, 	DBL_HEIGHT_2 | OBJFN_HOMEIN,    SWITCHED | SWAPPED | $08
	38F0 DATAWORD 4C 0A 00			; #0D SPR_BALL,       	OBJFN_BALL,                		0
	38F3 DATAWORD 58 00 21			; #0E SPR_LAVAPIT,    	0,                         		DEADLY | $01
	38F6 DATAWORD 5E 00 21			; #0F SPR_TOASTER,    	0,                         		DEADLY | $01
	38F9 DATAWORD 30 0E 00			; $10 SPR_SWITCH,     	OBJFN_SWITCH,              		0
	38FC DATAWORD 94 09 60			; $11 ANIM_BEACON,    	OBJFN_RANDB,               		SWITCHED
	38FF DATAWORD 96 4F 6C			; $12 ANIM_FACE,      	DBL_HEIGHT_1 | OBJFN_HOMEIN,    SWITCHED | SWAPPED | $08
	3902 DATAWORD 9A DD 0C			; $13 ANIM_CHARLES,   	DBL_HEIGHT_3 | OBJFN_ROBOT,     SWAPPED | $08
	3905 DATAWORD 49 1E 00			; $14 SPR_STICK,      	OBJFN_JOYSTICK,           		0
	3908 DATAWORD 5A 01 01			; $15 SPR_ANVIL,      	OBJFN_PUSHABLE,           		$01
	390B DATAWORD 5F 00 01			; $16 SPR_CUSHION,    	0,                        		$01
	390E DATAWORD 5F 14 01			; $17 SPR_CUSHION,   	OBJFN_DISSOLVE2,          		$01
	3911 DATAWORD 48 00 00			; $18 SPR_WELL,      	0,                        		0
	3914 DATAWORD 92 0B 60			; $19 ANIM_BEE,      	OBJFN_BEE,                		SWITCHED
	3917 DATAWORD 31 18 02			; #1A SPR_GRATING,   	OBJFN_DISSOLVE,           		$02
	391A DATAWORD 82 06 68			; #1B ANIM_VISORO,   	OBJFN_VISOR1,             		SWITCHED | $08
	391D DATAWORD 84 CC 6C			; #1C ANIM_VAPE2,    	DBL_HEIGHT_3 | OBJFN_RANDQ,     SWITCHED | SWAPPED | $08
	3920 DATAWORD 47 0A 20			; #1D SPR_DRUM,      	OBJFN_BALL,                		DEADLY
	3923 DATAWORD 5C 1F 01			; #1E SPR_HUSHPUPPY, 	OBJFN_HUSHPUPPY,           		$01
	3926 DATAWORD 55 15 01			; #1F SPR_SANDWICH,  	OBJFN_21,                  		$01
	3929 DATAWORD 96 CD 6C			; $20 ANIM_FACE,     	DBL_HEIGHT_3 | OBJFN_RANDR,     SWITCHED | SWAPPED | $08
	392C DATAWORD 5B 00 21			; $21 SPR_SPIKES,    	0,                        		DEADLY | $01
	392F DATAWORD 5D 14 01			; $22 SPR_BOOK,      	OBJFN_DISSOLVE2,          		$01
	3932 DATAWORD 59 14 01			; $23 SPR_PAD,       	OBJFN_DISSOLVE2,          		$01
	3935 DATAWORD 59 00 01			; $24 SPR_PAD,       	0,                        		$01
	3938 DATAWORD 3D 20 60			; $25 SPR_TAP,       	OBJFN_32,                 		SWITCHED
	393B DATAWORD 92 21 60			; $26 ANIM_BEE,      	OBJFN_33,                 		SWITCHED
	393E DATAWORD 9E 12 00			; $27 ANIM_HELIPLAT, 	OBJFN_HELIPLAT,           		0
	3941 DATAWORD 55 01 01			; $28 SPR_SANDWICH,  	OBJFN_PUSHABLE,           		$01
	3944 DATAWORD 5F 13 01			; $29 SPR_CUSHION,   	OBJFN_19,                 		$01
	3947 DATAWORD 8C 07 60			; #2A ANIM_MONOCAT,  	OBJFN_MONOCAT,            		SWITCHED
	394A DATAWORD 5A 16 01			; #2B SPR_ANVIL,     	OBJFN_22,                 		$01
	394D DATAWORD 5D 08 01			; #2C SPR_BOOK,      	OBJFN_ANTICLOCK,          		$01
	3950 DATAWORD 55 23 01			; #2D SPR_SANDWICH,  	OBJFN_35,                 		$01
	3953 DATAWORD 9C CD 6C			; #2E ANIM_TRUNK,    	DBL_HEIGHT_3 | OBJFN_RANDR,     SWITCHED | SWAPPED | $08
	3956 DATAWORD 42 00 20			; #2F SPR_TRUNK,     	0,                        		DEADLY
	3959 DATAWORD 47 0A 00			; $30 SPR_DRUM,      	OBJFN_BALL,               		0
	395C DATAWORD 2D 00 20			; $31 SPR_FISH1,     	0,                        		DEADLY
	395F DATAWORD 56 14 01			; $32 SPR_ROLLERS,   	OBJFN_DISSOLVE2,          		$01
	3962 DATAWORD 5D 0A 01			; $33 SPR_BOOK,      	OBJFN_BALL,               		$01
	3965 DATAWORD 5D 01 01			; $34 SPR_BOOK,      	OBJFN_PUSHABLE,           		$01
	3968 DATAWORD 98 4F 6C			; $35 ANIM_CHIMP,    	DBL_HEIGHT_1 | OBJFN_HOMEIN,    SWITCHED | SWAPPED | $08
	396B DATAWORD 98 CD 6C			; $36 ANIM_CHIMP,    	DBL_HEIGHT_3 | OBJFN_RANDR,     SWITCHED | SWAPPED | $08
	396E DATAWORD 82 08 68			; $37 ANIM_VISORO,   	OBJFN_ANTICLOCK,          		SWITCHED | $08
	3971 DATAWORD 36 00 20			; $38 SPR_ROBOMOUSE, 	0,                        		DEADLY
	3974 DATAWORD 37 00 20			; $39 SPR_ROBOMOUSEB,	0,                        		DEADLY
	3977 DATAWORD 1E 00 00			; #3A SPR_HEAD1,     	0,                        		0
	397A DATAWORD 18 00 00			; #3B SPR_HEELS1,    	0,                        		0
	397D DATAWORD 4C 24 00			; #3C SPR_BALL,      	OBJFN_CANNONBALL,          		0
	3980 DATAWORD 4C A5 2C			; #3D SPR_BALL,      	DBL_HEIGHT_2 | OBJFN_CROWNY,    DEADLY | SWAPPED | $08
	3983 DATAWORD 84 21 60			; #3E ANIM_VAPE2,    	OBJFN_33,                  		SWITCHED

;; -----------------------------------------------------------------------------------------------------------
;; Reinitialisation size of the array
;; The Reinitialise call with 3986 as argument will copy the 27 bytes of
;; ObjVars_reset_data into the ObjListIdx & after
ObjVars:
	3986 DATAWORD 1B														; length : 27 bytes
ObjVars_reset_data:
	3987 DATAWORD 00
	3988 DATAWORD 40 6A           											; reset for Objects  			6A40
	398A DATAWORD A9 39            											; reset for ObjectLists + 0		39A9
	398C DATAWORD AB 39           											; reset for ObjectLists + 2  	39AB
	398E DATAWORD 00 00
	3990 DATAWORD 00 00
	3992 DATAWORD 00 00 00 00
	3996 DATAWORD 00 00 00 00
	399A DATAWORD 00 00 00 00
	399E DATAWORD 00 00 00 00

;; -----------------------------------------------------------------------------------------------------------
;; The index into ObjectLists.
ObjListIdx:
	39A2 DATABYTE 00

Object_Destination:															; Current pointer for where we write objects into
	39A3 DATAWORD 40 6A														; 6A40 buffer

.ObjListAPtr:																; 'A' list item pointers are offset +2 from 'B' list pointers.
	39A5 DATAWORD A9 39														; ObjectLists + 0 : 39A9
.ObjListBPtr:
	39A7 DATAWORD AB 39														; ObjectLists + 2 : 39AB

;; Each list consists of a pair of pointers to linked lists of
;; objects (ListA and ListB). They're opposite directions in a
;; doubly-linked list, and each side has a head node, it seems.
ObjectLists:
	39A9 DATAWORD 00 00 													; ObjectLists + 0   ; Usual list
	39AB DATAWORD 00 00             										; ObjectLists + 2   ; Usual list
	39AD DATAWORD 00 00 00 00            									; ObjectLists + 1*4 ; Next room in V direction
	39B1 DATAWORD 00 00 00 00            									; ObjectLists + 2*4 ; Next room in U direction
	39B5 DATAWORD 00 00 00 00            									; ObjectLists + 3*4 ; Far
	39B9 DATAWORD 00 00 00 00            									; ObjectLists + 4*4 ; Near

Saved_Object_Destination:
	39BD DATAWORD 40 6A														Objects : 6A40

;; -----------------------------------------------------------------------------------------------------------
.SortObj:
	39BF DATAWORD 00 00

;; -----------------------------------------------------------------------------------------------------------
;; Given an index in A, set the object list index and pointers.
.SetObjList:
	39C1 32 A2 39       LD (ObjListIdx),A									; object id
	39C4 87             ADD A,A												; *2
	39C5 87             ADD A,A												; *4
	39C6 C6 A9          ADD A,A9											; (ObjectLists & $00ff) + (4 * object id)
	39C8 6F             LD L,A
	39C9 CE 39          ADC A,39											; ObjectLists >> 8	; #39A9+offset
	39CB 95             SUB L
	39CC 67             LD H,A
	39CD 22 A5 39       LD (ObjListAPtr),HL									; pointer A
	39D0 23             INC HL
	39D1 23             INC HL												; next word in list
	39D2 22 A7 39       LD (ObjListBPtr),HL									; pointer B
	39D5 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; DE contains an 'A' object pointer. Assumes the other half of the object
;; is in the next slot (+0x12). Syncs the object state.
.SyncDoubleObject:
    ;; Copy 5 bytes, from the pointer location onwards:
    ;; Next pointer, flags, U & V coordinates.
	39D6 21 12 00       LD HL,0012
	39D9 19             ADD HL,DE
	39DA E5             PUSH HL
	39DB EB             EX DE,HL
	39DC 01 05 00       LD BC,0005
	39DF ED B0          LDIR												repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	; Copy across Z coordinate, sutracting 6.
	39E1 7E             LD A,(HL)
	39E2 D6 06          SUB 06
	39E4 12             LD (DE),A
	;; If bit 5 of byte 9 is set on first object, we're done.
	39E5 13             INC DE
	39E6 23             INC HL
	39E7 23             INC HL
	39E8 CB 6E          BIT 5,(HL)
	39EA 20 03          JR NZ,snkdblob_1
	; Otherwise, copy the sprite over (byte 8).
	39EC 2B             DEC HL
	39ED ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
snkdblob_1:
	39EF E1             POP HL
	39F0 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Copy an object into the object buffer, add a second object if it's
;; doubled, and link it into the depth-sorted lists.
;;
;; HL is a 'B' pointer to an object.
;; BC contains the size of the object (18 bytes).
.AddObject:
    ;; First, just return if there's no intersection with the view window.
	39F1 E5             PUSH HL
	39F2 C5             PUSH BC
	39F3 23             INC HL
	39F4 23             INC HL
	39F5 CD 03 1E       CALL IntersectObj   								; HL now contains an 'A' ptr to object.
	39F8 C1             POP BC
	39F9 E1             POP HL
	39FA D0             RET NC
	; Copy BC bytes of object to what ObjDest pointer, updating ObjDest
	39FB ED 5B A3 39    LD DE,(Object_Destination)							get Object_Destination buffer pointer
	39FF D5             PUSH DE
	3A00 ED B0          LDIR												repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	3A02 ED 53 A3 39    LD (Object_Destination),DE							update Object_Destination
	3A06 E1             POP HL
	; HL now points at copied object
	3A07 E5             PUSH HL
	3A08 FD E1          POP IY
	; If it's not a double object, just call Enlist.
	3A0A FD CB 04 5E    BIT 3,(IY+O_FLAGS)									; Check bit 3 of flags...
	3A0E 28 2B          JR Z,Enlist
	;; Bit 3 set = tall object. Make the second object like the
    ;; first, copying the first 9 bytes.
	3A10 01 09 00       LD BC,0009
	3A13 E5             PUSH HL
	;; Copy byte at offset 9 over, setting bit 1.
	3A14 ED B0          LDIR												repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	3A16 EB             EX DE,HL
	3A17 1A             LD A,(DE)											; Load A with offset 9 of original
	3A18 F6 02          OR 02
	3A1A 77             LD (HL),A											; Set bit 1, write out.
	; Write 0 for byte at offset 10.
	3A1B 23             INC HL
	3A1C 36 00          LD (HL),00
	; And update ObjDest to point past newly constructed object (offset 18).
	3A1E 11 08 00       LD DE,0008
	3A21 19             ADD HL,DE
	3A22 22 A3 39       LD (Object_Destination),HL							update Object_Destination
	; If bit 5 of offset 9 set, set the sprite on this second object.
	3A25 FD CB 09 6E    BIT 5,(IY+O_SPRFLAGS)
	3A29 28 0F          JR Z,addob_1
	3A2B FD E5          PUSH IY
	3A2D 11 12 00       LD DE,0012											array size
	3A30 FD 19          ADD IY,DE
	3A32 3A F1 36       LD A,(BottomSprite)
	3A35 CD 4E 37       CALL SetObjSprite
	3A38 FD E1          POP IY
addob_1:
	3A3A E1             POP HL
;; HL points at an object, as does IY.
.Enlist:
	3A3B 3A A2 39       LD A,(ObjListIdx)
	; If the current object list is >= 3, use EnlistAux directly.
	3A3E 3D             DEC A
	3A3F FE 02          CP 02
	3A41 30 23          JR NC,EnlistAux
	; If it's not double-height, insert on the current list.
	3A43 23             INC HL
	3A44 23             INC HL
	3A45 FD CB 04 5E    BIT 3,(IY+O_FLAGS)
	3A49 28 14          JR Z,EnlistObj
	3A4B E5             PUSH HL
	3A4C CD 5F 3A       CALL EnlistObj
	3A4F D1             POP DE
	3A50 CD D6 39       CALL SyncDoubleObject
	3A53 E5             PUSH HL
	3A54 CD 31 3B       CALL GetUVZExtentsA
	3A57 D9             EXX
	3A58 FD E5          PUSH IY
	3A5A E1             POP HL
	3A5B 23             INC HL
	3A5C 23             INC HL
	3A5D 18 51          JR DepthInsert

;; Put the object in HL into its depth-sorted position in the
;; list.
.EnlistObj:
	3A5F E5             PUSH HL
	3A60 CD 31 3B       CALL GetUVZExtentsA
	3A63 D9             EXX
	3A64 18 47          JR DepthInsertHd
; Takes a B pointer in HL/IY. Enlists it, and its other half if it's a
;; double-size object. Inserts inthe the appropriate list.
.EnlistAux:
	3A66 23             INC HL
	3A67 23             INC HL
	; Easy path if it's a single object.
	3A68 FD CB 04 5E    BIT 3,(IY+O_FLAGS)
	3A6C 28 14          JR Z,EnlistObjAux
	; Otherwise, do one half...
	3A6E E5             PUSH HL
	3A6F CD 82 3A       CALL EnlistObjAux
	3A72 D1             POP DE
	3A73 CD D6 39       CALL SyncDoubleObject
	; and insert the other half, on the same object list.
	3A76 E5             PUSH HL
	3A77 CD 31 3B       CALL GetUVZExtentsA
	3A7A D9             EXX
	3A7B FD E5          PUSH IY
	3A7D E1             POP HL
	3A7E 23             INC HL
	3A7F 23             INC HL
	3A80 18 2E          JR DepthInsert

;; Object in HL. Inserts object into appropriate object list
;; based on coordinates.
;;
;; List 3 is far away, 0 in middle, 4 is near.
.EnlistObjAux:
	3A82 E5             PUSH HL
	3A83 CD 31 3B       CALL GetUVZExtentsA
	; If object is beyond high U boundary, put on list 3.
	3A86 3E 03          LD A,03
	3A88 08             EX AF,AF
	3A89 3A C4 1E       LD A,(Max_min_UV_Table+2)							MaxU
	3A8C BA             CP D
	3A8D 38 19          JR C,elonjax_1
	; If object is beyond high V boundary, put on list 3.
	3A8F 3A C5 1E       LD A,(Max_min_UV_Table+3)							MaxV
	3A92 BC             CP H
	3A93 38 13          JR C,elonjax_1
	; If object is beyond low U boundary, put on list 4.
	3A95 3E 04          LD A,04
	3A97 08             EX AF,AF
	3A98 3A C2 1E       LD A,(Max_min_UV_Table)								MinU
	3A9B 3D             DEC A
	3A9C BB             CP E
	3A9D 30 09          JR NC,elonjax_1
	; If object is beyond low V boundary, put on list 4.
	3A9F 3A C3 1E       LD A,(Max_min_UV_Table+1)							MinV
	3AA2 3D             DEC A
	3AA3 BD             CP L
	3AA4 30 02          JR NC,elonjax_1
	; Otherwise, put on list 0.
	3AA6 AF             XOR A
	3AA7 08             EX AF,AF
elonjax_1:
	3AA8 D9             EXX
	3AA9 08             EX AF,AF
	; And then insert into the appropriate place on that list.
	3AAA CD C1 39       CALL SetObjList
;; Does DepthInsert on the list pointed to by ObjListAPtr
.DepthInsertHd:
	3AAD 2A A5 39       LD HL,(ObjListAPtr)
;; Object extents in alt registers, 'A' pointer in HL.
;; Object to insert is on the stack.
;;
;; I believe this traverses a list sorted far-to-near, and
;; loads up HL with the nearest object further away from our
;; object.
.DepthInsert:
	3AB0 22 BF 39       LD (SortObj),HL
.DepIns2:
	3AB3 7E             LD A,(HL)											; Load next object into HL...
	3AB4 23             INC HL
	3AB5 66             LD H,(HL)
	3AB6 6F             LD L,A
	3AB7 B4             OR H
	3AB8 28 0D          JR Z,DepIns3										; Zero? Done!
	3ABA E5             PUSH HL
	3ABB CD 31 3B       CALL GetUVZExtentsA
	3ABE CD A5 3B       CALL DepthCmp
	3AC1 E1             POP HL
	3AC2 30 EC          JR NC,DepthInsert  									; Update SortObj if current HL is far away
	3AC4 A7             AND A
	3AC5 20 EC          JR NZ,DepIns2										; Break out of loop if past point of caring
.DepIns3:
	3AC7 2A BF 39       LD HL,(SortObj)
	;; Insert the stack-stored object after SortObj.
    ;; Load our object in DE, HL contains object to chain after.
	3ACA D1             POP DE
	; Copy HL obj's 'next' pointer into DE obj's.
	3ACB 7E             LD A,(HL)
	3ACC ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	3ACE 4F             LD C,A
	3ACF 7E             LD A,(HL)
	3AD0 12             LD (DE),A
	; Now copy address of DE into HL's 'next' pointer.
	3AD1 1B             DEC DE
	3AD2 72             LD (HL),D
	3AD3 2B             DEC HL
	3AD4 73             LD (HL),E
	;; Now links in the other direction:
    ;; Put DE's new 'next' pointer into HL.
	3AD5 69             LD L,C
	3AD6 67             LD H,A
	; And if it's zero, load HL with pointer referred to by ObjListBPtr
	3AD7 B1             OR C
	3AD8 20 05          JR NZ,br_3ADF
	3ADA 2A A7 39       LD HL,(ObjListBPtr)
	3ADD 23             INC HL
	3ADE 23             INC HL
br_3ADF
	; Link DE after HL
	3ADF 2B             DEC HL
	3AE0 1B             DEC DE
	3AE1 ED A8          LDD
	3AE3 7E             LD A,(HL)
	3AE4 12             LD (DE),A
	3AE5 73             LD (HL),E
	3AE6 23             INC HL
	3AE7 72             LD (HL),D
	3AE8 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Take an object out of the list, and reinserts it in the
;; appropriate list.
.Relink:
	3AE9 E5             PUSH HL
	3AEA CD F1 3A       CALL Unlink
	3AED E1             POP HL
	3AEE C3 66 3A       JP EnlistAux

;; -----------------------------------------------------------------------------------------------------------
;; Unlink the object in HL. If bit 3 of IY+4 is set, it's an
;; object made out of two subcomponents, and both must be
;; unlinked.
.Unlink:
	3AF1 FD CB 04 5E    BIT 3,(IY+O_FLAGS)
	3AF5 28 09          JR Z,UnlinkObj
	3AF7 E5             PUSH HL
	3AF8 CD 00 3B       CALL UnlinkObj
	3AFB D1             POP DE
	3AFC 21 12 00       LD HL,0012
	3AFF 19             ADD HL,DE
;; Takes a 'B' pointer in HL, and removes the pointed object
;; from the list.
;;
;; In C-like pseudocode:
;;
;; if (obj->b_next == null) {
;;   a_head = obj->a_next;
;; } else {
;;   obj->b_next->a_next = obj->a_next;
;; }
;;
;; if (obj->a_next == null) {
;;   b_head = obj->b_next;
;; } else {
;;   obj->a_next->b_next = obj->b_next;
;; }
.UnlinkObj:
    ;; Load DE with next object after HL, save it.
	3B00 5E             LD E,(HL)
	3B01 23             INC HL
	3B02 56             LD D,(HL)
	3B03 23             INC HL
	3B04 D5             PUSH DE
	;; If zero, get first object on List A, else offset DE by 2 to
    ;; create an 'A' pointer.
	3B05 7A             LD A,D
	3B06 B3             OR E
	3B07 13             INC DE
	3B08 13             INC DE
	3B09 20 04          JR NZ,ulnk_1
	3B0B ED 5B A5 39    LD DE,(ObjListAPtr)
	;; HL pointer at 'A' pointer now. Copy *HL to *DE, saving
    ;; value in HL.
ulnk_1:
	3B0F 7E             LD A,(HL)
	3B10 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	3B12 4F             LD C,A
	3B13 7E             LD A,(HL)
	3B14 12             LD (DE),A
	3B15 67             LD H,A
	3B16 69             LD L,C
	;; If the pointer was null, put the head of the B list in HL.
	3B17 B1             OR C
	3B18 2B             DEC HL
	3B19 20 04          JR NZ,br_3B1F
	3B1B 2A A7 39       LD HL,(ObjListBPtr)
	3B1E 23             INC HL
br_3B1F
	; Make HL's next B object the saved DE B pointer.
	3B1F D1             POP DE
	3B20 72             LD (HL),D
	3B21 2B             DEC HL
	3B22 73             LD (HL),E
	3B23 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Like GetUVZExtentsB, but applies extra height adjustment -
;; increases height by 6 if flag bit 3 is set.
.GetUVZExtentsE:
	3B24 CD 2F 3B       CALL GetUVZExtentsB
	3B27 E6 08          AND 08
	3B29 C8             RET Z
	3B2A 79             LD A,C
	3B2B D6 06          SUB 06
	3B2D 4F             LD C,A
	3B2E C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Given an object in HL, returns its U, V and Z extents.
;; moves in a particular direction:
;;
;; D = high U, E = low U
;; H = high V, L = low V
;; B = high Z, C = low Z
;; It also returns flags in A.
;;
;; Values are based on the bottom 3 flag bits
;; Flag   U      V      Z
;; 0    +3 -3  +3 -3  0  -6
;; 1    +4 -4  +4 -4  0  -6
;; 2    +4 -4  +1 -1  0  -6
;; 3    +1 -1  +4 -4  0  -6
;; 4    +4  0  +4  0  0 -18
;; 5     0 -4  +4  0  0 -18
;; 6    +4  0   0 -4  0 -18
;; 7     0 -4   0 -4  0 -18
.GetUVZExtentsB:
	3B2F 23             INC HL
	3B30 23             INC HL
;; GetUVZExtentsB, except HL has a pointer + 2 to an object, so works with ListA items.
.GetUVZExtentsA:
	3B31 23             INC HL
	3B32 23             INC HL
	3B33 7E             LD A,(HL)											; Offset 4: Flags
	3B34 23             INC HL
	3B35 4F             LD C,A
	3B36 08             EX AF,AF
	3B37 79             LD A,C
	3B38 CB 57          BIT 2,A
	3B3A 20 42          JR NZ,GUVZE_5 										; If bit 2 set
	3B3C CB 4F          BIT 1,A
	3B3E 20 1A          JR NZ,GUVZE_3 										; If bit 1 set
	3B40 E6 01          AND 01
	3B42 C6 03          ADD A,03
	3B44 47             LD B,A												; Bit 0 + 3 in B
	3B45 87             ADD A,A
	3B46 4F             LD C,A												; x2 in C
	3B47 7E             LD A,(HL)											; Load U co-ord
	3B48 80             ADD A,B
	3B49 57             LD D,A												; Store added co-ord in D
	3B4A 91             SUB C
	3B4B 5F             LD E,A												; And subtracted co-ord in E
	3B4C 23             INC HL
	3B4D 7E             LD A,(HL)					 						; Load V co-ord
	3B4E 23             INC HL
	3B4F 80             ADD A,B
	3B50 46             LD B,(HL)											; Load Z co-ord for later
	3B51 67             LD H,A						 						; Store 2nd added co-ord in H
	3B52 91             SUB C
	3B53 6F             LD L,A						 						; And 2nd subtracted co-ored in L
GUVZE_5e:
	3B54 78             LD A,B
	3B55 D6 06          SUB 06
	3B57 4F             LD C,A												; Put Z co-ord - 6 in C
	3B58 08             EX AF,AF
	3B59 C9             RET

;; Bit 1 was set in the object flags
GUVZE_3:
	3B5A 1F             RRA
	3B5B 38 11          JR C,GUVZE_4
	;; Bit 1 set, bit 0 not set
	3B5D 7E             LD A,(HL)
	3B5E C6 04          ADD A,04
	3B60 57             LD D,A
	3B61 D6 08          SUB 08
	3B63 5F             LD E,A												; D/E given added/subtracted U co-ords of 4
	3B64 23             INC HL
	3B65 7E             LD A,(HL)
	3B66 23             INC HL
	3B67 46             LD B,(HL)
	3B68 67             LD H,A
	3B69 6F             LD L,A												; H/L given added/subtracted V co-ords of 1
	3B6A 24             INC H
	3B6B 2D             DEC L
	3B6C 18 E6          JR GUVZE_2

;; Bits 1 and 0 were set
GUVZE_4:
	3B6E 56             LD D,(HL)
	3B6F 5A             LD E,D
	3B70 14             INC D
	3B71 1D             DEC E												; D/E given added/subtracted U co-ords of 1
	3B72 23             INC HL
	3B73 7E             LD A,(HL)
	3B74 23             INC HL
	3B75 C6 04          ADD A,04
	3B77 46             LD B,(HL)
	3B78 67             LD H,A
	3B79 D6 08          SUB 08
	3B7B 6F             LD L,A												; H/L given added/subtracted V co-ords of 4
	3B7C 18 D6          JR GUVZE_2
;; Bit 2 was set in the object flags
GUVZE_5:
	3B7E 7E             LD A,(HL)											; Load U co-ord
	3B7F CB 19          RR C
	3B81 38 06          JR C,GUVZE_5b
	3B83 5F             LD E,A												; Bit 0 reset
	3B84 C6 04          ADD A,04
	3B86 57             LD D,A
	3B87 18 04          JR GUVZE_5c
;; Bit 0 set
GUVZE_5b:
	3B89 57             LD D,A
	3B8A D6 04          SUB 04
	3B8C 5F             LD E,A
GUVZE_5c:
	3B8D 23             INC HL
	3B8E 7E             LD A,(HL)											; Load V co-ord
	3B8F 23             INC HL
	3B90 46             LD B,(HL)											; Load Z co-ord
	3B91 CB 19          RR C
	3B93 38 06          JR C,GUVZE_5d

	3B95 6F             LD L,A												; Bit 1 reset
	3B96 C6 04          ADD A,04
	3B98 67             LD H,A
	3B99 18 04          JR GUVZE_5e
; Bit 1 set
GUVZE_5d:
	3B9B 67             LD H,A
	3B9C D6 04          SUB 04
	3B9E 6F             LD L,A
GUVZE_5e:
	3B9F 78             LD A,B
	3BA0 D6 12          SUB 12
	3BA2 4F             LD C,A
	3BA3 08             EX AF,AF
	3BA4 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Provides a single, long-winded function to depth-order two set of
;; UVZ extents.
;; Two set of UVZ extents (as returned from GetUVZExtents), in main
;; and EXX'd registers.
;;
;; Returns:
;;  Carry set if EXX'd registers represent a further-away object.
;;  A = 0 if there's an overlap in 2 dimensions, $FF otherwise
.DepthCmp:
    ;; L < H' && H > L' -> U Overlap
	3BA5 7D             LD A,L
	3BA6 D9             EXX
	3BA7 BC             CP H
	3BA8 7D             LD A,L
	3BA9 D9             EXX
	3BAA 30 03          JR NC,NoUOverlap
	3BAC BC             CP H
	3BAD 38 37          JR C,UOverlap
.NoUOverlap:
    ;; E < D' && D > E' -> V Overlap
	3BAF 7B             LD A,E
	3BB0 D9             EXX
	3BB1 BA             CP D
	3BB2 7B             LD A,E
	3BB3 D9             EXX
	3BB4 30 03          JR NC,dpth_1
	3BB6 BA             CP D
	3BB7 38 64          JR C,VNoUOverlap
dpth_1
	3BB9 79             LD A,C
	3BBA D9             EXX
	3BBB B8             CP B
NoUVOverlap:
    ;; C < B' && B > C' -> Z Overlap
	3BBC 79             LD A,C
	3BBD D9             EXX
	3BBE 30 03          JR NC,NoUVZOverlap
	3BC0 B8             CP B
	3BC1 38 17          JR C,ZNoUVOverlap
.NoUVZOverlap:
    ;; No overlaps at all - simple depth comparison
    ;; HL = U + V + Z (lower coords)
	3BC3 7D             LD A,L
	3BC4 83             ADD A,E													HL = L + E + C
	3BC5 81             ADD A,C
	3BC6 6F             LD L,A
	3BC7 CE 00          ADC A,00
	3BC9 95             SUB L
	3BCA 67             LD H,A
	; DE = U' + V' + Z' (lower co-ords)
	3BCB D9             EXX
	3BCC 7D             LD A,L
	3BCD 83             ADD A,E
	3BCE 81             ADD A,C
	3BCF D9             EXX
	3BD0 5F             LD E,A
	3BD1 CE 00          ADC A,00
	3BD3 93             SUB E
	3BD4 57             LD D,A
	; Compare depths
	3BD5 ED 52          SBC HL,DE
	3BD7 3E FF          LD A,FF
	3BD9 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.ZNoUVOverlap:
    ;; Overlaps in Z, not U or V. In this case, we compare on U + V
	3BDA 7D             LD A,L
	3BDB 83             ADD A,E
	3BDC 6F             LD L,A
	3BDD D9             EXX
	3BDE 7D             LD A,L
	3BDF 83             ADD A,E
	3BE0 D9             EXX
	3BE1 BD             CP L
	3BE2 3F             CCF
	3BE3 3E FF          LD A,FF
	3BE5 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.UOverlap:
    ;; E < D' && D > E' -> V Overlap
	3BE6 7B             LD A,E
	3BE7 D9             EXX
	3BE8 BA             CP D
	3BE9 7B             LD A,E
	3BEA D9             EXX
	3BEB 30 03          JR NC,UNoVOverlap
	3BED BA             CP D
	3BEE 38 26          JR C,UVOverlap
.UNoVOverlap:
    ;; C < B' && B > C' -> Z Overlap
	3BF0 79             LD A,C
	3BF1 D9             EXX
	3BF2 B8             CP B
	3BF3 79             LD A,C
	3BF4 D9             EXX
	3BF5 30 03          JR NC,UNoVZOverlap
	3BF7 B8             CP B
	3BF8 38 15          JR C,UZNoVOverlap
.UNoVZOverlap:
    ;; Compare on Z  + V
	3BFA D9             EXX
	3BFB 83             ADD A,E
	3BFC D9             EXX
	3BFD 6F             LD L,A
	3BFE CE 00          ADC A,00
	3C00 95             SUB L
	3C01 67             LD H,A
	3C02 79             LD A,C
	3C03 83             ADD A,E
	3C04 5F             LD E,A
	3C05 CE 00          ADC A,00
	3C07 93             SUB E
	3C08 57             LD D,A
	3C09 ED 52          SBC HL,DE
	3C0B 3F             CCF
	3C0C 3E FF          LD A,FF
	3C0E C9             RET

;; -----------------------------------------------------------------------------------------------------------
.UZNoVOverlap:
    ;; Compare on V
	3C0F 7B             LD A,E
	3C10 D9             EXX
	3C11 BB             CP E
	3C12 D9             EXX
	3C13 3E 00          LD A,00
	3C15 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.UVOverlap:
    ;; Compare on Z
	3C16 79             LD A,C
	3C17 D9             EXX
	3C18 B9             CP C
	3C19 D9             EXX
	3C1A 3E 00          LD A,00
	3C1C C9             RET

;; -----------------------------------------------------------------------------------------------------------
.VNoUOverlap:
    ;; C < B' && B > C' -> Z Overlap
	3C1D 79             LD A,C
	3C1E D9             EXX
	3C1F B8             CP B
	3C20 79             LD A,C
	3C21 D9             EXX
	3C22 30 03          JR NC,VNoUZOverlap
	3C24 B8             CP B
	3C25 38 14          JR C,VZNoUOverlap
.VNoUZOverlap:
    ;; Compare on U + Z
	3C27 D9             EXX
	3C28 85             ADD A,L
	3C29 D9             EXX
	3C2A 5F             LD E,A
	3C2B CE 00          ADC A,00
	3C2D 93             SUB E
	3C2E 57             LD D,A
	3C2F 79             LD A,C
	3C30 85             ADD A,L
	3C31 6F             LD L,A
	3C32 CE 00          ADC A,00
	3C34 95             SUB L
	3C35 67             LD H,A
	3C36 ED 52          SBC HL,DE
	3C38 3E FF          LD A,FF
	3C3A C9             RET

;; -----------------------------------------------------------------------------------------------------------
.VZNoUOverlap:
    ;; Compare on U
	3C3B 7D             LD A,L
	3C3C D9             EXX
	3C3D BD             CP L
	3C3E D9             EXX
	3C3F 3E 00          LD A,00
	3C41 C9             RET

;; -----------------------------------------------------------------------------------------------------------
Walls_PanelBase:
	3C42 DATAWORD 00 00
Walls_PanelFlipsPtr:
	3C44 DATAWORD 00 00             										; Pointer to byte full of whether walls need to flip
Walls_ScreenMaxV:
	3C46 DATABYTE 00
Walls_ScreenMaxU:
	3C47 DATEBYTE 00
Walls_CornerX:
	3C48 DATABYTE 00
Walls_DoorZ:
	3C49 DATABYTE 00             											; Height of highest door.

;; -----------------------------------------------------------------------------------------------------------
;; Set the various variables used to work out the edges of the walls.
.StoreCorner:
	3C4A CD 82 3D       CALL GetCorner										BC = XY; HL points on BkgndData
	3C4D 79             LD A,C												C = Y
	3C4E D6 06          SUB 06												-6
	3C50 4F             LD C,A
	3C51 80             ADD A,B												B = X
	3C52 1F             RRA													div 2
	3C53 32 46 3C       LD (Walls_ScreenMaxV),A								Store (Y + X - 6) / 2
	3C56 78             LD A,B
	3C57 ED 44          NEG													-X ou 256-X
	3C59 81             ADD A,C												Y - X ou 256 - X + Y
	3C5A 1F             RRA													div 2
	3C5B 32 47 3C       LD (Walls_ScreenMaxU),A						 		Store 128 - ((X - Y) / 2)
	3C5E 78             LD A,B
	3C5F 32 48 3C       LD (Walls_CornerX),A								Store B in Walls_CornerX
	3C62 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Configure the walls.
;; Height of highest door in A.
.ConfigWalls:
	3C63 32 49 3C       LD (Walls_DoorZ),A									; door height
	3C66 CD 85 3C       CALL VWall
    ;; Skip if there's an extra room visible in the U dir.
	3C69 3A C0 1E       LD A,(Has_no_wall)
	3C6C E6 04          AND 04												; test bit 2 : wall U side (ne)
	3C6E C0             RET NZ												; if there is a wall, leave (else can see further into next room
	;; Put the wall mask in B' and stash the reflection flag at smc_OWFlag.
    ;; Step size in DE, direction extent in A.
	3C6F 06 04          LD B,04
	3C71 D9             EXX
	3C72 3E 80          LD A,80
	3C74 32 11 3D       LD (smc_OWFlag+1),A									self mode code, value of "OR ..."
	3C77 CD 82 3D       CALL GetCorner
	3C7A 11 02 00       LD DE,0002
	3C7D FD 7E FF       LD A,(IY+FF)										(IY-$01) ; MaxV
	3C80 FD 96 FD       SUB (IY+FD)											(IY-$03) ; MinV
	3C83 18 1B          JR OneWall

;; Draw wall parallel to U axis.
.VWall:
    ;; Skip if there's an extra room in the V direction.
	3C85 3A C0 1E       LD A,(Has_no_wall)
	3C88 E6 08          AND 08
	3C8A C0             RET NZ
	; Put the wall mask in B' and stash the reflection flag at smc_OWFlag.
    ;; Step size in DE, direction extent in A.
	3C8B 06 08          LD B,08
	3C8D D9             EXX
	3C8E AF             XOR A
	3C8F 32 11 3D       LD (smc_OWFlag+1),A									self mode code, value of "OR ..."
	3C92 CD 82 3D       CALL GetCorner
	3C95 2D             DEC L
	3C96 2D             DEC L
	3C97 11 FE FF       LD DE,FFFE											-2
	3C9A FD 7E FE       LD A,(IY+FE)										(IY-$02) ; MaxU
	3C9D FD 96 FC       SUB (IY+FC)											(IY-$04)   ; MinU
;; Room extent in A, movement step in DE, BkgndData pointer in HL, X/Y in B/C
;; The flag for this wall in B'
.OneWall:
    ;; Divide wall extent by 16 (one panel?)
	3CA0 1F             RRA
	3CA1 1F             RRA
	3CA2 1F             RRA
	3CA3 1F             RRA
	3CA4 E6 0F          AND 0F
	;; Move BkgndData pointer to IX.
	3CA6 E5             PUSH HL
	3CA7 DD E1          POP IX
	3CA9 D9             EXX
	;; Updated extent in C, check if this wall has a door.
	3CAA 4F             LD C,A
	3CAB 3A C1 1E       LD A,(Has_Door)										Has_Door
	3CAE A0             AND B
	3CAF FE 01          CP 01
	;; Carry set means no door. Stash it in F'
	3CB1 08             EX AF,AF
	3CB2 3A BF 1E       LD A,(WorldId)										which world? (for panels selection)
	3CB5 47             LD B,A
	;; Put PanelFlips + WorldId into Walls_PanelFlipsPtr.
	3CB6 C6 D8          ADD A,D8											(PanelFlips & $FF)
	3CB8 6F             LD L,A
	3CB9 CE 70          ADC A,70											(PanelFlips >> 8)	; #70D8+offset
	3CBB 95             SUB L
	3CBC 67             LD H,A
	3CBD 22 44 3C       LD (Walls_PanelFlipsPtr),HL
	;; We use the FetchData mechanism to unpack the Panel_WorldData. Set it up.
	3CC0 78             LD A,B
	3CC1 87             ADD A,A
	3CC2 47             LD B,A												; B updated to 2x
	3CC3 87             ADD A,A
	3CC4 87             ADD A,A												; A is 8x
	3CC5 C6 A9          ADD A,A9											+((Panel_WorldData - 1) & $FF)
	3CC7 6F             LD L,A
	3CC8 CE 3D          ADC A,3D											+((Panel_WorldData - 1) >> 8)	; #3DA9+offset
	3CCA 95             SUB L
	3CCB 67             LD H,A												; HL is Panel_WorldData - 1 + 8xWorldId
	3CCC 22 AB 1E       LD (DataPtr),HL
	3CCF 3E 80          LD A,80
	3CD1 32 AD 1E       LD (CurrData),A
	;; Update Walls_PanelBase
	3CD4 3E 9A          LD A,9A												PanelsBaseAddr & $FF
	3CD6 80             ADD A,B
	3CD7 6F             LD L,A
	3CD8 CE 3D          ADC A,3D											PanelsBaseAddr >> 8			; #3D9A
	3CDA 95             SUB L
	3CDB 67             LD H,A												; HL is PanelsBaseAddr + 2 x WorldId
	3CDC 7E             LD A,(HL)
	3CDD 23             INC HL
	3CDE 66             LD H,(HL)
	3CDF 6F             LD L,A
	3CE0 22 42 3C       LD (Walls_PanelBase),HL								; Set the panel codes for the current world.
	3CE3 3E FF          LD A,FF
	; Recover the no door flag, stick the extent in A, push A and flag.
	3CE5 08             EX AF,AF
	3CE6 79             LD A,C
	3CE7 F5             PUSH AF
	;; Find the location of the panel info we care about.
    ;; Extent = 4 -> B = $01
	3CE8 D6 04          SUB 04
	3CEA 06 01          LD B,01
	3CEC 28 0C          JR Z,owctd_1
	;; Extent = 5 -> B = $0F
	3CEE 06 0F          LD B,0F
	3CF0 3C             INC A
	3CF1 28 07          JR Z,owctd_1
	;; Extent = 6 -> B = $19
	3CF3 06 19          LD B,19
	3CF5 3C             INC A
	3CF6 28 02          JR Z,owctd_1
	; Otherwise, B = $1F
	3CF8 06 1F          LD B,1F
owctd_1:
	3CFA F1             POP AF
	3CFB 38 06          JR C,owctd_2										; No door? A' is $FF and we jump.
	;; We have a door
	3CFD 79             LD A,C
	3CFE 87             ADD A,A
	3CFF 80             ADD A,B
	3D00 47             LD B,A												; Add 2xC to B
	3D01 79             LD A,C
	3D02 08             EX AF,AF											; And put C (extent) in A'
	;; Skip B entries, to get the panels we want.
owctd_2:
	3D03 CD 7A 3D       CALL FetchData2b
	3D06 10 FB          DJNZ owctd_2
	; Put 2x extent in B.
	3D08 41             LD B,C
	3D09 CB 20          SLA B
	;; Then enter the wall-panel-processing loop.
.OWPanel:
	3D0B 08             EX AF,AF
	; Loop through A panels, then hit OWDoor.
	3D0C 3D             DEC A
	3D0D 28 32          JR Z,OWDoor
	;; Otherwise update entries in BkgndData.
	3D0F 08             EX AF,AF
.smc_OWFlag:
	3D10 F6 00         	OR 00
	;;3D11 DATABYTE 00														self-modifying code at 3D32, 3D51, 3C74, 3C8F adds a flip if needed.
	3D12 DD 77 01       LD (IX+01),A										; Set the wall-panel sprite
	3D15 D9             EXX
	3D16 79             LD A,C
	3D17 C6 08          ADD A,08
	3D19 DD 71 00       LD (IX+00),C										; Y start of wall (0 = clear)
	3D1C 4F             LD C,A
	3D1D DD 19          ADD IX,DE											; Move to next panel (L or R)
	3D1F D9             EXX
	3D20 CD 7A 3D       CALL FetchData2b
.OWPanelLoop:
	3D23 10 E6          DJNZ OWPanel
	3D25 D9             EXX
	3D26 DD E5          PUSH IX
	3D28 E1             POP HL
	3D29 7D             LD A,L
	3D2A FE 40          CP 40
	3D2C D0             RET NC
	; If last entry is not clear, return
	3D2D DD 7E 00       LD A,(IX+00)
	3D30 A7             AND A
	3D31 C0             RET NZ
	; If it is, add some Pillar.
	3D32 3A 11 3D       LD A,(smc_OWFlag+1)									read value of "OR ..." ; self mod code
	3D35 F6 05          OR 05
	3D37 DD 77 01       LD (IX+01),A
	3D3A 79             LD A,C
	3D3B D6 10          SUB 10
	3D3D DD 77 00       LD (IX+00),A
	3D40 C9             RET

.OWDoor:
	3D41 D9             EXX
	3D42 3A 49 3C       LD A,(Walls_DoorZ)									DoorZ
	3D45 A7             AND A
	3D46 79             LD A,C
	3D47 28 03          JR Z,br_3D4C
	3D49 C6 10          ADD A,10
	3D4B 4F             LD C,A
br_3D4C
	3D4C D6 10          SUB 10
	3D4E DD 77 00       LD (IX+00),A										; Set height.
	3D51 3A 11 3D       LD A,(smc_OWFlag+1)									read value of "OR ..." ; self mod
	3D54 F6 04          OR 04
	3D56 DD 77 01       LD (IX+01),A										; Set wall to blank.
	3D59 DD 19          ADD IX,DE
	3D5B DD 77 01       LD (IX+01),A										; Ditto next slot.
	3D5E 79             LD A,C
	3D5F D6 08          SUB 08
	3D61 DD 77 00       LD (IX+00),A										; And lower for the next slot.
	3D64 C6 18          ADD A,18
	3D66 4F             LD C,A
	3D67 3A 49 3C       LD A,(Walls_DoorZ)									DoorZ
	3D6A A7             AND A
	3D6B 28 04          JR Z,br_3D71
	3D6D 79             LD A,C
	3D6E D6 10          SUB 10
	3D70 4F             LD C,A
br_3D71
	3D71 DD 19          ADD IX,DE
	3D73 3E FF          LD A,FF
	3D75 08             EX AF,AF
	3D76 D9             EXX
	3D77 05             DEC B
	3D78 18 A9          JR OWPanelLoop

;; Fetch 2 bits from data in CurrData, returned in A
;; CurrData and DataPtr updated as needed
.FetchData2b:
	3D7A C5             PUSH BC
	3D7B 06 02          LD B,02												number of bit to fetch from CurrData
	3D7D CD B2 22       CALL FetchData										fetch 2 bits in A
	3D80 C1             POP BC
	3D81 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Gets values associated with the far back corner of the screen.
;; IY must point just after Max_min_UV_Table. (IY=Max_min_UV_Table+4)
;; Returns X in B, Y in C, BkgndData pointer in HL
.GetCorner:
    3D82 FD 7E FE       LD A,(IY+FE)										; IY-$02 = Max_min_UV_Table+2 = MaxU
	3D85 57             LD D,A
	3D86 FD 5E FF       LD E,(IY+FF)										; IY-$01 = Max_min_UV_Table+3 = MaxV ; DE = MaxU;MaxV
	3D89 93             SUB E												; A = difference between those 2 values
	3D8A C6 80          ADD A,80
	3D8C 47             LD B,A												; B = #80 + (MaxU - MaxV) = X coord
	3D8D 1F             RRA
	3D8E 1F             RRA													A = B/4
	3D8F E6 3E          AND 3E												align on even value (word align)
	3D91 6F             LD L,A												L can be #20 to #3E
	3D92 26 6A          LD H,6A												H = BkgndData >> 8; HL = BkgndData buffer word address
	3D94 3E 07          LD A,07
	3D96 93             SUB E
	3D97 92             SUB D												7 - (MaxV + MaxU)
	3D98 4F             LD C,A												return that value in C = Y coord
	3D99 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This table returns a pointer on the base wall panel for the current
;; world. From that base value, the Panel_WorldData will add an offset
;; to pick the wall panel we want for each part of the wall.
.PanelsBaseAddr:									; panel images base addr
	3D9A DATAWORD F0 70								; img_wall_deco + $70 * 0   ; 70F0 Blacktooth
	3D9C DATAWORD 90 73								; img_wall_deco + $70 * 3   ; 7390 Market
	3D9E DATAWORD 30 76								; img_wall_deco + $70 * 6   ; 7630 Egyptus
	3DA0 DATAWORD F0 77								; img_wall_deco + $70 * 8   ; 77F0 Penitentiary
	3DA2 DATAWORD B0 79								; img_wall_deco + $70 * 10  ; 79B0 Moon base
	3DA4 DATAWORD 30 7D								; img_wall_deco + $70 * 14  ; 7D30 Book world
	3DA6 DATAWORD F0 7E								; img_wall_deco + $70 * 16  ; 7EF0 Safari
	3DA8 DATAWORD 90 81								; img_wall_deco + $70 * 19  ; 8190 Prison

;; -----------------------------------------------------------------------------------------------------------
;; Used when Wall building.
;; These data consists of packed 2-bit values to choose the panel sprite
;; to pick for each part of the wall. It is essentially an index to add
;; to PanelsBaseAddr
.Panel_WorldData:
	3DAA DATABYTE 46 91 65 94 A1 69 69 AA    		; 1 0 1 2 2 1 0 1 ...  Blacktooth
	3DB2 DATABYTE 49 24 51 49 12 44 92 A4    		; 1 0 2 1 0 2 1 0 ...  Market
	3DBA DATABYTE 04 10 10 41 04 00 44 00    		; 0 0 1 0 0 1 0 0 ...  Egyptus
	3DC2 DATABYTE 04 10 10 41 04 00 10 00    		; 0 0 1 0 0 1 0 0 ...  Penitentiary
	3DCA DATABYTE 4E 31 B4 E7 4E 42 E4 99    		; 1 0 3 2 0 3 0 1 ...  Moon base
	3DD2 DATABYTE 45 51 50 51 54 55 55 55    		; 1 0 1 1 1 1 0 1 ...  Book world
	3DDA DATABYTE 64 19 65 11 A4 41 28 55    		; 1 2 1 0 0 1 2 1 ...  Safari
	3DE2 DATABYTE 00 00 00 00 00 00 00 00	 		; in the Prison we always use the same wall panel 0

;; -----------------------------------------------------------------------------------------------------------
;; Bit mask of worlds saved (5 bits : "1" means got crown for corresponding world).
;; This will be used to count how many worlds have been saved.
.saved_World_Mask:
	3DEA DATABYTE 00

;; -----------------------------------------------------------------------------------------------------------
;; Special collectible items.
;; The first word is the little-endian roomID, the next word is the little-endian
;; representation of "UVY + SpriteID". Sprite ID is the index in SpecialSprites.
;; Note: the first byte (room id low byte), will be added "1" (bit0 set) when
;; the item has been picked up, so can no longer be found during search when
;; building the room.
;; There are 47 special items in ths table. Adding the victoryRoom_Crowns 5 crowns
;; to this, it reaches 52 (#34) special objects.
.tab_Specials_collectible:
	;; <roomID word little-endian> <low byte : Z|SPR#> <high byte : UV> x 47
	3DEB DATAWORD 70 14 00 72						; speId 0 : room id 1470 : U,V,Z = 7,2,0 sprite Id 0 in SpecialSprites = SPR_PURSE
	3DEF DATAWORD 60 30 01 40
	3DF3 DATAWORD B0 2E 09 34
	3DF7 DATAWORD B0 00 1A 00
	3DFB DATAWORD F0 9A 0B 70
	3DFF DATAWORD 40 A7 1C 44
	3E03 DATAWORD 30 37 7D 37
	3E07 DATAWORD 70 15 68 34
	3E0B DATAWORD 60 89 48 47
	3E0F DATAWORD 60 C5 68 76
	3E13 DATAWORD 80 1B 68 76
	3E17 DATAWORD D0 BC 28 35
	3E1B DATAWORD D0 1C 28 71
	3E1F DATAWORD F0 87 38 74
	3E23 DATAWORD 20 FB 28 71
	3E27 DATAWORD 60 31 48 05
	3E2B DATAWORD C0 E2 38 54
	3E2F DATAWORD 20 69 68 07
	3E33 DATAWORD 60 52 62 77
	3E37 DATAWORD 60 47 72 27
	3E3B DATAWORD C0 E3 42 07
	3E3F DATAWORD F0 63 12 70
	3E43 DATAWORD 20 AA 22 05
	3E47 DATAWORD 30 6C 22 46
	3E4B DATAWORD 60 47 73 57
	3E4F DATAWORD 80 FA 63 67
	3E53 DATAWORD F0 70 13 60
	3E57 DATAWORD 10 7B 73 31
	3E5B DATAWORD 60 64 74 70
	3E5F DATAWORD 80 1A 44 45
	3E63 DATAWORD F0 46 74 74
	3E67 DATAWORD 60 C5 66 74
	3E6B DATAWORD 70 98 76 00
	3E6F DATAWORD 00 32 76 50
	3E73 DATAWORD 80 29 76 40
	3E77 DATAWORD A0 E0 16 40
	3E7B DATAWORD A0 0F 66 47
	3E7F DATAWORD B0 03 26 44
	3E83 DATAWORD F0 83 36 17
	3E87 DATAWORD 40 8A 06 06						; speID 39 roomID #8A40 : Sprite6 in SpecialSprites = BUNNY; Initial Head's Room
	3E8B DATAWORD 20 99 76 14
	3E8F DATAWORD 60 C5 65 75
	3E93 DATAWORD 60 77 75 44
	3E97 DATAWORD 00 36 75 66
	3E9B DATAWORD A0 FE 75 22
	3E9F DATAWORD F0 42 65 61
	3EA3 DATAWORD 20 AE 75 04						; speId 46

;; -----------------------------------------------------------------------------------------------------------
;; This is used when drawing the Victory Room to show (or not) a crown
;; corresponding to the saved worlds.
;; Therfore, the room ID is always #8D30 (victory room ID). However, the bit0
;; of the roomID will be updated by AddSavedCrowns_and_SpecialItems depending on
;; if the corresponding world has been saved (0) or not (1).
;; If not saved, roomID bit0 will therfore be '1' so that it is not found
;; during the search in Find_Specials (hence not displayed in victory room).
;; Second data word is the little-endian representation of UVZ+SpriteCode.
;; The SpriteCode always is #E so from SpecialSprites+#E we get SPR_CROWN (#2F).
;; Also note that this table is part of the tab_Specials_collectible table, hence
;; the first item below (Egyptus Crown in Victory room), is the special item n°47
;; because Ids 0 to 46 are in the tab_Specials_collectible table.
.victoryRoom_Crowns:
	;; <roomID word little-endian> <low byte : Z|SPR#> <high byte : UV>
	3EA7 DATAWORD 30 8D 7E 47				; speid47 : Egyptus            : 477E = U=4, V=7, Z=7, SPR_CROWN
	3EAB DATAWORD 30 8D 6E 17				; speid48 : Penitentiary       : 176E = U=1, V=7, Z=6, SPR_CROWN
	3EAF DATAWORD 30 8D 7E 07				; speid49 : Safari             : 077E = U=0, V=7, Z=7, SPR_CROWN
	3EB3 DATAWORD 30 8D 6E 37				; speid50 : Book World         : 376E = U=3, V=7, Z=6, SPR_CROWN
	3EB7 DATAWORD 30 8D 3E 27				; speid51 : BlackTooth Emperor : 273E = U=2, V=7, Z=3, SPR_CROWN

;; -----------------------------------------------------------------------------------------------------------
;; These are the sprites ID associated with special collectible objects.
;; e.g. Special obj Id #02 is "Donuts"
.SpecialSprites:
	3EBB DATABYTE 27 28 29 2A           	; SPR_PURSE, SPR_HOOTER, SPR_DONUTS, SPR_BUNNY (Speed)
	3EBF DATABYTE 2A 2A 2A 00      			; SPR_BUNNY (Spring), SPR_BUNNY (invuln), SPR_BUNNY (lives), 0
	3EC3 DATABYTE 86 2F 2F 2F				; ANIM_FISH, SPR_CROWN (Egyptus), SPR_CROWN (Penitentiary), SPR_CROWN (Safari)
	3EC7 DATABYTE 2F 2F 2F					; SPR_CROWN (book world), SPR_CROWN (emperor), SPR_CROWN (victory room)

;; -----------------------------------------------------------------------------------------------------------
;; Looking for the room Id in the special items table and point HL
;; on the special item in it
;; 2 Functions:
;;  * Find_Specials_current
;;  * Find_Specials : this one will need the room ID in BC.
;; Output: Found:     Z=1, Carry=0 ; HL pointing on 2nb byte of object in tab_Specials_collectible
;;         Not Found: Z=0; Carry=1
.Find_Specials_current:
	3ECA ED 4B 0E 01    LD BC,(current_Room_ID)								; BC = current_Room_ID
.Find_Specials:																; if branching directly here BC must have the roomID we want
	3ECE 21 EB 3D       LD HL,tab_Specials_collectible
	3ED1 1E 34          LD E,34												; number of special items (#34=52) in tab_Specials_collectible+victoryRoom_Crowns tables
findspec_loop:
	3ED3 79             LD A,C												; low byte room ID
	3ED4 BE             CP (HL)												; compare byte in table with roomid we are lloking for
	3ED5 23             INC HL												; next byte
	3ED6 20 03          JR NZ,FindSpecCont									; no match, skip to FindSpecCont, else:
	3ED8 78             LD A,B												; low byte matched so match the high byte room id part
	3ED9 BE             CP (HL)												; compare
	3EDA C8             RET Z												; Found! Ret Z set Carry reset
.FindSpecCont:																; else not yet found
	3EDB 23             INC HL
	3EDC 23             INC HL
	3EDD 23             INC HL												; skip 3 bytes to next room ID in table
	3EDE 1D             DEC E												; dec E
	3EDF 20 F2          JR NZ,findspec_loop									; if E not 0, loop, else:
	3EE1 1D             DEC E												; Nothing found; E=FF, Z = reset, Carry = set
special_found_end_2:
	3EE2 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Takes a pointer in HL, increase it, and extracts the nibbles in E, D, B and C.
;; RLD : if A = 0000aaaa, (HL) = hhhhllll, then after RLD we have:
;;          A = 0000hhhh, (HL) = llllaaaa
.GetNibbles:
	3EE3 23             INC HL
	3EE4 AF             XOR A
	3EE5 ED 6F          RLD
	3EE7 5F             LD E,A												; E gets high 4 bits of *(HL+1).
	3EE8 ED 6F          RLD
	3EEA 57             LD D,A     											; D gets next 4 bits of *(HL+1).
	3EEB ED 6F          RLD
	3EED 23             INC HL
	3EEE ED 6F          RLD
	3EF0 47             LD B,A		    									; B gets high 4 bits of *(HL+2).
	3EF1 ED 6F          RLD
	3EF3 4F             LD C,A	     										; C gets next 4 bits of *(HL+2).
	3EF4 ED 6F          RLD
	3EF6 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This updates which of the 5 crowns will be shown in the victory room
;; from the saved_World_Mask value.
.AddSavedCrowns_and_SpecialItems:
	3EF7 C5             PUSH BC												; save curr room_ID
	3EF8 21 A7 3E       LD HL,victoryRoom_Crowns							; point on the 5 crowns in the victory room
	3EFB 3A EA 3D       LD A,(saved_World_Mask)								; get saved_World_Mask
	3EFE 2F             CPL													; invert all bits of A (so we get 0=saved=match, and 1=not-saved=no-match)
	3EFF 06 05          LD B,05												; 5 crowns
	3F01 11 04 00       LD DE,0004											; 4 bytes per entry in the victoryRoom_Crowns table
addcrowns_loop:
	3F04 CB 1E          RR (HL)												; This loop replaces the bit 0 of (HL) n°i (i 0 to 4) [= low byte of room ID in the crown search table]....
	3F06 1F             RRA													; ...with the bit n°i in A (saved world (complement))...
	3F07 CB 16          RL (HL)												; ...to indicate if we saved the corresponding world (currbit=0, will match during search in victoryRoom_Crowns table)
	3F09 19             ADD HL,DE											; ...or if we did not save it (currbit=1 will no longer match during search)
	3F0A 10 F8          DJNZ addcrowns_loop									; ...so that, in the victory room, only the saved worlds crowns will be shown.
	3F0C C1             POP BC												; When the 5 worlds have been updated, restore curr room id
	3F0D CD CE 3E       CALL Find_Specials									; Add special items in the room; if found HL points on 2nd byte in tab_Specials_collectible
addspe_loop:
	3F10 C0             RET NZ												; RET if not found, else:
special_found:
	3F11 E5             PUSH HL
	3F12 D5             PUSH DE
	3F13 C5             PUSH BC												; Save everything (so we can relaunch a search if multiple special items in the room)
	3F14 FD E5          PUSH IY
	3F16 CD E3 3E       CALL GetNibbles										; Fills in E, D from (HL+1) and B, C from (HL+2); HL will be incremented by 2 ; since HL was pointing on 2nd byte of object in tab_Specials_collectible, it gets E = Z, D = SPR, B = U, C = V
	3F19 FD 21 98 1E    LD IY,TmpObj_variables
	3F1D 7A             LD A,D												; Special Sprite ID in D ; (E = Z, D = SPR, B = U, C = V)
	3F1E FE 0E          CP 0E												; 0E is the Victory room SPR_CROWN sprite id in SpecialSprites, other special sprites are Purse, Hooter, Donut tray, Fish, Bunnies and World crowns. Note that the worlds crowns are not the victory room crowns.
	3F20 3E 60          LD A,60
	3F22 20 01          JR NZ,br_3F25										; if Victory room Crown then O_FLAGS = 0, else O_FLAGS = #60
	3F24 AF             XOR A
br_3F25
	3F25 FD 77 04       LD (IY+O_FLAGS),A            						; Set flags
	3F28 FD 72 11       LD (IY+O_SPECIAL),D        							; Set special item sprite index in SpecialSprites.
	3F2B FD 36 0A 1A    LD (IY+O_FUNC),1A      								; Set the object function OBJFN_26
	;; Look up D in SpecialSprites to get a sprite id, and set it.
	3F2F 7A             LD A,D												; index in SpecialSprites
	3F30 C6 BB          ADD A,BB											; SpecialSprites & FF
	3F32 6F             LD L,A
	3F33 CE 3E          ADC A,3E											; SpecialSprites >> 8  ; 3EBB+offset
	3F35 95             SUB L
	3F36 67             LD H,A												; HL = pointer on sprite code in SpecialSprites
	3F37 7E             LD A,(HL)											; A = Sprite code for special item
	3F38 C5             PUSH BC												; save UVZ
	3F39 D5             PUSH DE
	3F3A CD 4E 37       CALL SetObjSprite
	3F3D D1             POP DE
	3F3E C1             POP BC												; restore UVZ, BC = UV
	3F3F FD E1          POP IY
	3F41 7B             LD A,E												; A = Z
	3F42 CD 6E 22       CALL SetTmpObjUVZ
	3F45 CD CC 20       CALL AddObjOpt

	3F48 C1             POP BC
	3F49 D1             POP DE												; Restore state and carry on.
	3F4A E1             POP HL
	3F4B CD DB 3E       CALL FindSpecCont
	3F4E 18 C0          JR addspe_loop

;; -----------------------------------------------------------------------------------------------------------
; Reset the "collected" flag (bit0) on all the specials.
.ResetSpecials:
	3F50 21 EB 3D       LD HL,tab_Specials_collectible						; in special collectible table
	3F53 11 04 00       LD DE,0004											; every 4 bytes in the table is the low byte for roomID
	3F56 06 34          LD B,34												; #34=52 special obj
rstspe_loop:																; when the item was picked up, the bit0 was set (so we could not pick it up again)
	3F58 CB 86          RES 0,(HL)											; so reset it to reinit it
	3F5A 19             ADD HL,DE
	3F5B 10 FB          DJNZ rstspe_loop									; and do it for all 52 special objects
	3F5D C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Get a special item. Id in A
.GetSpecial:
	3F5E 57             LD D,A												; store special we want in D
	3F5F CD CA 3E       CALL Find_Specials_current							; Find Specials in current_Room_ID (HL points on 2bd byte of object in tab_Specials_collectible)
getspe_1:
	3F62 C0             RET NZ												; leave if not found, else:
	3F63 23             INC HL												; point on special object <low byte : Z|SPR#>  (<high byte : UV)
	3F64 7E             LD A,(HL)											; get special obj value
	3F65 2B             DEC HL												; this is just to realign HL if we loop
	3F66 E6 0F          AND 0F												; only look at bits [3:0] : Sprite ID in Special items
	3F68 BA             CP D												; compare witch the one we want
	3F69 28 05          JR Z,special_found									; jump special_found if found, else:
	3F6B CD DB 3E       CALL FindSpecCont									; not the one we want, go to the next items until "00"
	3F6E 18 F2          JR getspe_1											; loop

special_found:
	3F70 2B             DEC HL												; point back on room ID in table
	3F71 CB C6          SET 0,(HL)											; set bit 0 of room ID low byte; so this item is no longer available (we picked it up already)
	3F73 87             ADD A,A												; *2 (word align)
	3F74 C6 89          ADD A,89											; SpecialFns low byte
	3F76 6F             LD L,A
	3F77 CE 3F          ADC A,3F											; SpecialFns high byte : #3F89 + special obj offset
	3F79 95             SUB L
	3F7A 67             LD H,A
	3F7B 5E             LD E,(HL)
	3F7C 23             INC HL
	3F7D 66             LD H,(HL)
	3F7E 6B             LD L,E												; get in HL the addr of the special function from SpecialFns table
	3F7F DD 21 84 3F    LD IX,special_found_end_1							; Set IX to the continuation point after the JP (HL) is done
	3F83 E9             JP (HL)												; jump to the selected special function (PickUp2, Boost*, SaveContinue, GetCrown)

special_found_end_1:
	3F84 06 C5          LD B,C5												; Sound ID Dum-diddy-dum
	3F86 C3 91 0D       JP 	Play_Sound										; will RET

;; -----------------------------------------------------------------------------------------------------------
;; Array of functions pointers when picking up a special item.
;; For exemple when picking up the special item 'Donuts', we will
;; run the function at address "3FB4" : BoostDonuts.
.SpecialFns:
	3F89 DATAWORD A5 3F							; 0 : Purse PickUp2	3FA5
	3F8B DATAWORD A5 3F							; 1 : Hooter PickUp2	3FA5
	3F8D DATAWORD B4 3F							; 2 : Donuts BoostDonuts 3FB4
	3F8F DATAWORD C3 3F							; 3 : Bunny BoostSpeed 3FC3
	3F91 DATAWORD CC 3F							; 4 : Bunny BoostSpring 3FCC
	3F93 DATAWORD D8 3F							; 5 : Bunny BoostInvuln 3FD8
	3F95 DATAWORD DC 3F							; 6 : Bunny BoostLives 3FDC
	3F97 DATAWORD 00 00							; 7 :
	3F99 DATAWORD 25 40							; 8 : Fish SaveContinue 4025
	3F9B DATAWORD 14 40							; 9 : Crown GetCrown 4014
	3F9D DATAWORD 14 40							; #A : Crown GetCrown 4014
	3F9F DATAWORD 14 40							; #B : Crown GetCrown 4014
	3FA1 DATAWORD 14 40							; #C : Crown GetCrown 4014
	3FA3 DATAWORD 14 40							; #D : Crown GetCrown 4014 (Emperor)

;; -----------------------------------------------------------------------------------------------------------
;; Pickup Purse or Hooter, update Inventory and update HUD
;; PickUp2 : D has the bitnb for the item: Purse bit 0, Hooter bit 1
;; Pick_it_up : item bitnb in A (eg. bit 2 = donut tray)
.PickUp2:
	3FA5 7A             LD A,D												; item bir nb
.Pick_it_up:
	3FA6 21 7B 24       LD HL,Inventory										; point on Inventory
	3FA9 CD 39 41       CALL Set_bit_nb_A_in_content_HL						; add item bit to Inventory
	3FAC CD 9C 45       CALL Draw_Screen_Periphery							; update HUD
	3FAF 06 C2          LD B,C2												; Sound ID HornPipe
	3FB1 C3 91 0D       JP Play_Sound										; will RET

;; -----------------------------------------------------------------------------------------------------------
;; pick up a donut tray
.BoostDonuts:
	3FB4 3A 84 24       LD A,(selected_characters)							; get selected_characters
	3FB7 E6 02          AND 02												; test if Head
	3FB9 C8             RET Z												; if not Head, then leave
	3FBA 3E 06          LD A,06												; CNT_DONUTS
	3FBC CD F2 3F       CALL BoostCountPlus									; boost counter
	3FBF 3E 02          LD A,02												; bit2 in Inventory for pick-up a donuts tray
	3FC1 18 E3          JR Pick_it_up										; add it to inventory and update HUD

;; -----------------------------------------------------------------------------------------------------------
;; Pick up a Bunny. 4 types of Bunnies : lives, invulnerability, speed, extra jump.
.BoostSpeed:
	3FC3 3A 84 24       LD A,(selected_characters)							; get selected_characters
	3FC6 E6 02          AND 02												; test if Head
	3FC8 C8             RET Z												; if not Head, then leave
	3FC9 AF             XOR A												; code for CNT_SPEED
	3FCA 18 26          JR BoostCountPlus									; Boost!

.BoostSpring:
	3FCC 3A 84 24       LD A,(selected_characters)							; get selected_characters
	3FCF E6 01          AND 01												; test if Heels
	3FD1 C8             RET Z												; if not Heels, then leave
	3FD2 18 1E          JR BoostCountPlus									; A = 01, code for CNT_SPRING, boost

;; heels : c=2; a=b01 a=0 cy=1 a=2 push a ret
;; head : c=2 a=b10 a=1 cy=0 a=3 push a ret
;; both : c=2 a=b11 a=2 call boostcount (boost heels invul and refresh HUD) a=3 push a ret
.BoostInvuln2:
	3FD4 DD 21 E2 3E    LD IX,special_found_end_2							; the DoJumpIX will just RET
.BoostInvuln:
	3FD8 0E 02          LD C,02												; CNT_HEELS_INVULN
	3FDA 18 02          JR BoostMaybeDbl

.BoostLives:
	3FDC 0E 04          LD C,04												; CNT_HEELS_LIVES
;; Boosts both characters counts if they're joined. Only works for
;; invuln and lives.
.BoostMaybeDbl:
	3FDE 3A 84 24       LD A,(selected_characters)							; get selected_characters
	3FE1 FE 03          CP 03												; both Head and Heels?
	3FE3 28 06          JR Z,BoostCountDbl									; if yes, then increment both (invuln if coming from BoostInvuln or lives if coming from BoostLives) (BoostCountDbl), else:
	3FE5 1F             RRA													; bit Head in bit[0], bit Heels in Carry
	3FE6 E6 01          AND 01												; if Head increment, if Heels add 0
	3FE8 81             ADD A,C												; coming from BoostLives : either CNT_HEELS_LIVES or CNT_HEAD_LIVES ; coming from BoostInvuln : either CNT_HEELS_INVULN or CNT_HEAD_INVULN
	3FE9 18 07          JR BoostCountPlus									; boost

;; Head and Heels are joined : increment both counters
;; This can come from BoostLives (lives) or BoostInvuln (invuln)
.BoostCountDbl:
	3FEB 79             LD A,C												; counter for Heels
	3FEC F5             PUSH AF
	3FED CD F7 3F       CALL BoostCount										; boost
	3FF0 F1             POP AF
	3FF1 3C             INC A												; counter for Head
.BoostCountPlus:
	3FF2 F5             PUSH AF
	3FF3 CD B2 19       CALL DoJumpIX										; this does a JP (IX); coming from BoostInvuln2 it'll just RET (special_found_end_2), or a Sound+RET (special_found_end_1) if coming from a Special item function
	3FF6 F1             POP AF
.BoostCount:
	;; Boosts whichever count index is provided in A, and displays it.
	;; 0: speed, 1: spring, 2:Heels Invul, 3: Head Invul,
	;; 4:Heels Lives, 5:Head Lives, 6:Donuts
	3FF7 CD 78 41       CALL Get_Count_pointer								; HL=pointer on counter at index in A; output A=increment
	3FFA CD 66 41       CALL Boost_HLcontent_base10_clamp99 				; AddBCD clamped
.Show_Num:
	; Number to print in A, location in C.
	3FFD F5             PUSH AF
	3FFE C5             PUSH BC
	3FFF A7             AND A
	4000 3E 81          LD A,81												; color1 when printing 0
	4002 28 02          JR Z,fsnum_1										; was "0" else:
	4004 3E 83          LD A,83												; color3 if not 0
fsnum_1:
	4006 CD C2 4A       CALL Print_String									; Print new count on HUD
	4009 C1             POP BC
	400A 79             LD A,C
	400B C6 B1          ADD A,B1											; B1 = Ligthning ; Position indexed into array...
	400D CD C2 4A       CALL Print_String
	4010 F1             POP AF
	4011 C3 BF 4B       JP Print_2Digits_RightAligned						; print value in A, right aligned; will RET

;; -----------------------------------------------------------------------------------------------------------
;; Pick up a crown; WorldId in D
.GetCrown:
	4014 7A             LD A,D												; special item ID
	4015 D6 09          SUB 09												; in SpecialFns the GetCrown are items 9 to #E so align it at 0 (world nb)
	4017 21 EA 3D       LD HL,saved_World_Mask								; points on saved_World_Mask
	401A CD 39 41       CALL Set_bit_nb_A_in_content_HL						; set the bit N (N in A) in (HL) corresponding to the world we saved.
	401D 06 C1          LD B,C1												; Sound_ID #C1 = "Tada!"
	401F CD 91 0D       CALL Play_Sound										; play
	4022 C3 1D 45       JP Emperor_Screen_Cont								; display the "Emperor" screen if we got 5 crowns

;; -----------------------------------------------------------------------------------------------------------
;; Pick up a Fish (save points)
.SaveContinue:
	4025 06 C2          LD B,C2												; Sound_ID #C2 = Hornpipe
	4027 CD 91 0D       CALL Play_Sound
	402A CD 2A 41       CALL GetContinueData								; get current save array (18 bytes)
	402D DD 21 EB 3D    LD IX,tab_Specials_collectible
	4031 11 04 00       LD DE,0004
	4034 06 06          LD B,06
savecont_1:
	4036 36 80          LD (HL),80
savecont_2:
	4038 DD 7E 00       LD A,(IX+00)
	403B DD 19          ADD IX,DE
	403D 1F             RRA
	403E CB 1E          RR (HL)
	4040 30 F6          JR NC,savecont_2
	4042 23             INC HL
	4043 10 F1          DJNZ savecont_1
	4045 EB             EX DE,HL
	4046 21 94 41       LD HL,Save_point_value								Save point value (Continues)
	4049 34             INC (HL)											incr the number of active save point
	404A 21 84 24       LD HL,selected_characters							points on selected_characters
	404D 7E             LD A,(HL)											save selected char first byte
	404E ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	4050 21 80 24       LD HL,Characters_lives								point on Characters_lives
	4053 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	4055 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	4057 FE 03          CP 03
	4059 28 13          JR Z,SaveContinue_3
	405B 21 96 24       LD HL,2496											???
	405E BE             CP (HL)
	405F 20 0D          JR NZ,SaveContinue_3
	4061 21 31 BB       LD HL,BB31											save 4 bytes in buffer
	4064 01 04 00       LD BC,0004
	4067 ED B0          LDIR												repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	4069 21 10 BB       LD HL,Other_Character_state
	406C 18 0B          JR SaveContinue_4
.SaveContinue_3
	406E 21 92 24       LD HL,2492
	4071 01 04 00       LD BC,0004
	4074 ED B0          LDIR												repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	4076 21 0E 01       LD HL,current_Room_ID								point on current_Room_ID
.SaveContinue_4:
	4079 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	407B ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	407D 21 0E 01       LD HL,current_Room_ID								point on current_Room_ID
	4080 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	4082 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	4084 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.DoContinue:
	4085 21 94 41       LD HL,Save_point_value								Save point value
	4088 35             DEC (HL)											use a save point
	4089 CD 2A 41       CALL GetContinueData
	408C 7E             LD A,(HL)
	408D E6 03          AND 03
	408F 32 7B 24       LD (Inventory),A									update inventory
	4092 7E             LD A,(HL)
	4093 1F             RRA
	4094 1F             RRA
	4095 E6 1F          AND 1F
	4097 32 EA 3D       LD (saved_World_Mask),A								update saved_World_Mask
	409A E5             PUSH HL
	409B DD E1          POP IX
	409D 21 EB 3D       LD HL,tab_Specials_collectible
	40A0 11 04 00       LD DE,0004
	40A3 06 2F          LD B,2F
	40A5 CB 1E          RR (HL)
	40A7 18 0A          JR br_40B3

doco_loop:
	40A9 CB 1E          RR (HL)
	40AB DD CB 00 3E    SRL (IX+00)
	40AF 20 07          JR NZ,br_40B8
	40B1 DD 23          INC IX
br_40B3
	40B3 37             SCF
	40B4 DD CB 00 1E    RR (IX+00)
br_40B8
	40B8 CB 16          RL (HL)
	40BA 19             ADD HL,DE
	40BB 10 EC          DJNZ doco_loop
	40BD DD E5          PUSH IX
	40BF E1             POP HL
	40C0 23             INC HL
	40C1 11 84 24       LD DE,selected_characters							points on selected_characters
	40C4 7E             LD A,(HL)
	40C5 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	40C7 11 80 24       LD DE,Characters_lives								point on Characters_lives
	40CA ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	40CC ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	40CE 11 58 46       LD DE,access_new_room_code							point on access_new_room_code
	40D1 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	40D3 CB 47          BIT 0,A
	40D5 11 B5 24       LD DE,Heels_variables+O_U							??? Heels U?
	40D8 28 03          JR Z,br_40DD
	40DA 11 C7 24       LD DE,Head_variables+O_U							??? Head U?
br_40DD
	40DD 01 03 00       LD BC,0003
	40E0 ED B0          LDIR												repeat LD (DE),(HL); DE++, HL++, BC-- until BC=0
	40E2 11 0E 01       LD DE,current_Room_ID								point on current_Room_ID
	40E5 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	40E7 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	40E9 FE 03          CP 03
	40EB 28 16          JR Z,dconti_1
	40ED ED 4B 80 24    LD BC,(Characters_lives)							get Characters_lives
	40F1 05             DEC B
	40F2 FA 03 41       JP M,dconti_1
	40F5 0D             DEC C
	40F6 FA 03 41       JP M,dconti_1
	40F9 EE 03          XOR 03
	40FB 32 10 BB       LD (Other_Character_state),A
	40FE E5             PUSH HL
	40FF CD 22 23       CALL InitOtherChar
	4102 E1             POP HL
dconti_1:
	4103 11 0E 01       LD DE,current_Room_ID								point on current_Room_ID
	4106 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	4108 ED A0          LDI													do once : LD (DE),(HL); DE++, HL++, BC--
	410A ED 4B 0E 01    LD BC,(current_Room_ID)								get current_Room_ID
	410E CB C1          SET 0,C
	4110 CD CE 3E       CALL Find_Specials
	4113 CD E3 3E       CALL GetNibbles										Fills in E, D from (HL+1) and B, C from (HL+2); HL will be incremented by 2
	4116 7B             LD A,E
	4117 08             EX AF,AF
	4118 11 5E 42       LD DE,UVZ_coord_Set_UVZ
	411B 21 5B 42       LD HL,UVZ_origin
	411E CD 75 22       CALL Set_UVZ
	4121 3E 08          LD A,08
	4123 32 58 46       LD (access_new_room_code),A							update access_new_room_code
	4126 32 87 24       LD (Teleport_down_anim_length),A
	4129 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Output : HL points on the Continue_Data data for the Save point in Save_point_value
.GetContinueData:
	412A 3A 94 41       LD A,(Save_point_value)								; Continues Save point value
	412D 47             LD B,A
	412E 04             INC B												; get which save point we need to restore
	412F 21 83 41       LD HL,Continue_Data-#12								; Continue_Data (4195) - $12 (because it'll get added #12 just next)
	4132 11 12 00       LD DE,0012											; Character obj size
gcdta_loop:
	4135 19             ADD HL,DE											; (Continue_Data + #12) B times
	4136 10 FD          DJNZ gcdta_loop										; loop until HL points on the data
	4138 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This function will set a bit (bit number in A) in a byte pointed by HL, leaving the
;; other bits in (HL) untouched.
;; Input: A: the bit number to set
;;        HL: the pointer on the data byte where to set the bit.
.Set_bit_nb_A_in_content_HL:
	4139 47             LD B,A												; bit numbrer to set
	413A 04             INC B												; converted as number of rotations
	413B 3E 80          LD A,80												; start with wandering bit in bit7
fsbn_loop:
	413D 07             RLCA
	413E 10 FD          DJNZ fsbn_loop										; left rotate B times to put the 1 in bit n°A
	4140 B6             OR (HL)												; read value in (HL) and set a 1 in bit n°A
	4141 77             LD (HL),A											; write the result back in (HL)
	4142 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Decrement one of the core counters and re-display it.
;; Input : A can be: 0: speed, 1: spring, 2:Heels Invul, 3: Head Invul, 4:Heels Lives, 5:Head Lives, 6:Donuts
.Decrement_counter_and_display:
	4143 CD 78 41       CALL Get_Count_pointer								; HL=pointer on Counter corresponding to the index in A when calling; output A=increment
	4146 CD 6E 41       CALL Sub_1_HLcontent_base10_clamp0					; minus 1
	4149 C8             RET Z												; if was already 0, then leave with Z set, else:
	414A 7E             LD A,(HL)											; get new val after "minus 1"
	414B CD FD 3F       CALL Show_Num										; display it
	414E F6 FF          OR FF												; Ret with Z reset
	4150 C9             RET

;; -----------------------------------------------------------------------------------------------------------
; Re-prints all the Counters values on the HUD.
.PrintStatus:
	4151 3E B8          LD A,B8												; String code B8 = shield, spring, shield, lightning icons
	4153 CD C2 4A       CALL Print_String									; print icons
	4156 3E 07          LD A,07												; 7 Counters
prntstat_1:
	4158 F5             PUSH AF
	4159 3D             DEC A												; foreach counter starting at n° 6
	415A CD 78 41       CALL Get_Count_pointer								; HL = pointer on counter
	415D 7E             LD A,(HL)											; Counter value
	415E CD FD 3F       CALL Show_Num										; print value
	4161 F1             POP AF
	4162 3D             DEC A												; next counter
	4163 20 F3          JR NZ,prntstat_1									; loop counters id 6 to 0
	4165 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Increment the Counter pointer by HL with the increment value in A.
;; Output: Carry reset: counter incremented;
;;         Carry set: counter incremented and clamped at 99
.Boost_HLcontent_base10_clamp99:
	4166 86             ADD A,(HL)											; add selected increment to counter pointed by HL
	4167 27             DAA													; base10 adjust
	4168 77             LD (HL),A											; update value
	4169 D0             RET NC												; if not overflowed 99 leave with Carry reset, else:
	416A 3E 99          LD A,99												; clamp at 99
	416C 77             LD (HL),A											; update the value to reflect this
	416D C9             RET													; Ret with Carry set

;; -----------------------------------------------------------------------------------------------------------
;; Input: HL = pointer on the counter we want to decrement (by 1)
;; Output: A=0/Zset : was already 0 (clapmed at 0);
;;         A=-1/Zreset : value in (HL) decremented by 1
.Sub_1_HLcontent_base10_clamp0:
	416E 7E             LD A,(HL)											; get value
	416F A7             AND A												; test
	4170 C8             RET Z												; if 0, leave with A=0 and Z set, else:
	4171 D6 01          SUB 01												; minus 1
	4173 27             DAA													; base10 adjusted
	4174 77             LD (HL),A											; update counter value
	4175 F6 FF          OR FF												; leave with A=-1 and Z reset
	4177 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Given a count index in A, return the corresponding counter increment
;; and Counters address in HL.
;; Input: A can be 0: speed, 1: spring, 2:Heels Invul, 3: Head Invul, 4:Heels Lives, 5:Head Lives, 6:Donuts
;; If access_new_room_code is non-zero, return 3 as the increment. (dec invulnr counters by 3 if changing room ???)
;; Output: A increment value
;;        HL selected Counter pointer
;; Leaves the counter index in BC.
.Get_Count_pointer:
	4178 4F             LD C,A
	4179 06 00          LD B,00												; BC=index in A
	417B 21 8D 41       LD HL,CounterIncrements
	417E 09             ADD HL,BC											; add BC as offset of CounterIncrements table
	417F 3A 58 46       LD A,(access_new_room_code)							; get access_new_room_code
	4182 A7             AND A												; test it
	4183 7E             LD A,(HL)											; get counter increment value
	4184 28 02          JR Z,gcnt_1											; if access_new_room_code = 0 return counter increment from table
	4186 3E 03          LD A,03												; else return increment of 3 in A
gcnt_1:
	4188 21 7C 24       LD HL,Counters										; Points on start of array Counters
	418B 09             ADD HL,BC											; and add item offset, now points on the counter
	418C C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; These are the BCD values by how much the corresponding counters
;; are increased when picking up a Bunny or Donuts tray
CounterIncrements:
	418D DATABYTE 99        			; 00 CNT_SPEED			+99 time
	418E DATABYTE 10					; 01 CNT_SPRING			+10 amount
	418F DATABYTE 99       				; 02 CNT_HEELS_INVULN	+99 time
	4190 DATABYTE 99   					; 03 CNT_HEAD_INVULN	+99 time
	4191 DATABYTE 02    				; 04 CNT_HEELS_LIVES	+2 amount
	4192 DATABYTE 02   					; 05 CNT_HEAD_LIVES		+2 amount
	4193 DATABYTE 06					; 06 CNT_DONUTS			+6 amount

;; -----------------------------------------------------------------------------------------------------------
.Save_point_value:
	4194 DATABYTE 00				; (Continues) Save-point value (living fish comsumed)

;; A bunch of #12 (18) bytes arrays for save points
;; (up to 11 Living Fish are defined in the room data hence the 11*18 size)
;; The default values are probably "don't care"
.Continue_Data:
	;; Default Values do not matter, they'll be overwritten
	4195 DATABYTE FF 21 00 F8 CD 41 4D F6 01 D1 C9 CD 17 28 C3 34
	41A5 DATABYTE 6C CD
	41A7 DATABYTE 67 1D 21 DA 76 CD AD 6A CD 87 55 CD 67 1D CD 88
	41B7 DATABYTE 43 CD
	41B9 DATABYTE AF 5F 21 00 00 22 73 76 C3 67 1D 3A 74 76 B7 FA
	41C9 DATABYTE D6 4B
	41CB DATABYTE 3A 73 76 FE F3 DA D6 4B 37 C9 E6 7F E5 21 73 76
	41DB DATABYTE CD 00
	41DD DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	41ED DATABYTE 00 00
	41EF DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	41FF DATABYTE 00 00
	4201 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4211 DATABYTE 00 00
	4213 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4223 DATABYTE 00 00
	4225 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4235 DATABYTE 00 00
	4237 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4247 DATABYTE 00 00
	4249 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4259 DATABYTE 00 00

;; -----------------------------------------------------------------------------------------------------------
.UVZ_origin:
	425B DATABYTE 00 00 00

.UVZ_coord_Set_UVZ:
	425E DATABYTE 00 00 00

;; -----------------------------------------------------------------------------------------------------------
;; This will keep up with which of the 301 (#012D) rooms have been visited.
;; 301 rooms = 301 bits ; a 1 indicates a room in the Room_List1+Room_List2 lists has been visited.
;;    eg.: a 06 in 4266 (from start at #4261), indicates that the 42nd and 43rd rooms
;;         in the lists have been visited, which is Head's 1st and Heels 1st rooms!)
;;    eg.: a 01 at 4261 means that the first room in the list (room ID #1200) has been
;;         visited (and none of the 7 following ones in the list)
;; Note: 301 rooms should only required 38 bytes! (37*8=296 + 5 lsb bits in the 38th byte)
;; 		The way "countBits" is defined to count how many rooms have been visited
;; 		requires 301 bytes! (unless we modify the value at "43A2 01 2D 01 LD BC,012D"
;; 		with "43A2 01 26 00 LD BC,0026" to only check 38 bytes!). BUT countBits is used
;; 		by other parts of the code, so it does require a 301-byte RoomMask_buffer, off
;;      which most will always be "00".
.RoomMask_buffer:
	4261 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4271 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4281 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4291 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	42A1 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	42B1 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	42C1 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	42D1 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	42E1 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	42F1 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4301 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4311 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4321 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4331 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4341 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4351 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4361 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4371 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	4381 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00

;; -----------------------------------------------------------------------------------------------------------
;; This provides 3 bitpacked Counters, ie. they count how many "1"s are
;; set in the number of bytes defined whitin the functions:
;; PurseHooterCount:
;; 		* Clears donut bit from Inventory and then count number of items remaining.
;;        In other words, count the number of items owned in the list "Purse, Hooter".
;; SavedWorldCount:
;;		* Count how many of the 5 worlds we have saved.
;; RoomCount:
;;	    * Count how many of the 301 rooms we have visited.
;;        By starting the game, we automatically visit 2 rooms (even if we do not swop):
;;           Heels' 1st room and Head's first room.
;;           Indeed, it actually count how many rooms have been Build. Now, when the
;;           game starts, Heels' room is built to init Heels, then Head room is built
;;           and displayed.
;;        Note that the victory room counts for 2 because both are Built when entering
;;        the Victory room. This is because the main room does not have a far wall,
;;        therefore the next room is visible and displayed (even if we can never go in it
;;        as we cannot move in the Victory room!. This is also the case with any
;;        other room with no wall letting us see the next room.
;; Output: result in DE
.PurseHooterCount:
	438E 21 7B 24       LD HL,Inventory										; pointer on Inventory
	4391 CB 96          RES 2,(HL)											; Lose Donut tray (empty tray)
edo1:
	4393 D9             EXX
	4394 01 01 00       LD BC,0001											; will count the "1" bits in 1 byte (Inventory byte)
	4397 18 0C          JR countBits										; count how many bits are set in the item inventory (Purse+Hooter)

.SavedWorldCount:
	4399 21 EA 3D       LD HL,saved_World_Mask								; points on saved_World_Mask
	439C 18 F5          JR edo1												; count how many bits are set in the byte at saved_World_Mask

.RoomCount:
	439E 21 61 42       LD HL,RoomMask_buffer								; point on RoomMask_buffer
	43A1 D9             EXX
	;; Due to the way RoomMask_buffer is bitpacked we could set BC to
	;; 38 (#26) (RoomMask_buffer should always be null from the 39th byte.)
	43A2 01 2D 01       LD BC,012D											; BC=301 (nb max of bytes to check = rooms (although #0026 (38 bytes) should be fine; see the way RoomMask_buffer is bit packed)
.countBits:
	43A5 D9             EXX
	43A6 11 00 00       LD DE,0000											; init counter
	43A9 D9             EXX
cbi1:
	43AA D9             EXX
	43AB 4E             LD C,(HL)											; read bitmask (a bit to 1 = item owned, room visited or world saved)
	43AC 37             SCF													; filler Carry set
	43AD CB 11          RL C												; rotate left bitmask value leaving bit in Carry, old carry in bit0
cbi2:
	43AF 7B             LD A,E
	43B0 CE 00          ADC A,00											; add 1 if got a 1 leaving C
	43B2 27             DAA
	43B3 5F             LD E,A
	43B4 7A             LD A,D
	43B5 CE 00          ADC A,00											; DE will be BCD corrected immediately
	43B7 27             DAA
	43B8 57             LD D,A
	43B9 CB 21          SLA C												; get next bit
	43BB 20 F2          JR NZ,cbi2											; if rest of the byte is null, then leave, else loop upto 8 bits
	43BD 23             INC HL												; next byte
	43BE D9             EXX
	43BF 0B             DEC BC												; do it for all rooms
	43C0 78             LD A,B
	43C1 B1             OR C
	43C2 20 E6          JR NZ,cbi1											; untils last room
	43C4 D9             EXX
	43C5 C9             RET													; result in DE

;; -----------------------------------------------------------------------------------------------------------
.Erase_visited_room:
	43C6 21 61 42       LD HL,RoomMask_buffer
	43C9 01 2D 01       LD BC,012D											; Erase #012D bytes from addr #4261 (301 rooms)
	43CC C3 67 24       JP Erase_forward_Block_RAM							; continue on Erase_forward_Block_RAM (will have a RET)

;; -----------------------------------------------------------------------------------------------------------
;; Gets the score and puts it in HL (BCD).
;; Note that a "0" will be appended to make the score 10x when displayed.
;; The score in HL (BCD) is:
;;     16 * visited rooms (up to 301)
;;     + 500 if purse
;;     + 500 if hooter
;;     + 636 * crowns (up to 5)
;;     + 501 if Head is in the Victory room
;;     + 501 if Heels is in the Victory room (make sure to enter the last room together!)
;;    That's 99980 max pts!
.GetScore:
	43CF CD 5E 01       CALL Sub_Check_Victory_Room							; Zero set if Victory room reached.
	43D2 F5             PUSH AF												; save flags
	43D3 CD 9E 43       CALL RoomCount										; Count number of visited rooms in DE
	43D6 F1             POP AF												; restore flags
	43D7 21 00 00       LD HL,0000											; score = 0
	43DA 20 0C          JR NZ,gs_1											; if not in victory room, skip to gs_1, else:
	43DC 21 01 05       LD HL,0501											; points = 501 BCD
	43DF 3A 85 24       LD A,(both_in_same_room)							; get both_in_same_room
	43E2 A7             AND A												; test
	43E3 28 03          JR Z,gs_1											; if only one reached the end, skip, else:
	43E5 21 02 10       LD HL,1002											; points = 1002 NCD
gs_1:
	43E8 01 10 00       LD BC,0010											; BC= 16 (#10 not BCD)
	43EB CD 01 44       CALL MulAccBCD										; HL = DE (BCD) * BC
	43EE E5             PUSH HL
	43EF CD 8E 43       CALL PurseHooterCount								; Count Purse and Hooter in DE
	43F2 E1             POP HL
	43F3 01 F4 01       LD BC,01F4											; 500 points per item (0 to 2 items)
	43F6 CD 01 44       CALL MulAccBCD
	43F9 E5             PUSH HL
	43FA CD 99 43       CALL SavedWorldCount								; Count saved crowns.
	43FD E1             POP HL
	43FE 01 7C 02       LD BC,027C											; #027C = 636 points per world saved (0 to 5 crowns)
	;; this flow in MulAccBCD
;; The function MulAccBCD adds to HL (BCD), the product
;; of DE (BCD) and BC (not in BCD) :  HL = HL + (DE * BC)
.MulAccBCD:																	; HL and DE are in BCD. BC is not.
	4401 7B             LD A,E
	4402 85             ADD A,L
	4403 27             DAA
	4404 6F             LD L,A
	4405 7C             LD A,H
	4406 8A             ADC A,D
	4407 27             DAA
	4408 67             LD H,A
	4409 0B             DEC BC
	440A 78             LD A,B
	440B B1             OR C
	440C 20 F3          JR NZ,MulAccBCD
	440E C9             RET													; result in HL : HL = HL + (DE * BC)

;; -----------------------------------------------------------------------------------------------------------
;; Get the actual direction validated from a user input in A.
;; Input: a 4-bit bitmask Left,Right,Down,Up (active low)
;; 	Let's take "A"=active (0), "I"=inactive (1)
;;  (note: we must ignore conflicting inputs L+R = no x_wise_move)
;;	LRDU : return_code					LRDU : return_code
;;	AAAA : FF	(no move)				IAAA : 02	(Right)						Up
;;  AAAI : 00	(Down)					IAAI : 01	(Down and Right)		 05	04 03
;;	AAIA : 04	(Up)					IAIA : 03	(Up and Right)		Left 06 FF 02 Right
;;  AAII : FF 	(no move)				IAII : 02	(Right)					 07 00 01
;;	AIAA : 06	(Left)					IIAA : FF 	(no move)				   Down
;;  AIAI : 07	(Down and Left)			IIAI : 00	(Down)
;;	AIIA : 05	(Up and Left)			IIIA : 04	(Up)
;;  AIII : 06 	(Left)					IIII : FF 	(no move)
;; Output in A: the validated direction as described above
.Get_dir_code_LRDU_bitmap:
	440F E6 0F          AND 0F												; Only care about 4 lsb : Left,Right,Down,Up
	4411 C6 1A          ADD A,1A											; All this does...
	4413 6F             LD L,A
	4414 CE 44          ADC A,44											; ...
	4416 95             SUB L
	4417 67             LD H,A												; ... HL = Array_direction_table + A
	4418 7E             LD A,(HL)											; get direction code depending on input direction keys
	4419 C9             RET													; return code FF (no move) or 00 to 07 (direction)

.Array_direction_table:
	441A DATABYTE FF 00 04 FF 06 07 05 06 02 01 03 02 FF 00 04 FF

;; -----------------------------------------------------------------------------------------------------------
;; A has a direction, returns Y delta in C, X delta in B, and
;; third entry goes in A and is the DirTable inverse mapping.
.DirDeltas:
	442A 6F             LD L,A
	442B 87             ADD A,A												; *2
	442C 85             ADD A,L												; *3 (groups of 3 bytes)
	442D C6 3A          ADD A,3A											; DirTable2 & #00FF
	442F 6F             LD L,A
	4430 CE 44          ADC A,44											; (DirTable2 & #FF00) >> 8	; #443A+(dir*3) ; DirTable2 addr = #443A
	4432 95             SUB L
	4433 67             LD H,A												; HL = DirTable2 + 3*A
	4434 4E             LD C,(HL)											; C = 1st byte = Ydelta
	4435 23             INC HL
	4436 46             LD B,(HL)											; B = 2nb byte = Xdelta
	4437 23             INC HL
	4438 7E             LD A,(HL)											; A = DirTable inverse mapping
	4439 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; First byte is Y delta, second X, third is reverse lookup (DirTable inverse mapping)?
.DirTable2:
	443A DATABYTE FF 00 0D          		; Ydelta, Xdelta, DirTable ~F2 ; down
	443D DATABYTE FF FF 09          		; Ydelta, Xdelta, DirTable ~F6 ; south-east
	4440 DATABYTE 00 FF 0B          		; Ydelta, Xdelta, DirTable ~F4 ; right
	4443 DATABYTE 01 FF 0A       			; Ydelta, Xdelta, DirTable ~F5 ; north-east
	4446 DATABYTE 01 00 0E       			; Ydelta, Xdelta, DirTable ~F1 ; up
	4449 DATABYTE 01 01 06       			; Ydelta, Xdelta, DirTable ~F9 ; north-west
	444C DATABYTE 00 01 07       			; Ydelta, Xdelta, DirTable ~F8 ; left
	444F DATABYTE FF 01 05					; Ydelta, Xdelta, DirTable ~FA ; south-west

;; -----------------------------------------------------------------------------------------------------------
.UpdateCurrPos:
	4452 2A EE 36       LD HL,(CurrObject)
	;; Takes direction in A.
.UpdatePos:
	4455 E5             PUSH HL
	4456 CD 2A 44       CALL DirDeltas
	;; Store the bottom 4 bits of A (dir bitmap) in Object + $0B
	4459 11 0B 00       LD DE,000B
	445C E1             POP HL
	445D 19             ADD HL,DE
	445E AE             XOR (HL)
	445F E6 0F          AND 0F
	4461 AE             XOR (HL)
	4462 77             LD (HL),A
	;; Update U coordinate with Y delta
	4463 11 FA FF       LD DE,FFFA											-$06
	4466 19             ADD HL,DE
	4467 7E             LD A,(HL)
	4468 81             ADD A,C
	4469 77             LD (HL),A
	;; Update V coordinate with X delta.
	446A 23             INC HL
	446B 7E             LD A,(HL)
	446C 80             ADD A,B
	446D 77             LD (HL),A
	446E C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Takes a pointer in HL to an index which is incremented into a byte
;; array that follows it. Next item is returned in A. Array is
;; terminated with 0, at which point we read the first item again.
.Read_Loop_byte:
	446F 34             INC (HL)											; next item
	4470 7E             LD A,(HL)											; index_offset = (HL)
	4471 85             ADD A,L												; Then this does...
	4472 5F             LD E,A
	4473 8C             ADC A,H
	4474 93             SUB E
	4475 57             LD D,A												; ... DE = HL + index_offset
	4476 1A             LD A,(DE)											; get value in (DE)
	4477 A7             AND A												; test
	4478 C0             RET NZ												; value at DE != 0, return, else:
	4479 36 01          LD (HL),01											; update index to 1
	447B 23             INC HL												; point on next byte
	447C 7E             LD A,(HL)											; get and return in A
	447D C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Word version of ReadLoop. Apparently unused?
ReadLoopW:
unused_Read_Loop_word:														; same than Read_Loop_byte, but for word (NOT USED!)
	447E 7E             LD A,(HL)											; A = (HL)
	447F 34             INC (HL)											; (HL)++
	4480 87             ADD A,A												; This does...
	4481 85             ADD A,L
	4482 5F             LD E,A
	4483 8C             ADC A,H
	4484 93             SUB E
	4485 57             LD D,A												; ... DE = HL + 2*A
	4486 13             INC DE
	4487 1A             LD A,(DE)
	4488 A7             AND A
	4489 28 05          JR Z,unused_Read_Loop_word_sub1
	448B EB             EX DE,HL
	448C 5F             LD E,A
	448D 23             INC HL
	448E 56             LD D,(HL)
	448F C9             RET

;; Loop-to-start: Set next time to index 1, return first entry.
unused_Read_Loop_word_sub1:
	4490 36 01          LD (HL),01
	4492 23             INC HL
	4493 5E             LD E,(HL)
	4494 23             INC HL
	4495 56             LD D,(HL)
	4496 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Pseudo random generator
.Random_gen:
	4497 2A C8 44       LD HL,(Rand_seed_2)
	449A 55             LD D,L
	449B 29             ADD HL,HL
	449C ED 6A          ADC HL,HL
	449E 4C             LD C,H
	449F 2A C6 44       LD HL,(Rand_seed_1)
	44A2 44             LD B,H
	44A3 CB 10          RL B
	44A5 5C             LD E,H
	44A6 CB 13          RL E
	44A8 CB 12          RL D
	44AA 09             ADD HL,BC
	44AB 22 C6 44       LD (Rand_seed_1),HL
	44AE 2A C8 44       LD HL,(Rand_seed_2)
	44B1 ED 5A          ADC HL,DE
	44B3 CB BC          RES 7,H
	44B5 22 C8 44       LD (Rand_seed_2),HL
	44B8 FA C2 44       JP M,rg_2
	44BB 21 C6 44       LD HL,Rand_seed_1
rg_1:
	44BE 34             INC (HL)
	44BF 23             INC HL
	44C0 28 FC          JR Z,rg_1
rg_2:
	44C2 2A C6 44       LD HL,(Rand_seed_1)
	44C5 C9             RET

Rand_seed_1:
	44C6 DATAWORD 4A 6F							; #6F4A
Rand_seed_2:
	44C8 DATAWORD 6E 21							; #216E

;; -----------------------------------------------------------------------------------------------------------
;; Pointer to object in HL
.RemoveObject:
	44CA E5				PUSH HL
	44CB E5				PUSH HL
	44CC FD E5          PUSH IY
	44CE E5             PUSH HL
	44CF FD E1          POP IY
	44D1 CD F1 3A       CALL Unlink
	44D4 FD E1          POP IY
	44D6 E1             POP HL
	44D7 CD EE 44       CALL DrawObject
	44DA DD E1          POP IX
	44DC DD CB 04 FE    SET 7,(IX+O_FLAGS)
	;; Transfer top bit of Phase to IX+$0A
	44E0 3A 10 01       LD A,(Do_Objects_Phase)								get Do_Objects_Phase
	44E3 DD 4E 0A       LD C,(IX+O_FUNC)
	44E6 A9             XOR C
	44E7 E6 80          AND 80
	44E9 A9             XOR C
	44EA DD 77 0A       LD (IX+O_FUNC),A
	44ED C9             RET

;; -----------------------------------------------------------------------------------------------------------
.DrawObject:
	44EE FD E5          PUSH IY
	;; Bump to an obj+2 pointer for call to GetObjExtents.
	44F0 23             INC HL
	44F1 23             INC HL
	44F2 CD 1E 1E       CALL GetObjExtents
	;; Move X extent from BC to HL, Y extent from HL to DE.
	44F5 EB             EX DE,HL
	44F6 60             LD H,B
	44F7 69             LD L,C
	;; Then draw where the thing is.
	44F8 CD EE 1C       CALL Draw_View
	44FB FD E1          POP IY
	44FD C9             RET

;; -----------------------------------------------------------------------------------------------------------
.InsertObject:
	44FE E5             PUSH HL
	44FF E5             PUSH HL
	4500 FD E5          PUSH IY
	4502 E5             PUSH HL
	4503 FD E1          POP IY
	4505 CD 66 3A       CALL EnlistAux
	4508 FD E1          POP IY
	450A E1             POP HL
	450B CD EE 44       CALL DrawObject
	450E DD E1          POP IX
	4510 DD CB 04 BE    RES 7,(IX+O_FLAGS)
	4514 DD 36 0B FF    LD (IX+0B),FF
	4518 DD 36 0C FF    LD (IX+0C),FF
	451C C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; When getting a crown, check that we have all crowns (5).
;; If so, show the page that shows we are proclaimed Emperor.
;; Then show the Worlds/Crowns page.
.Emperor_Screen_Cont:
	451D 3A EA 3D       LD A,(saved_World_Mask)								; get saved_World_Mask
	4520 FE 1F          CP 1F												; Got all 5 crowns?
	4522 20 14          JR NZ,fcsc_skip										; no then skip to fcsc_skip, else:
	4524 3E CA          LD A,CA												; Get proclaimed Emperor! STR_WIN_SCREEN
	4526 CD C2 4A       CALL Print_String
	4529 CD A5 0B       CALL Play_HoH_Tune									; Play Main Theme
	452C 11 0F 04       LD DE,040F											; 4 items (Head, Heels and their crowns); draw all
	452F 21 18 2F       LD HL,EmperorPageSpriteList							; pointer on sprite table
	4532 CD B1 45       CALL Draw_from_list									; draw them (must be 3x24)
	4535 CD 5E 45       CALL WaitKey										; Wait key and then Wipe Screen
fcsc_skip:
	4538 CD 41 45       CALL Show_World_Crowns_screen						; and Show Worlds/Crown screen (will also wait, then Wipe)
	453B CD F8 04       CALL DrawBlacked									; redraw the game screen
	453E C3 92 23       JP Update_Screen_Periph								; and the Periphery (HUD)

;; -----------------------------------------------------------------------------------------------------------
;; This is the World/Crowns/Planets screen
;; It also provides an function that waits a key press and wipe screen.
.Show_World_Crowns_screen:
	4541 3E C6          LD A,C6												; String ID #C6 STR_EMPIRE_BLURB
	4543 CD C2 4A       CALL Print_String
	4546 CD A5 0B       CALL Play_HoH_Tune									; Play HoH Theme
	4549 21 7E 45       LD HL,Planet_Sprites_list							; pointer on Planet_Sprites_list
	454C 11 FF 05       LD DE,05FF											; 5 planets items to draw, FF = draw all
	454F CD B1 45       CALL Draw_from_list									; draw them (3x24)
	4552 21 8D 45       LD HL,Crown_sprites_list							; pointer on Crown_sprites_list
	4555 ED 5B EA 3D    LD DE,(saved_World_Mask)							; get saved_World_Mask in E as bitmask indicating it item correspongin to bit n will be draw or not
	4559 16 05          LD D,05												; up to 5 crowns to draw
	455B CD B1 45       CALL Draw_from_list									; draw them (3x24)
.WaitKey:
	455E CD 36 0A       CALL Wait_anykey_released							; debounce key
	4561 CD 6C 45       CALL Wait_key_pressed								; Wait key press or count down over
	4564 CD 65 08       CALL Draw_wipe_and_Clear_Screen						; then Wipe and clear screen
	4567 06 C1          LD B,C1												; Play; Sound ID #C1 = "Tada"
	4569 C3 91 0D       JP Play_Sound										; will RET

;; -----------------------------------------------------------------------------------------------------------
;; Wait a key press to leave the screen shown (crown/worlds screen)
;; but leave automatically after a while (about 18-20 sec)
.Wait_key_pressed:
	456C 21 00 A8       LD HL,A800											; delay value (show the screen (crown, ..) about 19sec if no key pressed)
waitkp_loop:
	456F E5             PUSH HL
	4570 CD A5 0B       CALL Play_HoH_Tune									; Play Theme
	4573 CD 3C 0A       CALL Test_Enter_Shift_keys							; output : Carry=1 : no key pressed, else Carry=0 and C=0:Enter, C=1:Shift, C=2:other
	4576 E1             POP HL
	4577 D0             RET NC												; RET if a key was pressed
	4578 2B             DEC HL												; A7FF, A7FE....
	4579 7C             LD A,H
	457A B5             OR L												; test H=L=0
	457B 20 F2          JR NZ,waitkp_loop									; loop if not yet 0
	457D C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Data for the "Crowns/Worlds" screen. Defines the Sprite id and position
;; the the planets and crowns sprites on that screen.
.Planet_Sprites_list:
	457E DATABYTE 4C 54 78						; Sprite_ID_Ball (#4C), pix x,y coordinates : Egyptus
	4581 DATABYTE 4C A4 78						; Sprite_ID_Ball (#4C), pix x,y coordinates : Penitentiary
	4584 DATABYTE 4C 54 E8						; Sprite_ID_Ball (#4C), pix x,y coordinates : Safari
	4587 DATABYTE 4C A4 E8						; Sprite_ID_Ball (#4C), pix x,y coordinates : Book World
	458A DATABYTE 4C 7C B0						; Sprite_ID_Ball (#4C), pix x,y coordinates : Blacktooth
.Crown_sprites_list:
	458D DATABYTE 2F 54 60						; Sprite_ID_Crown (#2F), pix x,y coordinates : Egyptus
	4590 DATABYTE 2F A4 60						; Sprite_ID_Crown (#2F), pix x,y coordinates : Penitentiary
	4593 DATABYTE 2F 54 D0						; Sprite_ID_Crown (#2F), pix x,y coordinates : Safari
	4596 DATABYTE 2F A4 D0						; Sprite_ID_Crown (#2F), pix x,y coordinates : Book World
	4599 DATABYTE 2F 7C 98						; Sprite_ID_Crown (#2F), pix x,y coordinates : Blacktooth

;; -----------------------------------------------------------------------------------------------------------
;; This draws the game HUD, called the "Periphery".
;; It also provide an entry for drawing Head and Heels (Draw_sprites_from_list).
.Draw_Screen_Periphery:
	459C CD 39 2C       CALL Draw_carried_objects
	459F 21 CD 45       LD HL,Inventory_sprite_list							; pointer on Inventory_sprite_list
	45A2 ED 5B 7B 24    LD DE,(Inventory)									; E = bitmask based on Inventory (which are drawn or not)
	45A6 16 03          LD D,03												; 3 sprites to draw (Purse, Hooter, Donuts)
	45A8 CD B1 45       CALL Draw_from_list									; draw them (3x24)
	45AB ED 5B 84 24    LD DE,(selected_characters)							; DE = pointer on selected_characters
Draw_sprites_from_list														; E is the bitmask, HL points to the Data : Sprite_code, coordinates (2bytes)
	45AF 16 02          LD D,02												; nb of sprites to draw: 2 characters, Head and Heels!
	;; here it does an implicit "JP Draw_from_list" (with the list
	;; Head and Heels sprites), as it falls in it:
;; -----------------------------------------------------------------------------------------------------------
;; Given a list of sprites (3x24), draw them.
;; Inputs: D: number of sprites
;; 		   E: bitmask indicating to drawn the nth sprite or to shadow it
;; 		   HL: pointer on Sprites array
;; The sprites array data should contain for each entry:
;;         a Sprite code (1 byte), the Coordinates (2 bytes)
;; Important Note: if the bitmap is 0, a sprite is still drawn, but without the
;;                 vibrant color, to give a shadowed effect.
.Draw_from_list:
	45B1 7E             LD A,(HL)											; get sprite code of the first sprite
	45B2 23             INC HL												; point on coord word
	45B3 4E             LD C,(HL)
	45B4 23             INC HL
	45B5 46             LD B,(HL)											; get coord in BC = YX
	45B6 23             INC HL												; point on data for next sprite
	45B7 E5             PUSH HL												; save it
	45B8 CB 1B          RR E												; get current bitmap bit
	45BA D5             PUSH DE
	45BB 30 09          JR NC,dfl_2											; if 0, then "shadow" this sprite
	45BD CD F3 45       CALL Draw_sprite_3x24								; else draw it
dfl_1:
	45C0 D1             POP DE
	45C1 E1             POP HL
	45C2 15             DEC D												; count down
	45C3 20 EC          JR NZ,Draw_from_list								; if not finished, Draw next one
	45C5 C9             RET

dfl_2:
	45C6 16 01          LD D,01												; if the bitmap is 0, we still draw the sprite
	45C8 CD DE 45       CALL Draw_sprite_3x24_and_attribute					; but with a shadow effect. Attribute 1
	45CB 18 F3          JR dfl_1											; loop to next sprite.

;; -----------------------------------------------------------------------------------------------------------
;; This defines the Sprites IDs and coordinates for the "Periphery"
;; part of the game screen (ie. HUD)
.Sprite_Flipped: EQU  80

.Inventory_sprite_list:
	45CD DATABYTE 27 B0 F0						; Sprite_ID_Purse, pix x,y coordinates
	45D0 DATABYTE 28 44 F0						; Sprite_ID_Hooter, pix coordinates
	45D3 DATABYTE 29 44 D8						; Sprite_ID_Donuts, pix coordinates
	45D6 DATABYTE 98 94 F0						; Sprite_ID_Heels1 | Sprite_Flipped, pix coordinates
	45D9 DATABYTE 1E 60 F0						; Sprite_ID_Head1, pix coordinates

;; -----------------------------------------------------------------------------------------------------------
;; Draw a 3 byte x 24 row sprite on clear background, complete with
;; attributes in D, via Draw_Sprite.
;; Input: Sprite code in A.
;;        position the sprite in BC - bottomleft corner
;;        Attribute style in D:
;;				1 = "Shadow" mode
;;				3 = "Color" mode (this is the one used if using "Draw_sprite_3x24_attr3")
;; If entering directly at Draw_sprite_3x24_and_attribute, we
;; expect the attribute in D.
.Draw_sprite_3x24_attr3:
	45DC 16 03          LD D,03												; attribute = 3 for Draw_sprite_3x24_and_attribute ("Color" mode)
.Draw_sprite_3x24_and_attribute:
	45DE 32 38 35       LD (Sprite_Code),A									; update current Sprite Code
	45E1 78             LD A,B												; Y
	45E2 D6 48          SUB 48												; minus 3*24 bytes to get the topleft corner
	45E4 47             LD B,A												; now BC is the topleft-left point
	45E5 D5             PUSH DE
	45E6 C5             PUSH BC
	45E7 CD B3 35       CALL Load_sprite_image_address_into_DE				; get sprite image pinter in DE, B=height, HL=mask data
	45EA 21 0C 18       LD HL,180C											; Size = 24 rows (#18), 24 pix (#0C * 2)
	45ED C1             POP BC
	45EE F1             POP AF												; get the attribute code in A
	45EF A7             AND A												; if 0 set Z
	45F0 C3 B0 08       JP Draw_Sprite										; Draw the sprite with color attribute in A; will RET

;; -----------------------------------------------------------------------------------------------------------
;; Draw a 3-byte * 24 rows sprite on clear background
;; BC=bottomleft origin (without attribute)
.Draw_sprite_3x24:
	45F3 2E 01          LD L,01												; L is 1 on CPC, 0 on Spectrum
	45F5 2D             DEC L												; This is to ...
	45F6 2C             INC L												; ... update the Z flag
	45F7 28 E3          JR Z,Draw_sprite_3x24_attr3							; If L = 0 then go to Draw_sprite_3x24_attr3 (it seems it is never on CPC, but always on Spectrum!)
	45F9 32 38 35       LD (Sprite_Code),A									; update Sprite Code
	45FC CD 1A 46       CALL Calculate_Extents_3x24							; get min and max for x and y 3x24 sprite
	45FF CD 4E 46       CALL Clear_view_buffer								; empty the buffer
	4602 CD B3 35       CALL Load_sprite_image_address_into_DE				; DE = image data
	4605 01 00 67       LD BC,6700											; buffer 6700
	4608 D9             EXX
	4609 06 18          LD B,18												; height = 24=#18
	460B CD DD 14       CALL BlitMask3of3									; blit mask 3of3
	460E C3 A7 05       JP Blit_screen										; blit to screen

;; -----------------------------------------------------------------------------------------------------------
;; Clear a 3x24 area
.Clear_3x24:
	4611 CD 1A 46       CALL Calculate_Extents_3x24							; get min and max for x and y 3x24 sprite
	4614 CD 4E 46       CALL Clear_view_buffer								; empty the buffer
	4617 C3 A7 05       JP Blit_screen										; blit to erase

;; -----------------------------------------------------------------------------------------------------------
;; Calculate the X and Y Extent for a 3x24 sprite
;; Input: coordinate (bottom left) : y in B, x in C
.Calculate_Extents_3x24:
	461A 61             LD H,C
	461B 7C             LD A,H
	461C C6 0C          ADD A,0C											; +12
	461E 6F             LD L,A
	461F 22 98 1C       LD (ViewXExtent),HL									; update the ViewXExtent with X,X+#0C
	4622 78             LD A,B
	4623 C6 18          ADD A,18											; +24
	4625 4F             LD C,A
	4626 ED 43 9A 1C    LD (ViewYExtent),BC									; update the ViewYExtent with Y+#18,Y
	462A C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; how is this used? if it is used? #_NOTUSED_# ???
;; Draw a 3-byte * 32 rows sprite on clear background
;; BC=bottomleft origin (without attribute)
Draw_sprite_3x32:
	462B 32 38 35       LD (Sprite_Code),A									; update sprite code
	462E CD 1A 46       CALL Calculate_Extents_3x24							; update ViewYExtent min and ViewXExtent min and max
	4631 78             LD A,B												;
	4632 C6 20          ADD A,20											; +32
	4634 32 9A 1C       LD (ViewYExtent),A									; update ViewYExtent max with Y+32
	4637 CD 4E 46       CALL Clear_view_buffer								; erase buffer
	463A 3E 02          LD A,02
	463C 32 A2 1C       LD (SpriteFlags),A									; sprite flag bit1 set
	463F CD B3 35       CALL Load_sprite_image_address_into_DE				; DE = image data
	4642 01 00 67       LD BC,6700											; buffer 6700
	4645 D9             EXX
	4646 06 20          LD B,20												; Height = 32
	4648 CD DD 14       CALL BlitMask3of3									; blit mask 3of3
	464B C3 A7 05       JP Blit_screen										; blit screen

;; -----------------------------------------------------------------------------------------------------------
;; Clear the 6800 buffer
.Clear_view_buffer:
	464E 21 00 68       LD HL,6800
	4651 01 00 01       LD BC,0100											; erase 256 bytes (#0100) from #6800
	4654 C3 67 24       JP Erase_forward_Block_RAM							; Continue on Erase_forward_Block_RAM (will have a RET)

;; -----------------------------------------------------------------------------------------------------------
????
	4657 DATABYTE 00														????

;; Set to 0 if we're staying in the current room.
;; 1 = Down, 2 = Right, 3 = Up, 4 = Left, 5 = Below, 6 = Above, 7 = Teleport
;; 8 = ?? ; #80=??
access_new_room_code:
	4658 DATABYTE 00          												access_new_room_code
DyingAnimFrameIndex:
	4659 DATABYTE 00														When Dying will count down from #c to 0 while the vape anim is played
.Dying:
	465A DATABYTE 00       													Dying ; Mask of the characters who are dying
NR_Direction:
	465B DATABYTE 00

;; -----------------------------------------------------------------------------------------------------------
;; HL contains an object, A contains a direction
;; TODO: I guess IY holds the character object?
.Move:
	465C F5             PUSH AF
	465D CD 24 3B       CALL GetUVZExtentsE
	4660 D9             EXX
	4661 F1             POP AF
	4662 32 5B 46       LD (NR_Direction),A
;; Called from Move and recursively from the functions in movement.asm.
;; Expects UV extents in DE', HL', and movement direction in A.
;; Sets C flag if there's collision.
.DoMove:
	4665 CD 6C 46       CALL DoMoveAux
	4668 3A 5B 46       LD A,(NR_Direction)
	466B C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Takes direction in A, and UV extents in DE', HL'.
;;
;; It indexes into the move table, pulls out first
;; function entry into HL, and calls the second, having EXX'd,
;; arranging to return to PostMove.
.DoMoveAux:
	466C 11 8B 46       LD DE,PostMove										Direction
	;; Stick this on the stack to be called upon return.
	466F D5             PUSH DE
	4670 4F             LD C,A
	4671 87             ADD A,A
	4672 87             ADD A,A
	4673 81             ADD A,C												; A*5
	4674 C6 B7          ADD A,B7											MoveTbl & $FF
	4676 6F             LD L,A
	4677 CE 47          ADC A,47											MoveTbl >> 8 ; #47B7 + offset
	4679 95             SUB L
	467A 67             LD H,A												; Generate index into table
	467B 7E             LD A,(HL)
	467C 32 57 46       LD (4657),A					 						; Load first value here
	467F 23             INC HL
	4680 5E             LD E,(HL)
	4681 23             INC HL
	4682 56             LD D,(HL)											; Next two in DE
	4683 23             INC HL
	4684 7E             LD A,(HL)
	4685 23             INC HL
	4686 66             LD H,(HL)
	4687 6F             LD L,A												; Next two in HL
	4688 D5             PUSH DE
	4689 D9             EXX													; Save regs, and...
	468A C9             RET													; tail call DE.

;; -----------------------------------------------------------------------------------------------------------
;; Called after the call to the function in DoMoveAux.
;; The second movement function is in HL', the direction in C'.
.PostMove:
	468B D9             EXX
	;; Can't move in that direction? Return.
	468C C8             RET Z												; Sets C (collision).
	;; Put the second movement function from MoveTbl into IX.
	468D E5             PUSH HL
	468E DD E1          POP IX
	;; There are two similar loops, based on which direction we
    ;; want to traverse the object list:
	4690 CB 51          BIT 2,C
	4692 20 15          JR NZ,PM_Alt
    ;; Down or right case. Traverse the object list.
	4694 21 A9 39       LD HL,ObjectLists
.PM_ALoop:
	4697 7E             LD A,(HL)
	4698 23             INC HL
	4699 66             LD H,(HL)
	469A 6F             LD L,A
	469B B4             OR H
	469C 28 24          JR Z,PM_ABreak					 					; End of list - break.
	469E E5             PUSH HL
	469F CD B2 19       CALL DoCopy					 						; Call the function from MoveTbl.
	46A2 E1             POP HL
	46A3 38 3B          JR C,PM_AFound										; Found case
	46A5 20 F0          JR NZ,PM_ALoop					 					; Loop case
	46A7 18 19          JR PM_ABreak										; Break case

;; Up or left case. Traverse the object list in opposite direction.
.PM_Alt:
	46A9 21 AB 39       LD HL,ObjectLists + 2
.PM_BLoop:
	46AC 7E             LD A,(HL)
	46AD 23             INC HL
	46AE 66             LD H,(HL)
	46AF 6F             LD L,A
	46B0 B4             OR H
	46B1 28 09          JR Z,PM_BBreak										; End of list - break.
	46B3 E5             PUSH HL
	46B4 CD B2 19       CALL DoCopy					 						; Call the function from MoveTbl.
	46B7 E1             POP HL
	46B8 38 28          JR C,PM_BFound					 					; Other found case
	46BA 20 F0          JR NZ,PM_BLoop										; Loop case
.PM_BBreak:
	46BC CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	46BF 5D             LD E,L
	46C0 18 06          JR PM_Break

.PM_ABreak:
	46C2 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	46C5 5D             LD E,L
	46C6 23             INC HL
	46C7 23             INC HL
;; Both "Break" cases end up here.
;; HL points 2 into object
;; TODO: ??? I think it may be checking if the other character
;; is relevant? Or the main character???
.PM_Break:
	46C8 FD CB 09 46    BIT 0,(IY+O_SPRFLAGS)
	46CC 28 04          JR Z,PM_Break2
	46CE FD 7D          LD A,IYl											IY low byte
	46D0 BB             CP E
	46D1 C8             RET Z
.PM_Break2:
	46D2 3A AC 24       LD A,(Saved_Objects_List_index)						get Saved_Objects_List_index
	46D5 A7             AND A
	46D6 C8             RET Z												; Sets NC (no collision).
	46D7 CD B2 19       CALL DoCopy
	46DA D0             RET NC												; Sets NC (no collision).
	;; Adjust pointer and fall through...
	46DB CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	46DE 23             INC HL
	46DF 23             INC HL
.PM_AFound:
	46E0 2B             DEC HL
	46E1 2B             DEC HL
.PM_BFound:
	46E2 E5             PUSH HL
	46E3 DD E1          POP IX
	46E5 3A 57 46       LD A,(4657)
	46E8 DD CB 09 4E    BIT 1,(IX+O_SPRFLAGS)								Second of double-height character?
	46EC 28 08          JR Z,PM_Found2
    ;; Adjust first, then.
	46EE DD A6 FA       AND (IX+FA)											(IX+$0C-18)
	46F1 DD 77 FA       LD (IX+FA),A										(IX+$0C-18) ; -6
	46F4 18 06          JR PM_Found3

;; Otherwise, adjust it.
.PM_Found2:
	46F6 DD A6 0C       AND (IX+0C)
	46F9 DD 77 0C       LD (IX+0C),A
;; Call "Contact" with $FF in A.
.PM_Found3:
	46FC AF             XOR A
	46FD D6 01          SUB 01												; Sets C (collided).
;; Handle contact between a pair of objects in IX and IY
.Contact:
	46FF F5             PUSH AF
	4700 DD E5          PUSH IX
	4702 FD E5          PUSH IY
	4704 CD 0D 47       CALL ContactAux
	4707 FD E1          POP IY
	4709 DD E1          POP IX
	470B F1             POP AF
	470C C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; IX and IY are both objects, may be characters.
;; Something is in A.
.ContactAux:
	470D FD CB 09 46    BIT 0,(IY+O_SPRFLAGS)								test bit0 of IY+9 (sprite flags???)
	4711 20 0C          JR NZ,cactaux_1										no set jump over, else:
	4713 DD CB 09 46    BIT 0,(IX+O_SPRFLAGS)								test bit0 of IX+9 (sprite flag)
	4717 28 76          JR Z,ContactNonChar									if 0 then ContactNonChar, else:
	4719 FD E5          PUSH IY
	471B DD E3          EX (SP),IX											these 3 lines swap IY and IX
	471D FD E1          POP IY
cactaux_1:
	471F FD 4E 09       LD C,(IY+O_SPRFLAGS)								; sprite flags in C.
	4722 FD 46 04       LD B,(IY+O_FLAGS)									; char flags in B.????
	4725 DD CB 04 6E    BIT 5,(IX+O_FLAGS)									; if bit5 in IX+4
	4729 C8             RET Z												; if reset then leave, else:
	472A DD CB 04 76    BIT 6,(IX+O_FLAGS)									; if bit6
	472E 20 43          JR NZ,CollectSpecial								; is set then go CollectSpecial, else:
	4730 A7             AND A												test value in A????
	4731 28 05          JR Z,DeadlyContact									if 0 then DeadlyContact (deadly floor or object), else:
	4733 DD CB 09 66    BIT 4,(IX+O_SPRFLAGS)								test bit 4 of IX+9
	4737 C0             RET NZ												leave if set, else:
;; IY holds character sprite. We've hit a deadly floor or object.
;; C is character's sprite flags (IY offset 9)
;; B is character's other flags (IY offset 4)
.DeadlyContact:
	4738 CB 58          BIT 3,B												test char flag if bit3=00 : joined Heels+Head
	473A 06 03          LD B,03												B[1:0] = 2b11
	473C 20 06          JR NZ,dco_1											not joined, jump over this, else do:
	473E 05             DEC B												B[1:0] = 2b10
	473F CB 51          BIT 2,C												test sprite flag bit 2
	4741 20 01          JR NZ,dco_1											if bit2=1, then only Head
	4743 05             DEC B												else we are Heels, so B[1:0]=2b01
dco_1:																		;; updating flag bits based on invulnerability...
	4744 AF             XOR A												A=0
	4745 21 7E 24       LD HL,Heels_invulnerability							a #C9 (RET) here make invulnerable!
	4748 BE             CP (HL)												compare Heels' invul with 0 (active low)
	4749 28 02          JR Z,dco_2											if it is 0 (Heels is invuln), don't do the RES below, else do
	474B CB 80          RES 0,B												char flag bit 0=Heels invul (0=invul)
dco_2:
	474D 23             INC HL												Head_s_invulnerability
	474E BE             CP (HL)												compare Head's invul with 0 (active low)
	474F 28 02          JR Z,dco_3											if it is 0 (Head is invuln), don't do the RES below, else do
	4751 CB 88          RES 1,B												char flag bit 1=Head invul (0=invul)
dco_3:
	4753 78             LD A,B												final invul setting in A
	4754 A7             AND A												test it
	4755 C8             RET Z												if 0, then invulnerability is active, so leave. Else, death!
	4756 21 5A 46       LD HL,Dying											point on Dying mask (which char is dying)
	4759 B6             OR (HL)												based on the value of B (invulnerabilities)...
	475A 77             LD (HL),A											...refresh mask value at 'Dying'
	475B 2B             DEC HL												points on DyingAnimFrameIndex (frame of Vape animation effect when dying)
	475C 7E             LD A,(HL)											get value
	475D A7             AND A												test if 0
	475E C0             RET NZ												if not 0 (dying anim) return, else:
	475F 3A EA 3D       LD A,(saved_World_Mask)								get saved_World_Mask
	4762 FE 1F          CP 1F												if all worlds saved (then we are Emperor)
	4764 C8             RET Z												then Return (invulnerable as Emperor), else
	4765 36 0C          LD (HL),0C											Set value of DyingAnimFrameIndex to #0C (dying, will count down to 0 while the vape/dying anim is played)
	4767 3A 58 46       LD A,(access_new_room_code)							get access_new_room_code
	476A A7             AND A												test if 0
	476B C4 D4 3F       CALL NZ,BoostInvuln2								??? if merged HnH, then heels boost invuln ??? ; call BoostInvuln2 if access_new_room_code not 0 (changing room)
	476E 06 C6          LD B,C6												Sound_ID $C6 ; Death noise
	4770 C3 91 0D       JP Play_Sound										will RET

;; Make the special object disappear and call the associated function.
.CollectSpecial:
    ;; Set flags etc. for fading
	4773 DD 36 0F 08    LD (IX+O_ANIM),08
	4777 DD 36 04 80    LD (IX+O_FLAGS),80
	;; Switch to fade function
	477B DD 7E 0A       LD A,(IX+O_FUNC)
	477E E6 80          AND 80
	4780 F6 11          OR 11												OBJFN_FADE
	4782 DD 77 0A       LD (IX+O_FUNC),A
	;; Clear special collectable item status.
	4785 DD CB 09 B6    RES 6,(IX+O_SPRFLAGS)
	;; Extract the item id for the call to GetSpecial.
	4789 DD 7E 11       LD A,(IX+O_SPECIAL)
	478C C3 5E 3F       JP GetSpecial

;; Contact between two non-character objects.
.ContactNonChar:
	478F FD CB 09 5E    BIT 3,(IY+O_SPRFLAGS)
	4793 20 09          JR NZ,cnc_1
	4795 DD CB 09 5E    BIT 3,(IX+O_SPRFLAGS)
	4799 C8             RET Z
	479A FD E5          PUSH IY
	479C DD E1          POP IX
	;; Object in IX has bit 3 of sprite flags set.
    ;; If we're second part of double-height object, find the first part.
cnc_1:
	479E DD CB 09 4E    BIT 1,(IX+O_SPRFLAGS)
	47A2 28 05          JR Z,cnc_2
	47A4 11 EE FF       LD DE,FFEE
	47A7 DD 19          ADD IX,DE
; Return if bit 7 reset
cnc_2:
	47A9 DD CB 09 7E    BIT 7,(IX+O_SPRFLAGS)
	47AD C8             RET Z
	; Set bit 6, clear movement (?)
	47AE DD CB 09 F6    SET 6,(IX+O_SPRFLAGS)
	47B2 DD 36 0B FF    LD (IX+0B),FF
	47B6 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; MoveTbl is indexed on a direction, as per LookupDir.
;; First element is bit mask for directions.
;; Second is the function to move that direction.
;; Third element is the function to check collisions.
.MoveTbl:
	47B7 DATABYTE FD          												~$02
	47B8 DATAWORD FE 48             										Down
	47BA DATAWORD C4 48														DownCollide
	47BC DATABYTE FF       													~$00
	47BD DATAWORD DF 47             										DownRight
	47BF DATAWORD 00 00
	47C1 DATABYTE FB             											~$04
	47C2 DATAWORD 55 49             										Right
	47C4 DATAWORD E2 48														RightCollide
	47C8 DATABYTE FF       													~$00
	47C7 DATAWORD 00 48             										UpRight
	47C9 DATAWORD 00 00
	47CB DATABYTE FE          												~$01
	47CC DATAWORD A5 49             										Up
	47CE DATAWORD 68 48             										UpCollide
	47D0 DATABYTE FF             											~$00
	47D1 DATAWORD 24 48             										UpLeft
	47D3 DATAWORD 00 00
	47D5 DATABYTE F7             											~$08
	47D6 DATAWORD ED 49          											Left
	47D8 DATAWORD A9 48             										LeftCollide
	47DA DATABYTE FF             											~$00
	47DB DATAWORD 47 48             										DownLeft
	47DD DATAWORD 00 00

;; The diagonal movement functions rearrange things:
;; * They remove two elements of the stack, removing the call to
;;   PostMove and the return into DoMove (which puts (Direction)
;;   into A).
;; * They call DoMove, and check the resultant carry flag. Carry means
;;   failure to move in that direction. They move one direction, then the
;;   other.
;; * If the first move succeeds, the extents are updated to represent the
;;   successful move, before the second check is attempted.
;; * Depending on what works, they generate a movement direction in A,
;;   and success/failure in the carry flag.
DownRight:
	47DF D9             EXX
	;; Remove original return path, hit DoMove again.
	47E0 E1             POP HL
	47E1 D1             POP DE
	47E2 AF             XOR A
	;; Call Down
	47E3 CD 65 46       CALL DoMove
	47E6 38 0E          JR C,drght_1
	;; Update extents in DE
	47E8 D9             EXX
	47E9 15             DEC D
	47EA 1D             DEC E
	47EB D9             EXX
	;; Call Right
	47EC 3E 02          LD A,02
	47EE CD 65 46       CALL DoMove
	47F1 3E 01          LD A,01
	47F3 D0             RET NC
	47F4 AF             XOR A
	47F5 C9             RET

;; Call Right
drght_1:
	47F6 3E 02          LD A,02
	47F8 CD 65 46       CALL DoMove
	47FB D8             RET C
	47FC A7             AND A
	47FD 3E 02          LD A,02
	47FF C9             RET

;; -----------------------------------------------------------------------------------------------------------
.UpRight:
	4800 D9             EXX
	;; Remove original return path, hit DoMove again.
	4801 E1             POP HL
	4802 D1             POP DE
	;; Call Up
	4803 3E 04          LD A,04
	4805 CD 65 46       CALL DoMove
	4808 38 10          JR C,urght_1
	;; Update extents in DE
	480A D9             EXX
	480B 14             INC D
	480C 1C             INC E
	480D D9             EXX
	;; Call Right
	480E 3E 02          LD A,02
	4810 CD 65 46       CALL DoMove
	4813 3E 03          LD A,03
	4815 D0             RET NC
	4816 3E 04          LD A,04
	4818 A7             AND A
	4819 C9             RET

;; Call Right
urght_1:
	481A 3E 02          LD A,02
	481C CD 65 46       CALL DoMove
	481F D8             RET C
	4820 A7             AND A
	4821 3E 02          LD A,02
	4823 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.UpLeft:
	4824 D9             EXX
	;; Remove original return path, hit DoMove again.
	4825 E1             POP HL
	4826 D1             POP DE
	4827 3E 04          LD A,04
	4829 CD 65 46       CALL DoMove
	482C 38 10          JR C,ulft_1
	;; Update extents in DE
	482E D9             EXX
	482F 14             INC D
	4830 1C             INC E
	4831 D9             EXX
	;; Call Left
	4832 3E 06          LD A,06
	4834 CD 65 46       CALL DoMove
	4837 3E 05          LD A,05
	4839 D0             RET NC
	483A 3E 04          LD A,04
	483C A7             AND A
	483D C9             RET

;; Call Left
ulft_1:
	483E 3E 06          LD A,06
	4840 CD 65 46       CALL DoMove
	4843 D8             RET C
	4844 3E 06          LD A,06
	4846 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.DownLeft:
	4847 D9             EXX
	;; Remove original return path, hit DoMove again.
	4848 E1             POP HL
	4849 D1             POP DE
	;; Call Down
	484A AF             XOR A
	484B CD 65 46       CALL DoMove
	484E 38 0E          JR C,dlft_1
	;; Update extents in DE
	4850 D9             EXX
	4851 15             DEC D
	4852 1D             DEC E
	4853 D9             EXX
	;; Call Left
	4854 3E 06          LD A,06
	4856 CD 65 46       CALL DoMove
	4859 3E 07          LD A,07
	485B D0             RET NC
	485C AF             XOR A
	485D C9             RET

;; Call Left
dlft_1:
	485E 3E 06          LD A,06
	4860 CD 65 46       CALL DoMove
	4863 D8             RET C
	4864 A7             AND A
	4865 3E 06          LD A,06
	4867 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; *Collide functions take an object in HL, and check it against the
;; character whose extents are in DE' and HL'
;;
;; Returned flags are:
;;  Carry = Collided
;;  NZ = No collision, but further collisions are possible.
;;  Z = Stop now, no further collisions possible.
.UpCollide:
	4868 23             INC HL
	4869 23             INC HL
	486A CD 90 4A       CALL GetSimpleSize
	;; Check U coordinate
	486D 7E             LD A,(HL)
	486E 91             SUB C
	486F D9             EXX
	4870 BA             CP D
	4871 D9             EXX
	4872 38 31          JR C,CollideContinue 								Too far? Skip.
	4874 20 1D          JR NZ,ChkBack										Are we done yet?
	;; U coordinate matches.
	4876 23             INC HL
;; U coordinate matches. Check V overlaps.
.ChkVCollide:
	4877 7E             LD A,(HL)
	4878 90             SUB B
	4879 D9             EXX
	487A BC             CP H
	487B 7D             LD A,L
	487C D9             EXX
	487D 30 26          JR NC,CollideContinue
	487F 90             SUB B
	4880 BE             CP (HL)
	4881 30 22          JR NC,CollideContinue
	;; If we reached here, there's a V overlap.
.ChkZCollide:
	4883 23             INC HL
	4884 D9             EXX
	4885 79             LD A,C
	4886 D9             EXX
	4887 BE             CP (HL)
	4888 30 1B          JR NC,CollideContinue
	488A 7E             LD A,(HL)
	488B 93             SUB E
	488C D9             EXX
	488D B8             CP B
	488E D9             EXX
	488F 30 14          JR NC,CollideContinue
	;; If we reached here, there's a Z overlap.
	4891 37             SCF
	4892 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.ChkBack:
    ;; Check V coordinate
	4893 23             INC HL
	4894 7E             LD A,(HL)
	4895 90             SUB B
	4896 D9             EXX
	4897 BC             CP H
	4898 D9             EXX
	4899 38 0A          JR C,CollideContinue
	;; Check Z coordinate
	489B 23             INC HL
	489C 7E             LD A,(HL)
	489D 93             SUB E
	489E D9             EXX
	489F B8             CP B
	48A0 D9             EXX
	48A1 38 02          JR C,CollideContinue
	;; Passed our object, can stop now.
	48A3 AF             XOR A
	48A4 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; No carry = no collision, non-zero = keep searching.
;; return -1, no Z and no Carry
.CollideContinue:
	48A5 3E FF          LD A,FF
	48A7 A7             AND A
	48A8 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.LeftCollide:
	48A9 23             INC HL
	48AA 23             INC HL
	48AB CD 90 4A       CALL GetSimpleSize
	;; Check U coordinates overlap...
	48AE 7E             LD A,(HL)
	48AF 91             SUB C
	48B0 D9             EXX
	48B1 BA             CP D
	48B2 7B             LD A,E
	48B3 D9             EXX
	48B4 30 DD          JR NC,ChkBack
	48B6 91             SUB C
	48B7 BE             CP (HL)
	48B8 30 EB          JR NC,CollideContinue
	;; U overlaps, check V for contact.
	48BA 23             INC HL
	48BB 7E             LD A,(HL)
	48BC 90             SUB B
	48BD D9             EXX
	48BE BC             CP H
	48BF D9             EXX
	48C0 28 C1          JR Z,ChkZCollide   									U and V match.
	48C2 18 E1          JR CollideContinue 									Not a collision.

.DownCollide:
	48C4 CD 90 4A       CALL GetSimpleSize
	;; Check U coordinate.
	48C7 D9             EXX
	48C8 7B             LD A,E
	48C9 D9             EXX
	48CA 91             SUB C
	48CB BE             CP (HL)
	48CC 38 D7          JR C,CollideContinue 								Past it? Skip
	48CE 23             INC HL
	48CF 28 A6          JR Z,ChkVCollide    								Are we done yet?
	;; U coordinate matches.
.ChkFront:
    ;; Check U coordinate.
	48D1 D9             EXX
	48D2 7D             LD A,L
	48D3 D9             EXX
	48D4 90             SUB B
	48D5 BE             CP (HL)
	48D6 38 CD          JR C,CollideContinue
	; Check Z coordinate.
	48D8 23             INC HL
	48D9 7E             LD A,(HL)
	48DA 83             ADD A,E
	48DB D9             EXX
	48DC B8             CP B
	48DD D9             EXX
	48DE 30 C5          JR NC,CollideContinue
	;; Passed our object, can stop now.
	48E0 AF             XOR A
	48E1 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.RightCollide
	48E2 CD 90 4A       CALL GetSimpleSize
	;; Check U coordinate overlap...
	48E5 D9             EXX
	48E6 7B             LD A,E
	48E7 D9             EXX
	48E8 91             SUB C
	48E9 BE             CP (HL)
	48EA 23             INC HL
	48EB 30 E4          JR NC,ChkFront
	48ED 2B             DEC HL
	48EE 7E             LD A,(HL)
	48EF 91             SUB C
	48F0 D9             EXX
	48F1 BA             CP D
	48F2 7D             LD A,L
	48F3 D9             EXX
	48F4 30 AF          JR NC,CollideContinue
	 ;; U overlaps, checks V for contact.
	48F6 23             INC HL
	48F7 90             SUB B
	48F8 BE             CP (HL)
	48F9 CA 83 48       JP Z,ChkZCollide						   			; U and V match.
	48FC 18 A7          JR CollideContinue

;; Up, Down, Left and Right
;;
;; Takes U extent in DE, V extent in HL.
;; U/D work in U direction, L/R work in V direction.
;;
;; Sets NZ and C if you can move in a direction.
;; Sets Z and C if you cannot.
;; Leaving room sets direction in NextRoom, sets C and Z.
.Down:
	48FE CD 7D 4A       CALL ChkCantLeave
	4901 28 33          JR Z,D_NoExit
	; Inside the door frame to the side? Check a limited extent, then.
	4903 CD 35 4A       CALL UD_InOtherDoor
	4906 3E 24          LD A,24												DOOR_LOW
	4908 38 2F          JR C,D_NoExit2
	;; If the wall has a door, and
    ;; we're the right height to fit through, and
    ;; we're lined up to go through the frame,
    ;; set 'A' to be the far side of the door.
	490A DD CB FF 46    BIT 0,(IX-01)										Has_Door?
	490E 28 14          JR Z,D_NoDoor
	4910 3A F1 1E       LD A,(DoorHeights+3)								; sw door
	4913 CD 69 4A       CALL DoorHeightCheck
	4916 38 1E          JR C,D_NoExit
	4918 CD 59 4A       CALL UD_InFrame
	491B 38 20          JR C,D_NearDoor
	491D 3A C2 1E       LD A,(Max_min_UV_Table)								MinU
	4920 D6 04          SUB 04
	4922 18 09          JR D_Exit

;; If there's no wall, put the room end coordinate into 'A'...
.D_NoDoor
	4924 DD CB FE 46    BIT 0,(IX-02)										Has_no_vall
	4928 28 0C          JR Z,D_NoExit
	492A 3A C2 1E       LD A,(Max_min_UV_Table)								MinU
;; Case where we can exit the room.
.D_Exit:
	492D BB             CP E
	492E C0             RET NZ
	492F 3E 01          LD A,01
.LeaveRoom:
	4931 32 58 46       LD (access_new_room_code),A							update access_new_room_code
	4934 37             SCF													set Carry
	4935 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; The case where we can't exit the room, but may hit the wall.
.D_NoExit:
	4936 3A C2 1E       LD A,(Max_min_UV_Table)								MinU
;; (or some other value given in A).
.D_NoExit2:
	4939 BB             CP E
	493A C0             RET NZ
	493B 37             SCF
	493C C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Handle the near-door case: If we're not near the door frame,
;; we do the normal "not door" case. Otherwise, we do that and
;; then nudge into the door.
.D_NearDoor:
	493D CD 61 4A       CALL UD_InFrameW
	4940 38 F4          JR C,D_NoExit
	4942 CD 36 49       CALL D_NoExit
	;; Choose a direction to move based on which side of the door
    ;; we're trying to get through.
.UD_Nudge:
	4945 C0             RET NZ
	4946 7D             LD A,L
	4947 FE 25          CP 25												DOOR_LOW + 1
	4949 3E F7          LD A,F7												~$08
	494B 38 02          JR C,Nudge
	494D 3E FB          LD A,FB												~$04
;; Update the direction with they way to go to get through the door.
.Nudge:
	494F 32 AF 24       LD (Movement),A
	4952 AF             XOR A
	4953 37             SCF
	4954 C9             RET

;; -----------------------------------------------------------------------------------------------------------
Right:
	4955 CD 7D 4A       CALL ChkCantLeave
	4958 28 30          JR Z,R_NoExit
	;; Inside the door frame to the side? Check a limited extent, then.
	495A CD 3F 4A       CALL LR_InOtherDoor
	495D 3E 24          LD A,24												DOOR_LOW
	495F 38 2C          JR C,R_NoExit2
	;; If the wall has a door, and
    ;; we're the right height to fit through, and
    ;; we're lined up to go through the frame,
    ;; set 'A' to be the far side of the door.
	4961 DD CB FF 4E    BIT 1,(IX-01)										Has_Door
	4965 28 14          JR Z,R_NoDoor
	4967 3A F0 1E       LD A,(DoorHeights+2)								; se door
	496A CD 69 4A       CALL DoorHeightCheck
	496D 38 1B          JR C,R_NoExit
	496F CD 49 4A       CALL LR_InFrame
	4972 38 1D          JR C,R_NearDoor
	4974 3A C3 1E       LD A,(Max_min_UV_Table+1)							MinV
	4977 D6 04          SUB 04
	4979 18 09          JR R_Exit

;; If there's no wall, put the room end coordinate into 'A'...
.R_NoDoor:
	497B DD CB FE 4E    BIT 1,(IX-02)										(IX-$02) ; Has_no_vall
	497F 28 09          JR Z,R_NoExit
	4981 3A C3 1E       LD A,(Max_min_UV_Table+1)							MinV
;; Case where we can exit the room.
.R_Exit:
	4984 BD             CP L
	4985 C0             RET NZ
	4986 3E 02          LD A,02
	4988 18 A7          JR LeaveRoom

.R_NoExit:
	498A 3A C3 1E       LD A,(Max_min_UV_Table+1)							MinV
;; (or some other value given in A).
.R_NoExit2:
	498D BD             CP L
	498E C0             RET NZ
	498F 37             SCF
	4990 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; The case where we can't exit the room, but may hit the wall.
.R_NearDoor:
	4991 CD 51 4A       CALL LR_InFrameW
	4994 38 F4          JR C,R_NoExit
	4996 CD 8A 49       CALL R_NoExit
;; Choose a direction to move based on which side of the door
;; we're trying to get through.
.LR_Nudge:
	4999 C0             RET NZ
	499A 7B             LD A,E
	499B FE 25          CP 25
	499D 3E FE          LD A,FE
	499F 38 AE          JR C,Nudge
	49A1 3E FD          LD A,FD
	49A3 18 AA          JR Nudge

Up:
	49A5 CD 7D 4A       CALL ChkCantLeave
	49A8 28 31          JR Z,U_NoExit
	;; Inside the door frame to the side? Check a limited extent, then.
	49AA CD 35 4A       CALL UD_InOtherDoor
	49AD 3E 2C          LD A,2C												DOOR_HIGH
	49AF 38 2D          JR C,U_NoExit2
	;; If the wall has a door, and
    ;; we're the right height to fit through, and
    ;; we're lined up to go through the frame,
    ;; set 'A' to be the far side of the door.
	49B1 DD CB FF 56    BIT 2,(IX-01)										(IX-$01) ; Has_Door
	49B5 28 14          JR Z,U_NoDoor
	49B7 3A EF 1E       LD A,(DoorHeights+1)								; ne door
	49BA CD 69 4A       CALL DoorHeightCheck
	49BD 38 1C          JR C,U_NoExit
	49BF CD 59 4A       CALL UD_InFrame
	49C2 38 1E          JR C,U_NearDoor
	49C4 3A C4 1E       LD A,(Max_min_UV_Table+2)							MaxU
	49C7 C6 04          ADD A,04
	49C9 18 09          JR U_Exit

;; If there's no wall, put the room end coordinate into 'A'...
U_NoDoor:
	49CB DD CB FE 56    BIT 2,(IX-02)										Has_no_vall
	49CF 28 0A          JR Z,U_NoExit
	49D1 3A C4 1E       LD A,(Max_min_UV_Table+2)							MaxU
; Case where we can exit the room.
.U_Exit:
	49D4 BA             CP D
	49D5 C0             RET NZ
	49D6 3E 03          LD A,03
	49D8 C3 31 49       JP LeaveRoom

;; The case where we can't exit the room, but may hit the wall.
.U_NoExit:
	49DB 3A C4 1E       LD A,(Max_min_UV_Table+2)							MaxU
.U_NoExit2
	49DE BA             CP D												; (or some other value given in A).
	49DF C0             RET NZ
	49E0 37             SCF
	49E1 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Handle the near-door case: If we're not near the door frame,
;; we do the normal "not door" case. Otherwise, we do that and
;; then nudge into the door.
.U_NearDoor:
	49E2 CD 61 4A       CALL UD_InFrameW
	49E5 38 F4          JR C,U_NoExit
	49E7 CD DB 49       CALL U_NoExit
	49EA C3 45 49       JP UD_Nudge

;; -----------------------------------------------------------------------------------------------------------
Left:
	49ED CD 7D 4A       CALL ChkCantLeave
	49F0 28 31          JR Z,L_NoExit
	; Inside the door frame to the side? Check a limited extent, then.
	49F2 CD 3F 4A       CALL LR_InOtherDoor
	49F5 3E 2C          LD A,2C												DOOR_HIGH
	49F7 38 2D          JR C,L_NoExit2
	;; If the wall has a door, and
    ;; we're the right height to fit through, and
    ;; we're lined up to go through the frame,
    ;; set 'A' to be the far side of the door.
	49F9 DD CB FF 5E    BIT 3,(IX-01)										(IX-$01) ; Has_Door
	49FD 28 14          JR Z,L_NoDoor
	49FF 3A EE 1E       LD A,(DoorHeights)									; nw door
	4A02 CD 69 4A       CALL DoorHeightCheck
	4A05 38 1C          JR C,L_NoExit
	4A07 CD 49 4A       CALL LR_InFrame
	4A0A 38 1E          JR C,L_NearDoor
	4A0C 3A C5 1E       LD A,(Max_min_UV_Table+3)							MaxV
	4A0F C6 04          ADD A,04
	4A11 18 09          JR L_Exit

; If there's no wall, put the room end coordinate into 'A'...
.L_NoDoor:
	4A13 DD CB FE 5E    BIT 3,(IX-02)										(IX-$02) ; Has_no_vall
	4A17 28 0A          JR Z,L_NoExit
	4A19 3A C5 1E       LD A,(Max_min_UV_Table+3)							MaxV
;; Case where we can exit the room.
.L_Exit:
	4A1C BC             CP H
	4A1D C0             RET NZ
	4A1E 3E 04          LD A,04
	4A20 C3 31 49       JP LeaveRoom

;; The case where we can't exit the room, but may hit the wall.
.L_NoExit
	4A23 3A C5 1E       LD A,(Max_min_UV_Table+3)							MaxV
	; (or some other value given in A).
.L_NoExit2:
	4A26 BC             CP H
	4A27 C0             RET NZ
	4A28 37             SCF
	4A29 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Handle the near-door case: If we're not near the door frame,
;; we do the normal "not door" case. Otherwise, we do that and
;; then nudge into the door.
.L_NearDoor:
	4A2A CD 51 4A       CALL LR_InFrameW
	4A2D 38 F4          JR C,L_NoExit
	4A2F CD 23 4A       CALL L_NoExit
	4A32 C3 99 49       JP LR_Nudge

;; -----------------------------------------------------------------------------------------------------------
;; If we're not inside the V extent, we must be in the doorframes to
;; the side. Set C if this is the case.
.UD_InOtherDoor:
	4A35 3A C5 1E       LD A,(Max_min_UV_Table+3)							MaxV
	4A38 BC             CP H
	4A39 D8             RET C
	4A3A 7D             LD A,L
	4A3B DD BE 01       CP (IX+01)											(IX+$01) ; MinV
	4A3E C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; If we're not inside the U extent, we must be in the doorframes to
;; the side. Set C if this is the case.
.LR_InOtherDoor:
	4A3F 3A C4 1E       LD A,(Max_min_UV_Table+2)							MaxU
	4A42 BA             CP D
	4A43 D8             RET C
	4A44 7B             LD A,E
	4A45 DD BE 00       CP (IX+00)											(IX+$00) ; MinU
	4A48 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Return NC if within the interval associated with the door.
;; Specifically, returns NC if D <= DOOR_HIGH and E >= DOOR_LOW
.LR_InFrame:
	4A49 3E 2C          LD A,2C												DOOR_HIGH
	4A4B BA             CP D
	4A4C D8             RET C
	4A4D 7B             LD A,E
	4A4E FE 24          CP 24												DOOR_LOW
	4A50 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Same, but for the whole door, not just the inner arch
.LR_InFrameW:
	4A51 3E 30          LD A,30												DOOR_HIGH + 4
	4A53 BA             CP D
	4A54 D8             RET C
	4A55 7B             LD A,E
	4A56 FE 20          CP 20												DOOR_LOW - 4
	4A58 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Return NC if within the interval associated with the door.
;; Specifically, returns NC if H <= DOOR_HIGH and L >= DOOR_LOW
.UD_InFrame:
	4A59 3E 2C          LD A,2C												DOOR_HIGH
	4A5B BC             CP H
	4A5C D8             RET C
	4A5D 7D             LD A,L
	4A5E FE 24          CP 24												DOOR_LOW
	4A60 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Same, but for the whole door, not just the inner arch
.UD_InFrameW:
	4A61 3E 30          LD A,30												DOOR_HIGH + 4
	4A63 BC             CP H
	4A64 D8             RET C
	4A65 7D             LD A,L
	4A66 FE 20          CP 20												DOOR_LOW - 4
	4A68 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Door height check.
;;
;; Checks to see if the character Z coord (in A) is between B
;; and either B + 3 or B + 9 (depending on if you're both head
;; and heels currently). Returns NC if the character is in the right
;; height range to go through door.
.DoorHeightCheck:
	4A69 90             SUB B
	4A6A D8             RET C
	4A6B F5             PUSH AF
	4A6C 3A 84 24       LD A,(selected_characters)							get selected_characters
	4A6F FE 03          CP 03
	4A71 20 05          JR NZ,dhc_1
	4A73 F1             POP AF
	4A74 FE 03          CP 03
	4A76 3F             CCF
	4A77 C9             RET
dhc_1:
	4A78 F1             POP AF
	4A79 FE 09          CP 09
	4A7B 3F             CCF
	4A7C C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Points IX at the room boundaries, sets zero flag (can't leave room) if:
;; Bit 0 of IY+O_SPRFLAGS is not zero, or bottom 7 bits of IY+0A are not zero.
;;
;; Assumes IY points at the object.
;; Returns with zero flag set if it can't leave the room.
;; Also points IX at the room boundaries.
;;
;; TODO: Can't leave room if it's a not a player, or the object
;; function is zero'd.
.ChkCantLeave:
	4A7D DD 21 C2 1E    LD IX,Max_min_UV_Table								MinU
	4A81 FD CB 09 46    BIT 0,(IY+O_SPRFLAGS)								Low bit of sprite flag (TODO: Is player?)
	4A85 C8             RET Z												; If it's zero, can't leave room.
	4A86 FD 7E 0A       LD A,(IY+O_FUNC)									(IY+$0A) ; Check the object function...
	4A89 E6 7F          AND 7F
	4A8B D6 01          SUB 01
	4A8D D8             RET C												; If fn is 0, zero not set, can leave
	4A8E AF             XOR A
	4A8F C9             RET													; in other cases, can.

;; -----------------------------------------------------------------------------------------------------------
;; HL points to the object to check + 2.
;; Assumes flags are in range 0-3.
;; Returns fixed height of 6 in E.
;; Returns V extent in B, U extent in C.
;; Leaves HL pointing at the U coordinate.
.GetSimpleSize:
	4A90 23             INC HL
	4A91 23             INC HL
	4A92 7E             LD A,(HL)											 ; Load flags into A.
	4A93 23             INC HL
	4A94 1E 06          LD E,06												 ; Fixed height of 6.
	4A96 CB 4F          BIT 1,A
	4A98 20 08          JR NZ,GSS_1
	;; Cases 0, 1:
	4A9A 1F             RRA
	4A9B 3E 03          LD A,03
	4A9D CE 00          ADC A,00
	4A9F 47             LD B,A
	4AA0 4F             LD C,A
	4AA1 C9             RET													Either 3x3 or 4x4.

GSS_1:																		Cases 2, 3:
	4AA2 1F             RRA
	4AA3 38 04          JR C,GSS_2
	;; Case 2:
	4AA5 01 04 01       LD BC,0104
	4AA8 C9             RET													; 1x4

GSS_2:
	4AA9 01 01 04       LD BC,0401
	4AAC C9             RET													; 4x1

;; -----------------------------------------------------------------------------------------------------------
.Double_size_char_buffer:
	4AAD 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00					16 bytes Buffer for the double-height characters

;; -----------------------------------------------------------------------------------------------------------
.current_pen_number:
	4ABD DATABYTE 02											 			(02 by default)
.Char_cursor_pixel_position:
	4ABE DATAWORD 40 80											 			low byte = x(col) ; high byte = y(row)
.text_size:
	4AC0 DATABYTE 00     													Text height size variable (0:single; none-0:double)
.rainbow_mode:
	4AC1 DATABYTE FF														Rainbow mode On (00) or Off ("not 00")

;; -----------------------------------------------------------------------------------------------------------
;; This will Print a string and in the meantime handles the attribute
;; codes inserted within the string data.
;; -----------------------------------------------------------------------------------------------------------
;; If the string code is >= #80, then use the string data defined in the string tables:
;;  * String ID #80 to #CB come from String_Table_1 index 0 to #4B;
;;  * String ID #E0 to #FF come from String_Table_2 index 0 to #1F.
;; But we can also use the following codes:
;; 	 00 : Wipe Screen effect
;; 	 01 : New Line
;; 	 02 : Space to erase until the end of the line
;;   03 : Text_single_size (double height Off)
;;   04 : Text_double_size (double height On)
;;   05 xx : Color attribute
;;			xx = 00 : Rainbow (each letter changes the color)
;;				 else : color (1, 2 or 3)
;; 	 06 xx yy : Set_Text_Position col xx, row yy
;; 	 07 xx : Color scheme
;; Char symbols:
;;   21 : Menu Arrow type 1
;;   22 : Menu Arrow type 2
;;   23 : Menu Arrow type 3
;;   24 : Menu Arrow type 4
;;   25 : Lightning icon (speed)
;;   26 : Spring icon (jump)
;;   27 : Shield icon
;; Also, we can use these Macros:
;;   B0 xx yy : macro for 00 + 07 09 + 04 + 06, hence must also be followed by xx yy
;;	 B1 : macro for B9 05 14
;;	 B2 : macro for B9 19 14
;;	 B3 : macro for B9 19 17
;;	 B4 : macro for B9 05 17
;;   B5 : macro for 04 06 12 16
;;   B6 : macro for 04 06 0C 16
;;   B7 : macro for B9 01 11
;;   B8 : macro for 03 82 06 1A 13 followed by the 4 items (Spring, Shield, Speed, Shield)
;;	 B9 xx yy : macro for 03 + 06, hence must also be followed by xx yy
;; -----------------------------------------------------------------------------------------------------------
.Print_String:
	;; The jump address (function reentry) at 4AC3 will be updated in Control_Codes_more:
	;; Can be either:
	;; * Control_Code_attribute_5, 6 or 7 (will be followed by parameters (resp. 1, 2 and 1));
	;; * or, at the end of Control_Codes_more, reset back to Print_Char_base (with no parameter).
smc_print_string_routine:
	4AC2 C3 C5 4A       JP Print_Char_base									; self modified code, the addr is set at Control_Codes_more;
	;;4AC3 DATAWORD C5 4A													; default Print_Char_base (4AC5) else (Control_Code_attribute_5, 6 or 7)
.Print_Char_base:
	4AC5 FE 80          CP 80												; compare A with #80; if A < #80 then Carry is set, else Carry is reset
	4AC7 30 31          JR NC,Sub_Print_String								; Continue on Sub_Print_String if A >= #80 (will RET), else:
	4AC9 D6 20          SUB 20												; to test if was below or above #20
	4ACB 38 3E          JR C,Control_Codes									; if code was below 20 go to Control_Codes; will RET
	4ACD CD 80 05       CALL Char_code_to_Addr								; else it is a plain char, go to Char_code_to_Addr addr in DE (reminder: a "SUB 20" was done)
	4AD0 21 04 08       LD HL,0804											; sprite size : x=2x4 (2 pix per byte) ; y=8
	4AD3 3A C0 4A       LD A,(text_size)									; get Text height size (0:single (Z=1) or 1:double (NZ=1))
	4AD6 A7             AND A												; check if size was 0 or 1
	4AD7 C4 9F 4B       CALL NZ,Double_sized_char							; if Double size, then call Double_sized_char input:DE=symbol data, output:DE=buffer where the zoomed sprite is, HL=new size
	4ADA ED 4B BE 4A    LD BC,(Char_cursor_pixel_position)					; get Char cursor addr position B=y, C=x
	4ADE 79             LD A,C
	4ADF C6 04          ADD A,04											; col+4 (next pixel x position)
	4AE1 32 BE 4A       LD (Char_cursor_pixel_position),A					; write new Char cursor addr position
	4AE4 3A C1 4A       LD A,(rainbow_mode)									; get rainbowmode On/Off
	4AE7 A7             AND A												; test it
	4AE8 3A BD 4A       LD A,(current_pen_number)							; get current pen number
	4AEB 20 0A          JR NZ,pcb_end										; if Rainbow mode Off, then jump pcb_end
	4AED 3C             INC A												; else Rainbow mode is On so loop color to the next one
	4AEE E6 03          AND 03												; clamping it if needed (0,1,2,3 then back to 0)
	4AF0 37             SCF													; set carry flag
	4AF1 20 01          JR NZ,pcb_notr										; if new color not 0, then go pcb_notr
	4AF3 3C             INC A												; else +1 so we are in fact looping 1,2,3,1,2,3...
pcb_notr:
	4AF4 32 BD 4A       LD (current_pen_number),A							; store current pen number
pcb_end:
	4AF7 C3 B0 08       JP Draw_Sprite										; will RET

.Sub_Print_String:
	4AFA E6 7F          AND 7F												; A was >= #80, clear bit7 ("substract" #80)
	4AFC CD 8A 4B       CALL Get_string_address_in_table
print_char_until_delimiter
	4AFF 7E             LD A,(HL)											; get current Cursor_position_code
	4B00 FE FF          CP FF												; has reached Delimiter? (A == #FF?)
	4B02 C8             RET Z												; if Delimiter reached then RET
	4B03 23             INC HL												; else: next char position
	4B04 E5             PUSH HL												; store new char position
	4B05 CD C2 4A       CALL Print_String
	4B08 E1             POP HL												; restores surrent char position
	4B09 18 F4          JR print_char_until_delimiter						; loop

;; -----------------------------------------------------------------------------------------------------------
;; Available string attribute codes:
;; 	 00 : Wipe Screen effect
;; 	 01 : New Line
;; 	 02 : Space to erase until the end of the line
;;   03 : Text_single_size (double height Off)
;;   04 : Text_double_size (double height On)
;;   05 xx : Color attribute
;;			xx = 00 : Rainbow (each letter changes the color)
;;				 else : color (1, 2 or 3)
;; 	 06 xx yy : Set_Text_Position col xx, row yy
;; 	 07 xx : Color scheme
;; -----------------------------------------------------------------------------------------------------------
;; First part of the string attributes parsing. Handles the codes
;; 0 to 4. It'll jump to Control_Codes_more for codes 5 to 7
.Control_Codes:																; Handles Codes 0 to 4
	4B0B C6 20          ADD A,20											; We did a SUB 20 before, so add it back!
	4B0D FE 05          CP 05												; A < 5 ?
	4B0F 30 31          JR NC,Control_Codes_more							; jump Control_Codes_more if A >= 5
	4B11 A7             AND A												; A == 0?
	4B12 CA 65 08       JP Z,Draw_wipe_and_Clear_Screen						; if Code 0 jump Draw_wipe_and_Clear_Screen ; will RET
	4B15 D6 02          SUB 02												; Test codes 1 (C set) and 2 (Z set)
	4B17 38 14          JR C,Control_Code_new_line							; if Code = 1 jump Control_Code_new_line; will RET; else:
	4B19 28 05          JR Z,Control_Code_space_erase_end					; if Code = 2 jump Control_Code_space_erase_end; will RET, else:
	4B1B 3D             DEC A												; Test if codes 3 (A=0) or 4 (A=1)
	4B1C 32 C0 4A       LD (text_size),A									; Set Text size 0 = single height or 1 = double height
	4B1F C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This is the string attribute 02: clear the line from current cursor
;; position to the end of line (erase any old character that could
;; remain when text has changed)
Control_Code_space_erase_end:
	4B20 3A BE 4A       LD A,(Char_cursor_pixel_position))					; Char cursor addr position
	4B23 FE C0          CP C0												; has reached right border?
	4B25 D0             RET NC												; if yes, RET
	4B26 3E 20          LD A,20												; else : String " "
	4B28 CD C2 4A       CALL Print_String
	4B2B 18 F3          JR Control_Code_space_erase_end						; loop

;; -----------------------------------------------------------------------------------------------------------
;; This is the string attribute 01: "New line" (go to begining of next line)
.Control_Code_new_line:
	4B2D 2A BE 4A       LD HL,(Char_cursor_pixel_position)					; Char cursor addr position H=y, L=x
	4B30 3A C0 4A       LD A,(text_size)									; get Text height size
	4B33 A7             AND A												; test if single size (0) or double (1)
	4B34 7C             LD A,H												; A = row
	4B35 28 02          JR Z,ccnewln_single									; jump over one of the ADD below if single height, else do both!
	4B37 C6 08          ADD A,08											; Next char pixel row   (if double size do it twice)
ccnewln_single:
	4B39 C6 08          ADD A,08											; Next char pixel row (if single size do it once)
	4B3B 67             LD H,A												; refresh cursor address ...
	4B3C 2E 40          LD L,40												; ... position to ...
	4B3E 22 BE 4A       LD (Char_cursor_pixel_position),HL					; ...newline position
	4B41 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Next part of the string attributes parsing. Here it'll handle the
;; codes 5, 6 and 7; these are followed by parameters
.Control_Codes_more:														; Handles Codes 5, 6 and 7
	4B42 21 5A 4B       LD HL,Control_Code_attribute_5_setmode				; prepare jump address Control_Code_attribute_5_setmode
	4B45 28 0A          JR Z,Update_attribute_jump_address					; if Code = 5 jump Color_attribute ; Update_attribute_jump_address
	4B47 FE 07          CP 07												; test if Code 7
	4B49 21 55 4B       LD HL,Control_Code_attribute_7_setscheme			; prepare jump address Control_Code_attribute_7_setscheme
	4B4C 28 03          JR Z,Update_attribute_jump_address					; if Code 7 : Update_attribute_jump_address
	4B4E 21 68 4B       LD HL,Control_Code_attribute_6_getcol				; else code 6 : jump address Control_Code_attribute_6_getcol
.Update_attribute_jump_address:
	4B51 22 C3 4A       LD (smc_print_string_routine+1),HL					; update entry jump address of Print_String self mod code
	4B54 C9             RET

;; -----------------------------------------------------------------------------------------------------------
.Control_Code_attribute_7_setscheme:
	4B55 CD 2C 05       CALL Set_colors
	4B58 18 09          JR Control_Code_attribute_funnel					; back to default jump address Print_Char_base

.Control_Code_attribute_5_setmode:
	4B5A A7             AND A												; test color attribute
	4B5B 32 C1 4A       LD (rainbow_mode),A									; update rainbow mode (00 or "not 0")
	4B5E 28 03          JR Z,Control_Code_attribute_funnel					; if we had the "05 00" rainbow mode on attribute, then can leave
	4B60 32 BD 4A       LD (current_pen_number),A							; else need to set the pen number 1, 2, or 3
.Control_Code_attribute_funnel:
	4B63 21 C5 4A       LD HL,Print_Char_base								; back to default jump address Print_Char_base
	4B66 18 E9          JR Update_attribute_jump_address

.Control_Code_attribute_6_getcol:
	4B68 21 74 4B       LD HL,Control_Code_attribute_6_getrow				; next jump address will be Control_Code_attribute_6_getrow
	4B6B 87             ADD A,A
	4B6C 87             ADD A,A
	4B6D C6 40          ADD A,40											; next pix pos = 4xcol+#40  (#40 is the minX in pix coord, *4 : 4 pix per bytes)
	4B6F 32 BE 4A       LD (Char_cursor_pixel_position),A					; update char pix X address
	4B72 18 DD          JR Update_attribute_jump_address

.Control_Code_attribute_6_getrow:
	4B74 87             ADD A,A
	4B75 87             ADD A,A
	4B76 87             ADD A,A												; next pix pox = 8 * row
	4B77 32 BF 4A       LD (Char_cursor_pixel_position+1),A					; update char pix Y address
	4B7A 18 E7          JR Control_Code_attribute_funnel					; back to default jump address Print_Char_base

;; -----------------------------------------------------------------------------------------------------------
;; Produce a String attribute 06 (position "LOCATE")
;; Input: BC is the position;
;; Output: HL = pointer on Cursor_position_code string attribute.
.Set_Cursor_position:
	4B7C ED 43 87 4B    LD (Cursor_position_code+1),BC						; Update Cursor_position_code position from BC
	4B80 21 86 4B       LD HL,Cursor_position_code							; point Cursor_position_code
	4B83 C3 FF 4A       JP print_char_until_delimiter						; (will end up with a RET)

;; -----------------------------------------------------------------------------------------------------------
;; This produce a "String" attribute code 06 (position).
;; the position is set by Set_Cursor_position
.Cursor_position_code:
	4B86 DATABYTE 06														; cursor_position code
	4B87 DATAWORD 00 00														; Will be updated at address 4B7C
	4B89 DATABYTE FF														; delimiter code

;; -----------------------------------------------------------------------------------------------------------
;; This will find the pointer on the String we are looking for.
;; The "String ID AND #7F" is in A.
;;  * String ID #80 to #CB come from String_Table_1 index 0 to #4B;
;;  * String ID #E0 to #FF come from String_Table_2 index 0 to #1F.
;; Output: HL = pointer on the wanted String data.
.Get_string_address_in_table:
	4B8A 47             LD B,A												; B = Index of the String in the table (ID#80 -> B=0, ID#81 -> B=1, etc..)
	4B8B 21 31 31       LD HL,String_Table_1								; String_Table_1 base addr (ID #80 to #CB)
	4B8E D6 60          SUB 60												; test if code was >= #E0 (reminder: (ID AND 7F) SUB 60)
	4B90 38 04          JR C,got_tab										; If code was not from String_Table_2, then (is from String_Table_1) jump got_tab
	4B92 21 09 09       LD HL,String_Table_2								; change to table String_Table_2 base addr (ID #E0 to #FF)
	4B95 47             LD B,A
got_tab:
	4B96 04             INC B												; jump over 1rst Delimiter (tables start with FF)
search_nth_Delimiter:
	4B97 3E FF          LD A,FF												; code to look for (Delimiter)
loop_search_nth_Delimiter
	4B99 4F             LD C,A
	4B9A ED B1          CPIR												; Repeat CPI (CP (HL) ; INC HL ; DEC BC) until BC=0 or A=(HL); find first occurance.
	4B9C 10 FB          DJNZ loop_search_nth_Delimiter						; B-- ; Jump if B!=0
	4B9E C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This creates a zoomed char sprite from the original char
;; Output: DE will point on the double sized char buffer
.Double_sized_char:
	4B9F 06 08          LD B,08												; 8 original lines in char symbol
	4BA1 21 AD 4A       LD HL,Double_size_char_buffer						; Double_size_char_buffer
dsc_loop:
	4BA4 1A             LD A,(DE)											; get char symbol byte
	4BA5 77             LD (HL),A											; put it once
	4BA6 23             INC HL
	4BA7 77             LD (HL),A											; put it twice!
	4BA8 23             INC HL
	4BA9 13             INC DE												; next byte
	4BAA 10 F8          DJNZ dsc_loop
	4BAC 21 04 10       LD HL,1004											; sprite size : x=2x4 (2 pix per byte) ; y=16 (#10)
	4BAF 11 AD 4A       LD DE,Double_size_char_buffer						; Double_size_char_buffer
	4BB2 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; This will define the following functions:
;;  * Print_2Digits_LeftAligned : 2-digits, Left aligned, No leading "0" (but if 0 print "0 ")
;;  * Print_2Digits_RightAligned : 2-digits, Right aligned (Pad with spaces), No leading "0" (but if 0 print " 0")
;;  * Print_4Digits_LeftAligned : 4-digits, Left aligned, No leading "0" (but if 0 print "0 ")
;; Input: A = BCD 2-digit value to print (DE is a "don't care" here)
;;     OR DE = = BCD 4-digit value to print (A is a "don't care" here)
;;		  C = bitmap for the leading "0"s so that the lsb bit controls the highest power-of-10 digit
;;			  In that bitmap, a "1" means "prints a leading 0", a "0" means "look at bitmap in B.
;;		  B = bitmap used if the corresponding bit in C is 0;
;;			  In that bitmap, a "1" means print a Space instead of the corresponding 0 or as a padding;
;;                            a "0" means break (no leading 0, so do not need to continue parsing); RET with NC
.Print_4Digits_LeftAligned:
	;; Left align, no leading zero.
	4BB3 01 F8 00       LD BC,00F8											; 4 digits Left aligned, No leading "0" (but if 0 print "0 ")
	4BB6 D5             PUSH DE
	4BB7 7A             LD A,D
	4BB8 CD C7 4B       CALL print_2Digits									; print higher digits
	4BBB D1             POP DE
	4BBC 7B             LD A,E
	4BBD 18 08          JR print_2Digits									; print lower digits

.Print_2Digits_RightAligned:
	4BBF 01 FE FF       LD BC,FFFE				 							; Right aligned (Pad with spaces), No leading "0" (but if 0 print " 0")
	4BC2 18 03          JR print_2Digits
.Print_2Digits_LeftAligned:
	4BC4 01 FE 00       LD BC,00FE											; Left aligned, No leading "0" (but if 0 print "0 ")
.print_2Digits:
	4BC7 F5             PUSH AF												; save A
	4BC8 1F             RRA
	4BC9 1F             RRA
	4BCA 1F             RRA
	4BCB 1F             RRA													; int(A >> 4) (get high BCD nibble)
	4BCC CD D0 4B       CALL Sub_PrintDigit										; print it
	4BCF F1             POP AF												; restore value in A and print the low BCD nibble:
.Sub_PrintDigit:
	4BD0 E6 0F          AND 0F												; A MOD 16 (get low BCD nibble)
	4BD2 20 09          JR NZ,print_it										; if not 0 jump print_it, else:
	4BD4 CB 09          RRC C												; get bit0 of C in Carry and Circular Right rotate C
	4BD6 38 05          JR C,print_it										; if Carry=1, print the "0" out, else:
	4BD8 CB 08          RRC B												; get bit0 of B in Carry and Circular Right rotate B
	4BDA D0             RET NC												; if Carry=0, leave with Carry reset, else print out a "Space"
	4BDB 3E F0          LD A,F0												; A = #F0 (after the add 30, it'll become #20 = " ")
print_it:
	4BDD 0E FF          LD C,FF												; if Sub_PrintDigit recalled, we will print the "0"s from now ()
	4BDF C6 30          ADD A,30											; Convert number (0 to 9) to corresponding ASCII, and #F0 to " "so if value is "00" we will always at least print "0"
	4BE1 C5             PUSH BC
	4BE2 CD C2 4A       CALL Print_String									; Print it!
	4BE5 C1             POP BC
	4BE6 37             SCF													; leave with Carry set
	4BE7 C9             RET

;; -----------------------------------------------------------------------------------------------------------
;; Bit 0 set = have updated object extents
;; Bit 1 set = needs redraw
DrawFlags:
	4BE8 DATABYTE 00
Collided:
	4BE9 DATABYTE FF
RobotDir:
	4BEA DATABYTE FF

;; -----------------------------------------------------------------------------------------------------------
ObjFnJoystick:
	4BEB FD 7E 0C       LD A,(IY+0C)
	4BEE FD 36 0C FF    LD (IY+0C),FF
	4BF2 F6 F0          OR F0
	4BF4 FE FF          CP FF
	4BF6 C8             RET Z
	4BF7 32 EA 4B       LD (RobotDir),A
	4BFA C9             RET

;; -----------------------------------------------------------------------------------------------------------
ObjFnRobot:
	4BFB CD 29 50       CALL ObjAgain8
	4BFE 21 EA 4B       LD HL,RobotDir
	4C01 7E             LD A,(HL)
	4C02 36 FF          LD (HL),FF
	4C04 F5             PUSH AF
	4C05 CD 0F 44       CALL Get_dir_code_LRDU_bitmap
	4C08 3C             INC A
	4C09 D6 01          SUB 01
	4C0B D4 2B 4F       CALL NC,MoveDir
	4C0E F1             POP AF
	4C0F CD EF 4F       CALL ObjAgain6
	4C12 CD DF 4F       CALL FaceAndAnimate
	4C15 C3 C7 4F       JP ObjDraw

;; -----------------------------------------------------------------------------------------------------------
ObjFnTeleport:
	4C18 FD CB 0C 6E    BIT 5,(IY+0C)
	4C1C C0             RET NZ
	4C1D CD DF 4F       CALL FaceAndAnimate
	4C20 CD C7 4F       CALL ObjDraw
	4C23 06 47          LD B,47												Sound_ID #47 : Teleporter waiting noise
	4C25 C3 91 0D       JP Play_Sound	 									will RET

;; -----------------------------------------------------------------------------------------------------------
;; Function OBJFN_CANNONBALL #24 associated to the ObjDefns object #3C :
;; Cannon Balls (Sprite SPR_BALL) in the Victory room.
;; It launches a new Cannon ball when delay_CannonBall reaches 0 and
;; resets it to #60, so that, as long as a Cannon Ball exists,
;; delay_CannonBall won't be able to be 0, thus preventing the
;; Game_over in Victory_Room.
;; A launched cannon ball will have the behaviour of a fired Donut
;; (function id #19) and will get destroyed. When all Cannon Balls in
;; the Victory room have been destroyed, delay_CannonBall will reach
;; 0 and the Victory room celebration will end and go to Game_over.
delay_CannonBall:
	4C28 DATABYTE 60														; delay_CannonBall #60 by default, receives #40 at init, then #60 in ObjFnCannonFire

ObjFnCannonFire:
	4C29 21 28 4C       LD HL,delay_CannonBall								; delay_CannonBall
	4C2C 7E             LD A,(HL)											; read value
	4C2D A7             AND A												; and test
	4C2E C0             RET NZ												; if not 0 leave; else:
	4C2F 36 60          LD (HL),60											; reset delay before firing next Canon Ball;
	4C31 FD 36 0B F7    LD (IY+0B),F7										; update (IY+$0B),~$08
	4C35 FD 36 0A 19    LD (IY+O_FUNC),19									; update object function #19 = OBJFN_FIRE (cannon ball is similar to firing a donut: fired then destroyed)
	4C39 3E 05          LD A,05												; play Cannon fired sound
	4C3B C3 1C 2B       JP SetSound											; will RET

;; -----------------------------------------------------------------------------------------------------------
ObjFn35Val:
	4C3E DATABYTE 00

ObjFn35:
	4C3F 21 3E 4C       LD HL,ObjFn35Val
	4C42 36 FF          LD (HL),FF
	4C44 E5             PUSH HL
	4C45 CD 4C 4C       CALL ObjFn35b
	4C48 E1             POP HL
	4C49 36 00          LD (HL),00
	4C4B C9             RET

;; -----------------------------------------------------------------------------------------------------------
ObjFn35b:
	4C4C 3A F0 36       LD A,(ObjDir)
	4C4F 3C             INC A
	4C50 20 40          JR NZ,ObjFnEnd2
	4C52 FD 7E 0C       LD A,(IY+0C)
	4C55 E6 20          AND 20
	4C57 C0             RET NZ
	4C58 ED 4B AB 24    LD BC,(character_direction)							get character_direction in C
	4C5C 18 13          JR ObjFnEnd

ObjFn32:
	4C5E 3A F0 36       LD A,(ObjDir)
	4C61 3C             INC A
	4C62 20 2E          JR NZ,ObjFnEnd2
	4C64 CD 79 4F       CALL CharDistAndDir
	4C67 F6 F3          OR F3												~$0C	; Clear one axis of direction bits
	4C69 B9             CP C
	4C6A 28 05          JR Z,ObjFnEnd
	4C6C 79             LD A,C
	4C6D F6 FC          OR FC
	4C6F B9             CP C
	4C70 C0             RET NZ
ObjFnEnd:
	4C71 FD 71 0C       LD (IY+0C),C
	4C74 18 1C          JR ObjFnEnd2

;; -----------------------------------------------------------------------------------------------------------
; The function associated with a firing donut object.
ObjFnFire:
	4C76 CD E2 4F       CALL AnimateMe
	4C79 CD A7 4C       CALL ObjFnSub
	4C7C 38 03          JR C,ObjFF2
	4C7E CD A7 4C       CALL ObjFnSub
ObjFF2:
	4C81 DA 6D 4D       JP C,Fadeify
	4C84 18 12          JR ObjDraw2

ObjFnBall:
	4C86 3A F0 36       LD A,(ObjDir)
	4C89 3C             INC A
	4C8A 20 06          JR NZ,ObjFnEnd2
	4C8C FD 7E 0C       LD A,(IY+0C)
	4C8F 3C             INC A
	4C90 28 09          JR Z,ObjFnEnd4
ObjFnEnd2:
	4C92 CD 29 50       CALL ObjAgain8
	4C95 CD A7 4C       CALL ObjFnSub
ObjDraw2:
	4C98 C3 C7 4F       JP ObjDraw

ObjFnEnd4:
	4C9B FD E5          PUSH IY
	4C9D CD DC 4D       CALL ObjFnPushable
	4CA0 FD E1          POP IY
	4CA2 FD 36 0B FF    LD (IY+0B),FF
	4CA6 C9             RET

ObjFnSub:
	4CA7 3A F0 36       LD A,(ObjDir)
	4CAA FD A6 0C       AND (IY+0C)
	4CAD CD 0F 44       CALL Get_dir_code_LRDU_bitmap
	4CB0 FE FF          CP FF
	4CB2 37             SCF
	4CB3 C8             RET Z
	4CB4 CD D0 4C       CALL MoveCurr
	4CB7 D8             RET C
	4CB8 F5             PUSH AF
	4CB9 CD B6 4F       CALL UpdateObjExtents
	4CBC F1             POP AF
	4CBD F5             PUSH AF
	4CBE CD 52 44       CALL UpdateCurrPos
	4CC1 F1             POP AF
	4CC2 2A 3E 4C       LD HL,(ObjFn35Val)										L = ObjFn35Val byte (0 or FF)
	4CC5 2C             INC L													+1
	4CC6 C8             RET Z													RET if was FF, else:
	4CC7 CD D0 4C       CALL MoveCurr
	4CCA D8             RET C
	4CCB CD 52 44       CALL UpdateCurrPos
	4CCE A7             AND A
	4CCF C9             RET

;; -----------------------------------------------------------------------------------------------------------
.MoveCurr:
	4CD0 2A EE 36       LD HL,(CurrObject)
	4CD3 C3 5C 46       JP Move

;; -----------------------------------------------------------------------------------------------------------
ObjFnSwitch:
    ;; First check if we're touched. If not, clear $11 and return.
	4CD6 FD 7E 0C       LD A,(IY+0C)
	4CD9 F6 C0          OR C0
	4CDB 3C             INC A
	4CDC 20 04          JR NZ,objfnsw_1
	4CDE FD 77 11       LD (IY+O_SPECIAL),A
	4CE1 C9             RET

;; Otherwise, check if there was a previous touch.
;; If so, clear $0C and return.
objfnsw_1:
	4CE2 FD 7E 11       LD A,(IY+O_SPECIAL)
	4CE5 A7             AND A
	4CE6 28 05          JR Z,objfnsw_2
	4CE8 FD 36 0C FF    LD (IY+0C),FF
	4CEC C9             RET

;; Mark as previously touched...
objfnsw_2:
	4CED FD 35 11       DEC (IY+O_SPECIAL)
	4CF0 CD 24 50       CALL ObjAgain7
	;; Call PerObj on each object in the main object list...
	4CF3 21 AB 39       LD HL,ObjectLists + 2
objfnsw_loop:
	4CF6 7E             LD A,(HL)
	4CF7 23             INC HL
	4CF8 66             LD H,(HL)
	4CF9 6F             LD L,A
	4CFA B4             OR H
	4CFB 28 0A          JR Z,objfnsw_3
	4CFD E5             PUSH HL
	4CFE E5             PUSH HL
	4CFF DD E1          POP IX
	4D01 CD 15 4D       CALL PerObjSwitch							    	Call with the object in HL and IX
	4D04 E1             POP HL
	4D05 18 EF          JR objfnsw_loop

;; End part, mark for redraw and toggle the switch state flag.
objfnsw_3:
	4D07 CD E6 4F       CALL MarkToDraw
	4D0A FD 7E 04       LD A,(IY+O_FLAGS)
	4D0D EE 10          XOR 10
	4D0F FD 77 04       LD (IY+O_FLAGS),A
	4D12 C3 C7 4F       JP ObjDraw

.PerObjSwitch:
	4D15 DD 7E 0A       LD A,(IX+O_FUNC)
	4D18 E6 7F          AND 7F
	4D1A FE 0E          CP 0E												OBJFN_SWITCH
	4D1C C8             RET Z
	4D1D FE 11          CP 11												OBJFN_FADE
	4D1F C8             RET Z
	;; If neither bit 3 or 1 of $09 is set, toggle bit 7.
	4D20 DD 7E 09       LD A,(IX+O_SPRFLAGS)
	4D23 4F             LD C,A
	4D24 E6 09          AND 09
	4D26 C0             RET NZ
	4D27 79             LD A,C
	4D28 EE 40          XOR 40
	4D2A DD 77 09       LD (IX+O_SPRFLAGS),A
	4D2D C9             RET

;; -----------------------------------------------------------------------------------------------------------
ObjFnHeliplat2:
	4D2E 3E 90          LD A,90
	4D30 01 3E 52       LD BC,523E											; LD BC,nn , NOPs next instruction!  ObjFnHeliplat:  LD	A,$52
	4D33 FD 77 11       LD (IY+O_SPECIAL),A
	4D36 FD 36 0A 10    LD (IY+O_FUNC),10									#10 = OBJFN_HELIPLAT3
	4D3A C9          	RET

ObjFn19:
	4D3B FD CB 0C 6E    BIT 5,(IY+0C)
	4D3F C0             RET NZ
	4D40 CD 2F 50       CALL ObjAgain9
	4D43 C3 C7 4F       JP ObjDraw

;; -----------------------------------------------------------------------------------------------------------
; Rollers in the various directions
ObjFnRollers1
	4D46 3E FE          LD A,FE												~$01
	4D48 18 0A          JR WriteRollerDir
ObjFnRollers2:
	4D4A 3E FD          LD A,FD												~$02
	4D4C 18 06          JR WriteRollerDir
ObjFnRollers3:
	4D4E 3E F7          LD A,F7												~$08
	4D50 18 02          JR WriteRollerDir
ObjFnRollers4:
	4D52 3E FB          LD A,FB												~$04
.WriteRollerDir:
	4D54 FD 77 0B       LD (IY+0B),A
	4D57 FD 36 0A 00    LD (IY+O_FUNC),00
	4D5B C9             RET

;; -----------------------------------------------------------------------------------------------------------
ObjFnHushPuppy:
	4D5C 3A 84 24       LD A,(selected_characters)							get selected_characters
	4D5F E6 02          AND 02												; Test bit1 if we have Head (returns early if not)
	4D61 18 09          JR TestAndFade

;; -----------------------------------------------------------------------------------------------------------
; FIXME: Theory is this is for the dissolving wall grating next to the hooter
ObjFnDissolve:
	4D63 3E C0          LD A,C0
	4D65 01 3E CF       LD BC,CF3E											; LD BC,nn , NOPs next instruction! ; ObjFnDissolve2: LD	A,$CF
	4D68 FD B6 0C       OR (IY+0C)
	4D6B 3C             INC A
.TestAndFade:
	4D6C C8             RET Z												if it is Heels, then nothing to do, else:
; Set to use ObjFnFade
Fadeify:																	Make the HushPuppies disappear if Head enters the room
	4D6D 3E 05          LD A,05
	4D6F CD 1C 2B       CALL SetSound
	4D72 FD 7E 0A       LD A,(IY+O_FUNC)
	4D75 E6 80          AND 80
	4D77 F6 11          OR 11												OBJFN_FADE
	4D79 FD 77 0A       LD (IY+O_FUNC),A
	4D7C FD 36 0F 08    LD (IY+O_ANIM),08
ObjFnFade:
	4D80 FD 36 04 80    LD (IY+O_FLAGS),80
	4D84 CD B6 4F       CALL UpdateObjExtents
	4D87 CD E2 4F       CALL AnimateMe
	4D8A FD 7E 0F       LD A,(IY+O_ANIM)
	4D8D E6 07          AND 07
	4D8F C2 C7 4F       JP NZ,ObjDraw
ObjFnDisappear:
	4D92 2A EE 36       LD HL,(CurrObject)
	4D95 C3 CA 44       JP RemoveObject

;; -----------------------------------------------------------------------------------------------------------
ObjFnSpring:
	4D98 FD 46 08       LD B,(IY+O_SPRITE)
	4D9B FD CB 0C 6E    BIT 5,(IY+0C)
	4D9F FD CB 0C EE    SET 5,(IY+0C)
	4DA3 3E 2C          LD A,2C
	4DA5 28 1C          JR Z,br_4DC3
	4DA7 FD 7E 0F       LD A,(IY+O_ANIM)
	4DAA A7             AND A
	4DAB 20 10          JR NZ,br_4DBD
	4DAD 3E 2C          LD A,2C
	4DAF B8             CP B
	4DB0 20 2A          JR NZ,ObjFnPushable
	4DB2 FD 36 0F 50    LD (IY+O_ANIM),50
	4DB6 3E 04          LD A,04
	4DB8 CD 1C 2B       CALL SetSound
	4DBB 18 19          JR ObjFnStuff

br_4DBD
	4DBD E6 07          AND 07
	4DBF 20 15          JR NZ,ObjFnStuff
	4DC1 3E 2B          LD A,2B
br_4DC3
	4DC3 FD 77 08       LD (IY+O_SPRITE),A
	4DC6 FD 36 0F 00    LD (IY+O_ANIM),00
	4DCA B8             CP B
	4DCB 28 0F          JR Z,ObjFnPushable
	4DCD 18 07          JR ObjFnStuff

ObjFn26:
	4DCF FD 7E 0F       LD A,(IY+O_ANIM)
	4DD2 E6 F0          AND F0
	4DD4 28 06          JR Z,ObjFnPushable
ObjFnStuff:
	4DD6 CD B6 4F       CALL UpdateObjExtents
	4DD9 CD E2 4F       CALL AnimateMe
.ObjFnPushable:
	4DDC CD 29 50       CALL ObjAgain8
	4DDF 3E FF          LD A,FF
	4DE1 CD EF 4F       CALL ObjAgain6
	4DE4 C3 C7 4F       JP ObjDraw

ObjFn22:
	4DE7 21 2F 4F       LD HL,HalfTurn
	4DEA C3 2B 4E       JP ObjFnStuff2
ObjFn21:
	4DED 21 1D 4F       LD HL,Clockwise
	4DF0 C3 2B 4E       JP ObjFnStuff2
ObjFnVisor1:
	4DF3 21 2F 4F       LD HL,HalfTurn
	4DF6 18 39          JR TurnOnCollision
ObjFnMonocat:
	4DF8 21 1D 4F       LD HL,Clockwise
	4DFB 18 34          JR TurnOnCollision
ObjFnAnticlock:
	4DFD 21 24 4F       LD HL,Anticlockwise
	4E00 18 2F          JR TurnOnCollision
ObjFnBee
	4E02 21 10 4F       LD HL,DirAny
	4E05 18 2A          JR TurnOnCollision
; Random direction change, like a queen.
ObjFnRandQ:
	4E07 21 10 4F       LD HL,DirAny
	4E0A 18 59          JR TurnRandomly
; Random direction change, like a rook.
ObjFnRandR:
	4E0C 21 F4 4E       LD HL,DirAxes
	4E0F 18 54          JR TurnRandomly
; Random direction change, like a bishop.
ObjFnRandB:
	4E11 21 01 4F       LD HL,DirDiag
	4E14 18 4F          JR TurnRandomly
; Home in, like a robomouse.
ObjFnHomeIn:
	4E16 21 55 4F       LD HL,HomeIn
	4E19 18 36          JR GoThatWay

;; if we saved the 4 worlds, it gives us the capability to frighten some ennemies?
ObjFnCrowny:
	4E1B 3A EA 3D       LD A,(saved_World_Mask)								get saved_World_Mask
	4E1E F6 F0          OR F0												look at the 4 first crowns only
	4E20 3C             INC A												if #0F then become 0
	4E21 21 6D 4F       LD HL,MoveAway
	4E24 28 03          JR Z,crowny_1										if was #0F (we have 4 crowns) then make it MoveAway
	4E26 21 74 4F       LD HL,MoveTowards									else make it move towards
crowny_1:
	4E29 18 26          JR GoThatWay										move it the selected way

ObjFnStuff2:
	4E2B E5             PUSH HL
	4E2C CD DF 4F       CALL FaceAndAnimate
	4E2F 18 0B          JR ObjFnStuff5

.TurnOnCollision:
	4E31 E5             PUSH HL
.TurnOnColl2:
	4E32 CD DF 4F       CALL FaceAndAnimate
	4E35 CD 29 50       CALL ObjAgain8
	4E38 3E FF          LD A,FF
	4E3A 38 03          JR C,ObjFnStuff6
ObjFnStuff5:
	4E3C CD 7A 50       CALL ObjAgain11
ObjFnStuff6:
	4E3F CD EF 4F       CALL ObjAgain6
	4E42 E1             POP HL
	4E43 3A E9 4B       LD A,(Collided)
	4E46 3C             INC A
	4E47 CA C7 4F       JP Z,ObjDraw
	4E4A CD 50 4E       CALL DoTurn
	4E4D C3 C7 4F       JP ObjDraw

; Call the turning function provided earlier.
.DoTurn:
	4E50 E9             JP (HL)

.GoThatWay:
	4E51 E5             PUSH HL
	4E52 CD 29 50       CALL ObjAgain8
	4E55 E1             POP HL
	4E56 CD 50 4E       CALL DoTurn
.Collision33:
	4E59 CD DF 4F       CALL FaceAndAnimate
	4E5C CD 7A 50       CALL ObjAgain11
	4E5F CD EF 4F       CALL ObjAgain6
	4E62 C3 C7 4F       JP ObjDraw

; Turn randomly. If not turning randomly, act like TurnOnCollision.
.TurnRandomly:
	4E65 E5             PUSH HL
	; Pick a number. If not lucky, follow TurnOnCollision case.
	4E66 CD 97 44       CALL Random_gen
	4E69 7D             LD A,L
	4E6A E6 0F          AND 0F
	4E6C 20 C4          JR NZ,TurnOnColl2
	4E6E CD 29 50       CALL ObjAgain8
	4E71 E1             POP HL
	4E72 CD 50 4E       CALL DoTurn
	4E75 CD DF 4F       CALL FaceAndAnimate
	4E78 CD 7A 50       CALL ObjAgain11
	4E7B CD EF 4F       CALL ObjAgain6
	4E7E C3 C7 4F       JP ObjDraw

.HeliPadDir:
	4E81 DATABYTE 00

;; Running heliplat
ObjFnHeliplat3:
	4E82 3E 01          LD A,01												Sound_ID 01
	4E84 CD 1C 2B       CALL SetSound
	4E87 CD DF 4F       CALL FaceAndAnimate
	4E8A FD 7E 11       LD A,(IY+O_SPECIAL)
	4E8D 47             LD B,A
	4E8E CB 5F          BIT 3,A
	4E90 28 3C          JR Z,br_4ECE
	;; Bit 3 is set...
    ;; Calculate $C0 - (6 * A >> 4) - opposite direction in top bits!
	4E92 1F             RRA
	4E93 1F             RRA
	4E94 E6 3C          AND 3C
	4E96 4F             LD C,A
	4E97 0F             RRCA
	4E98 81             ADD A,C
	4E99 ED 44          NEG
	4E9B C6 C0          ADD A,C0
	4E9D FD BE 07       CP (IY+O_Z)
	; Above this level? Go to
	4EA0 30 16          JR NC,4EB8
	4EA2 2A EE 36       LD HL,(CurrObject)
	4EA5 CD 31 2E       CALL ChkSatOn
	4EA8 FD CB 0B A6    RES 4,(IY+0B)
	4EAC 30 02          JR NC,4EB0
	4EAE 28 41          JR Z,br_4EF1
	;; Ascend.
	4EB0 CD B6 4F       CALL UpdateObjExtents
	4EB3 FD 35 07       DEC (IY+O_Z)
	4EB6 18 39          JR br_4EF1

br_4EB8
	4EB8 21 81 4E       LD HL,HeliPadDir
	; Every other time (alternates 0/1):
	4EBB 7E             LD A,(HL)
	4EBC A7             AND A
	4EBD 20 02          JR NZ,br_4EC1
	4EBF 36 02          LD (HL),02
br_4EC1
	4EC1 35             DEC (HL)
	4EC2 20 2D          JR NZ,br_4EF1
	; Flip the movement direction
	4EC4 78             LD A,B
	4EC5 EE 08          XOR 08
	4EC7 FD 77 11       LD (IY+O_SPECIAL),A
	4ECA E6 08          AND 08
	4ECC 18 23          JR br_4EF1

br_4ECE
	; Calculate $BF - 6 * (A & 7): convert height to Z coord.
	4ECE E6 07          AND 07
	4ED0 87             ADD A,A
	4ED1 4F             LD C,A
	4ED2 87             ADD A,A
	4ED3 81             ADD A,C
	4ED4 ED 44          NEG
	4ED6 C6 BF          ADD A,BF
	4ED8 FD BE 07       CP (IY+O_Z)											Below this level?
	4EDB 38 DB          JR C,br_4EB8
	4EDD 2A EE 36       LD HL,(CurrObject)
	4EE0 CD F6 2C       CALL DoContact2
	4EE3 30 02          JR NC,br_4EE7
	4EE5 28 0A          JR Z,br_4EF1
br_4EE7
	; Descend
	4EE7 CD B6 4F       CALL UpdateObjExtents
	4EEA FD CB 0B AE    RES 5,(IY+0B)
	4EEE FD 34 07       INC (IY+O_Z)
br_4EF1
	4EF1 C3 C7 4F       JP ObjDraw

; An axis direction different to the current one.
DirAxes:
	4EF4 CD 97 44       CALL Random_gen
	4EF7 7D             LD A,L
	4EF8 E6 06          AND 06
	4EFA FD BE 10       CP (IY+O_DIRECTION)
	4EFD 28 F5          JR Z,DirAxes
	4EFF 18 2A          JR MoveDir

; A diagonal direction different to the current one.
.DirDiag:
	4F01 CD 97 44       CALL Random_gen
	4F04 7D             LD A,L
	4F05 E6 06          AND 06
	4F07 F6 01          OR 01
	4F09 FD BE 10       CP (IY+O_DIRECTION)
	4F0C 28 F3          JR Z,DirDiag
	4F0E 18 1B          JR MoveDir

; Any new direction at all.
.DirAny:
	4F10 CD 97 44       CALL Random_gen
	4F13 7D             LD A,L
	4F14 E6 07          AND 07
	4F16 FD BE 10       CP (IY+O_DIRECTION)
	4F19 28 F5          JR Z,DirAny
	4F1B 18 0E          JR MoveDir

; 90 degrees round clockwise.
.Clockwise:
	4F1D FD 7E 10       LD A,(IY+O_DIRECTION)
	4F20 D6 02          SUB 02
	4F22 18 05          JR ModMoveDir

; 90 degrees anticlockwise.
.Anticlockwise:
	4F24 FD 7E 10       LD A,(IY+O_DIRECTION)
	4F27 C6 02          ADD A,02
.ModMoveDir:
	4F29 E6 07          AND 07
.MoveDir:
	4F2B FD 77 10       LD (IY+O_DIRECTION),A
	4F2E C9             RET

;; -----------------------------------------------------------------------------------------------------------
; 180 degree half-turn.
.HalfTurn:
	4F2F FD 7E 10       LD A,(IY+O_DIRECTION)
	4F32 C6 04          ADD A,04
	4F34 18 F3          JR ModMoveDir

;; -----------------------------------------------------------------------------------------------------------
ObjFn33:
	4F36 CD 29 50       CALL ObjAgain8
	; Check for collision
	4F39 CD 79 4F       CALL CharDistAndDir
	4F3C 3E 18          LD A,18
	4F3E BA             CP D
	4F3F 38 0E          JR C,NoColl33
	4F41 BB             CP E
	4F42 DA 4F 4F       JP C,NoColl33
	4F45 79             LD A,C
	4F46 CD 0F 44       CALL Get_dir_code_LRDU_bitmap
	4F49 FD 77 10       LD (IY+O_DIRECTION),A
	4F4C C3 59 4E       JP Collision33

.NoColl33:
	4F4F CD DF 4F       CALL FaceAndAnimate
	4F52 C3 C7 4F       JP ObjDraw

;; -----------------------------------------------------------------------------------------------------------
;; Find the direction number associated with zeroing the
;; smaller distance, and then working towards the other dimension.
.HomeIn:
	4F55 CD 79 4F       CALL CharDistAndDir
	4F58 7A             LD A,D
	4F59 BB             CP E
	4F5A 06 F3          LD B,F3												~$0C
	4F5C 38 03          JR C,hmin_1
	4F5E 7B             LD A,E
	4F5F 06 FC          LD B,FC												~$03
hmin_1:
	4F61 A7             AND A
	4F62 78             LD A,B
	4F63 20 02          JR NZ,hmin_2
	4F65 EE 0F          XOR 0F
hmin_2:
	4F67 B1             OR C
.MoveToDirMask:
	4F68 CD 0F 44       CALL Get_dir_code_LRDU_bitmap
	4F6B 18 BE          JR MoveDir

;; -----------------------------------------------------------------------------------------------------------
.MoveAway:
	4F6D CD 79 4F       CALL CharDistAndDir
	4F70 EE 0F          XOR 0F
	4F72 18 F4          JR MoveToDirMask

.MoveTowards:
	4F74 CD 79 4F       CALL CharDistAndDir
	4F77 18 EF          JR MoveToDirMask

;; -----------------------------------------------------------------------------------------------------------
;; Return the absolute distances from the character in DE,
;; and direction as a bitmask in A.
.CharDistAndDir:
	4F79 CD 3B 2B       CALL Get_curr_Char_variables						; HL = pointer on current selected character's variables
	4F7C 11 05 00       LD DE,0005
	4F7F 19             ADD HL,DE
	4F80 7E             LD A,(HL)
	4F81 23             INC HL
	4F82 66             LD H,(HL)
	4F83 6F             LD L,A
	; Character position now in HL.
	4F84 0E FF          LD C,FF
	4F86 7C             LD A,H
	4F87 FD 96 06       SUB (IY+O_V)
	4F8A 57             LD D,A
	; Second coord diff in D...
	4F8B 28 0D          JR Z,SndCoordMatch
	4F8D 30 04          JR NC,SndCoordDiff
	4F8F ED 44          NEG
	4F91 57             LD D,A
	4F92 37             SCF
.SndCoordDiff:																; Absolute coord diff in D...
	4F93 F5             PUSH AF
	4F94 CB 11          RL C
	4F96 F1             POP AF
	4F97 3F             CCF
	4F98 CB 11          RL C
;; Build 2 bits of direction flag in C
.SndCoordMatch:
	4F9A FD 7E 05       LD A,(IY+O_U)
	4F9D 95             SUB L
	4F9E 5F             LD E,A
	4F9F 28 0F          JR Z,FstCoordMatch
	4FA1 30 04          JR NC,FstCoordDiff
	4FA3 ED 44          NEG
	4FA5 5F             LD E,A
	4FA6 37             SCF
; Absolute coord diff in E...
.FstCoordDiff:
	4FA7 F5             PUSH AF
	4FA8 CB 11          RL C
	4FAA F1             POP AF
	4FAB 3F             CCF
	4FAC CB 11          RL C
	4FAE 79             LD A,C
	; Direction flag now in A.
	4FAF C9             RET

.FstCoordMatch:
	4FB0 CB 01          RLC C
	4FB2 CB 01          RLC C
	4FB4 79             LD A,C
	4FB5 C9             RET													; Direction flag now in A.

;; -----------------------------------------------------------------------------------------------------------
; If bit 0 of DrawFlags is not set, set it and set the object extents.
.UpdateObjExtents:
	4FB6 3A E8 4B       LD A,(DrawFlags)
	4FB9 CB 47          BIT 0,A
	4FBB C0             RET NZ
	4FBC F6 01          OR 01
	4FBE 32 E8 4B       LD (DrawFlags),A
	4FC1 2A EE 36       LD HL,(CurrObject)
	4FC4 C3 A3 1C       JP StoreObjExtents

; Clear $0C and if any of DrawFlags are set, draw the thing.
.ObjDraw:
	4FC7 FD 36 0C FF    LD (IY+0C),FF
	4FCB 3A E8 4B       LD A,(DrawFlags)
	4FCE A7             AND A
	4FCF C8             RET Z
	4FD0 CD B6 4F       CALL UpdateObjExtents
	4FD3 2A EE 36       LD HL,(CurrObject)
	4FD6 CD E9 3A       CALL Relink
	4FD9 2A EE 36       LD HL,(CurrObject)
	4FDC C3 EB 1C       JP UnionAndDraw

;; -----------------------------------------------------------------------------------------------------------
.FaceAndAnimate:
	4FDF CD 8E 50       CALL SetFacingDirEx
; Calls animate and MarkToDraw if it's an animation.
.AnimateMe
	4FE2 CD 8C 37       CALL AnimateObj
	4FE5 D0             RET NC
; Sets bit 1 of DrawFlags
.MarkToDraw:
	4FE6 3A E8 4B       LD A,(DrawFlags)
	4FE9 F6 02          OR 02
	4FEB 32 E8 4B       LD (DrawFlags),A
	4FEE C9             RET

;; -----------------------------------------------------------------------------------------------------------
;collision check?
ObjAgain6:
	4FEF FD A6 0C       AND (IY+0C)
	4FF2 FE FF          CP FF
	4FF4 32 E9 4B       LD (Collided),A
	4FF7 C8             RET Z
	4FF8 CD 0F 44       CALL Get_dir_code_LRDU_bitmap
	4FFB FE FF          CP FF
	4FFD 32 E9 4B       LD (Collided),A
	5000 C8             RET Z
	5001 F5             PUSH AF
	5002 32 E9 4B       LD (Collided),A
	5005 CD D0 4C       CALL MoveCurr
	5008 C1             POP BC
	5009 3F             CCF
	500A D2 1F 50       JP NC,br_501F
	500D F5             PUSH AF
	500E B8             CP B
	500F 20 05          JR NZ,br_5016
	5011 3E FF          LD A,FF
	5013 32 E9 4B       LD (Collided),A
br_5016:
	5016 CD B6 4F       CALL UpdateObjExtents
	5019 F1             POP AF
	501A CD 52 44       CALL UpdateCurrPos
	501D 37             SCF
	501E C9             RET

br_501F:
	501F 3A F0 36       LD A,(ObjDir)
	5022 3C             INC A
	5023 C8             RET Z
ObjAgain7:
	5024 3E 06          LD A,06												Sound_ID 06
	5026 C3 1C 2B       JP SetSound											will RET
ObjAgain8:
	5029 FD CB 0C 66    BIT 4,(IY+0C)
	502D 28 35          JR Z,ObjAgain10
ObjAgain9:
	502F 2A EE 36       LD HL,(CurrObject)
	5032 CD F6 2C       CALL DoContact2
	5035 30 16          JR NC,OA9c
	5037 3F             CCF
	5038 20 07          JR NZ,OA9b
	503A FD CB 0C 66    BIT 4,(IY+0C)
	503E C0             RET NZ
	503F 18 23          JR ObjAgain10

OA9b:
	5041 FD CB 0C 66    BIT 4,(IY+0C)
	5045 37             SCF
	5046 20 05          JR NZ,OA9c
	5048 FD CB 0B A6    RES 4,(IY+0B)
	504C C9             RET

OA9c:
	504D F5             PUSH AF
	504E CD B6 4F       CALL UpdateObjExtents
	5051 FD CB 0B AE    RES 5,(IY+0B)
	5055 FD 34 07       INC (IY+O_Z)
	5058 3E 03          LD A,03												Sound_ID 03
	505A CD 1C 2B       CALL SetSound
	505D F1             POP AF
	505E D8             RET C
	505F FD 34 07       INC (IY+O_Z)
	5062 37             SCF
	5063 C9             RET

ObjAgain10:
	5064 2A EE 36       LD HL,(CurrObject)
	5067 CD 31 2E       CALL ChkSatOn
	506A FD CB 0B A6    RES 4,(IY+0B)
	506E 30 02          JR NC,br_5072
	5070 3F             CCF
	5071 C8             RET Z
br_5072
	5072 CD B6 4F       CALL UpdateObjExtents
	5075 FD 35 07       DEC (IY+O_Z)
	5078 37             SCF
	5079 C9             RET

;; -----------------------------------------------------------------------------------------------------------
ObjAgain11:
	507A FD 7E 10       LD A,(IY+O_DIRECTION)
	507D C6 86          ADD A,86											ObjAgain11_table low byte + drection offset
	507F 6F             LD L,A
	5080 CE 50          ADC A,50											ObjAgain11_table high byte
	5082 95             SUB L
	5083 67             LD H,A
	5084 7E             LD A,(HL)
	5085 C9             RET

.ObjAgain11_table:
	;;             0  1  2  3  4  5  6  7
	5086 DATABYTE FD F9 FB FA FE F6 F7 F5									; -3, -7, -5, -6, -2, -10, -9, -11

;; -----------------------------------------------------------------------------------------------------------
;; IY points on the object's object (variables)
;; SetFacingDir : C has the direction
.SetFacingDirEx:
	508E FD 4E 10       LD C,(IY+O_DIRECTION)								; Read direction code
	5091 CB 49          BIT 1,C												; Heading 'down'?
	5093 FD CB 04 A6    RES 4,(IY+O_FLAGS)									; Set bit 4 of flags, if so.
	5097 20 04          JR NZ,SetFacingDir
	5099 FD CB 04 E6    SET 4,(IY+O_FLAGS)
.SetFacingDir:
	509D FD 7E 0F       LD A,(IY+O_ANIM)				 					; Load animation code.
	50A0 A7             AND A
	50A1 C8             RET Z												; Return if not animated
	50A2 CB 51          BIT 2,C												; Heading right?
	50A4 4F             LD C,A
	50A5 28 07          JR Z,sfd_2
	50A7 CB 59          BIT 3,C
	50A9 C0             RET NZ
	50AA 3E 08          LD A,08
	50AC 18 04          JR sfd_1
sfd_2:
	50AE CB 59          BIT 3,C
	50B0 C8             RET Z												; Ret if sprite currently faces forward.
	50B1 AF             XOR A
sfd_1:
	50B2 A9             XOR C
	50B3 E6 0F          AND 0F
	50B5 A9             XOR C
	50B6 FD 77 0F       LD (IY+O_ANIM),A
	50B9 C9             RET

;; -----------------------------------------------------------------------------------------------------------
?????????
	50BA FD CB 0C 66 C0 18
??????????
	50C0 23
	50C1 FD CB 0C 66
	50C5 37
	50C6 20 05
	50C8 FD CB 0B A6
	50CC C9
	50CD F5
	50CE CD B6

;; -----------------------------------------------------------------------------------------------------------
;; These macros are used when processing the Room_list1 and 2 data to build a room
;; They define groups of objects that can be imported as a block. See algo in Room_list1 below.
Room_Macro_data: 															; MacroID #C0 to #DB
	;; <Length> <macroID> <Macro data N bytes>
	;; note: the length includes the MacroID byte but not the length byte
	50D0 DATABYTE 0C C0 02 CE 77 33 96 4F 26 92 FE 3F C0					; Macro C0 : 2*3 Gratings
	50DD DATABYTE 07 C1 C0 43 E0 01 FF C0									; Macro C1 : 4*3 Gratings
	50E5 DATABYTE 12 C2 16 D2 FB 3C 7D CF 27 FC 0A 69 75 9A 3C E6 FC 7F 80	; etc.
	50F8 DATABYTE 08 C3 16 CA 77 3C 9F F1 FE
	5101 DATABYTE 0B C4 C3 23 E1 E1 C5 B6 9F CF F8 FF
	510D DATABYTE 0C C5 0E C6 75 3B 9E 4F 67 D3 FE 3F C0
	511A DATABYTE 08 C6 17 D2 79 34 97 F1 FE
	5123 DATABYTE 0E C7 0E CB 73 79 5D 1F 4F CB EB EE FF 8F F0
	5132 DATABYTE 0E C8 0E CA 74 FB 5E 2F 5F B3 CB DD FF 8F F0
	5141 DATABYTE 0C C9 C8 03 87 62 79 DF 6F 8F FC 7F 80
	514E DATABYTE 08 CA 18 D2 79 34 97 F1 FE
	5157 DATABYTE 09 CB 00 CE 79 3C 7D BF F8 FF
	5161 DATABYTE 0C CC 16 D0 F8 BC 7E 4F 2F 9B FE 3F C0
	516E DATABYTE 0F CD 02 F2 F9 74 B6 3F 1E 8E C9 E4 D2 5F C7 F8
	517E DATABYTE 08 CE 1E D1 F9 34 B7 F1 FE
	5187 DATABYTE 10 CF 30 CC F7 BA BD DF 2F 33 D9 DC ED F6 BF E3 FC
	5198 DATABYTE 12 D0 CA AB E5 5B F2 95 F9 49 70 DD B4 C6 13 0E 9F 8F F0
	51AB DATABYTE 08 D1 24 D2 79 34 97 F1 FE
	51B4 DATABYTE 0B D2 CC 63 E6 41 F1 03 F8 82 7F F0
	51C0 DATABYTE 0E D3 0E D0 F8 BC 7E 4F 2F 9B CF E0 FF 8F F0
	51CF DATABYTE 08 D4 05 D2 79 34 93 F1 FE
	51D8 DATABYTE 0A D5 0F 4E 75 9F 1F CB DF 8F F0
	51E3 DATABYTE 0E D6 38 F1 E9 34 BB F0 1F A3 F2 79 7F E3 FC
	51F2 DATABYTE 0E D7 39 F1 E9 34 BB F0 1F A3 F2 79 7F E3 FC
	5201 DATABYTE 0B D8 D7 8B EB CB F5 9D FA CD 7F F0
	520D DATABYTE 10 DA 39 CA 67 34 9A CD F8 0F EA 77 3C 9E CF F8 FF
	521E DATABYTE 10 D9 38 CA 67 34 9A CD F8 0F EA 77 3C 9E CF F8 FF
	522F DATABYTE 10 DB 3A FC EE B6 5F 4F F8 3B FD EF 36 3F 3F F8 FF
	5240 DATABYTE 00

;; -----------------------------------------------------------------------------------------------------------
;; Room_list1 + Room_list2 = 230 + 71 rooms = 301 rooms
;; 		Note that the victory room is in fact composed of 2 rooms : #8D30 and #8E30.
;; Format:
;; <length> <high_id> <low_id in [7:4]; data in [3:0]> <data n bytes>
;; until length = 0. (Note that the room ID is in Big-Endian format)
;;
;; The data is shifted by one nibble in the roomID low byte.
;; For exemple, looking at Head's first room data at address 54C7:
;; 		54C7 10 8A 43 F8 01 02 01 3E E0 58 62 33 1A 8D FF 1F E0
;; Length = #10 (16 bytes of data not including length byte)
;; RoomID = #8A4  (1.5 bytes: "8A 4X" with low nibble ignored because it is data)
;; So the data are:  X3 F8 01 02 01 3E E0 58 62 33 1A 8D FF 1F E0
;;         0011_1111_1000_0000_0001_0000_0010_0000_0001_0011_1110_1110...
;;
;; The data is bit packed: 001_111_111_000_000_000_010_000_001_00000000__10_0_111_110_111_...
;; First 3 bits = Room Dimensions (see RoomDimensions table at addr 1ECE)
;; 			here "001" = "MinU=8, MinV=16, MaxU=72, MaxV=64"
;; Next 3 bits is Color Scheme (see array_Color_Schemes at addr 0554)
;;			here "111" = 7 (Black, Red, Blue, Pastel_yellow)
;; Next 3 bits is WorldId (see WorldId at 1EBF), to choose the walls sprites
;;			here "111" = 7 (Prison)
;; Next 3 bits is Door sprite Id (see ToDoorId at 045D) can be 0 to 3
;;   although ToDoorId will convert it to 0 to 2 to use one of the 3 types
;;   of door sprites. Here "000" = 0 : Doorway type 0.
;; Next 4x3 bits are the Walls&Doors data for FarLeft, FarRight, NearRight and  NearLeft sides
;; 			here "000 000 010 000" means Wall/NoDoor, Wall/NoDoor, Wall+Door at ground level, Wall/NoDoor
;; Next 3 bits defines the Floor tile to use.
;;			here "001" = 1 : uses floor_tile_pattern1
;; Then it will loop over the objects in the room or the Macros to use.
;; 	 * 8 bits = Object ID (as defined in the ObjDefns table at 38C9)
;;                 or (if value >= #C0) Macro ID in the Room_Macro_data table at 50D0).
;;				Here "00000000" = object ID 0 = ANIM_TELEPORT (the Teleport_data at addr 3490 says that
;;				room "8A4" goes to room "715")
;;		if Object:
;;			* 2 bits : controls how many objects of current type will be inserted ("?0" = 1; "?1" = several)
;;              and how orientation flag will be applied to the object(s) ("1?"=global, "0?"=per object);
;;				So we can have:
;;					only 1b more fetched to be used as the global orientation flag (no other bit inserted
;; 						between coordinates if several objects to get);
;;					or 1b orientation flag fetched before each set of coordinates.
;;						Here 2b flag = "10" : 1 object of current type ANIM_TELEPORT and 1b more to fetch.
;;          Loop (1 time or until coordinates = "7, 7, 0" (which means "end") as defined in the 2bit flag):
;;				1b : NoFlip/Flip bit. Global (only first loop) or per-object flag (every loop)
;;					Here 1b flag = "0" (NO Flip; if it is "1" then flip the sprite)
;;				3x3 bits: UVZ coordinates;
;;					Here "111 110 111" = U=7, V=6, Z=7 (ground level). Because only 1 object needed to be
;;						fetched (2b flag "?0"), it goes back to fetching next object/macro Id, which here is
;;                      SPR_GRATING, flag "11" (several/global), global orientation flag = "0" (No Flip)
;;                      and 4 coords fetched 0;6;1 0;6;3 0;6;5 0;6;7 (then the ending code 7;7;0).
;;						That finishes the data for that room.
;;						Note that the Special object "SPR_BUNNY (lives)" at 0;6;0 is added in another routine
;;						and is not part of the room data.
;;		if Macro:
;;			* 3x3 bits for origin offset coordinate added to all objects in the macro;
;;				Then it loops to fetching 8b object id or Macro id until the code is "FF" to leave
;;				the macro and go back where we were in the room data.
Room_list1: ;; 230 rooms
	;; <length> <high_id> <low_id in [7:4]; data in [3:0]> <next data N bytes>
	;; until length = 0
	5241 1A 12 01 61 FC 05 92 07 20 CA FA BF E0 93 0F CF CB D7 E7 33 A9 DC E7 73 FF 1F E0		; RoomID "120"
	525C 0B 1D 01 E1 08 05 B0 07 CB 03 FF 80													; RoomID "1D0"
	5268 0C 22 05 21 08 24 4B 95 F1 7D 7F E3 FC
	5275 1D 24 00 E1 10 3C 3F 38 E2 73 FC 03 3C F8 57 72 1D 16 87 11 FF FF 81 6D 17 0F 89 FF 1F E0
	5293 08 26 0F A1 08 05 96 07 FF
	529C 10 2D 03 A1 04 25 B4 2F 0C 97 70 FB 77 D9 EB FF 80
	52AD 1A 32 00 E1 08 24 4B AF F0 7F C0 76 EB D3 D9 EC 76 FC 7E BF A7 D7 CB E7 FF 8F F0
	52C8 12 35 0F E1 21 85 8A 3E C5 1F 85 64 79 3C CE 6F FC 7F 80
	52DB 09 36 0F E1 00 A4 25 0E FF E0
	52E5 0B 3C 03 A1 28 05 B4 2F D9 0B FF 80
	52F1 12 3D 03 A1 40 94 19 36 E7 10 ED B4 2F 0F E7 7D BF E3 FC
	5304 08 3E 0B 61 09 05 B2 1F FF
	530D 10 43 0C 21 C1 05 9D D7 CE 0B 8F 69 EC DA 5F F8 FF
	531E 0E 45 09 32 40 0B 81 87 C1 03 80 EC 3F E3 FC
	532D 0F 46 0E 72 41 0A 5D 09 E5 FB 4F 1F 53 FE 3F C0
	533D 1F 47 08 32 01 0A 09 37 E2 33 5E 15 33 E3 B0 CF 82 07 0E C9 F4 BF E0 0B 19 8C AA 55 32 9F F1 FE
	535D 0D 4C 0E 21 00 25 B2 17 DA 17 E5 81 FF C0
	536B 0D 4E 0F 21 00 25 B2 17 DA 17 E5 81 FF C0
	5379 08 81 0F 61 40 05 96 07 FF
	5382 10 82 01 E1 1F 8C 1F 38 24 9B 85 C4 F2 31 3F 1F E0
	5393 0D 84 03 E1 08 05 AF 0F D7 9B E5 81 FF C0
	53A1 0B 85 01 A1 08 05 B0 07 CB 0F FF 80
	53AD 06 87 0F E1 48 05 FE
	53B4 08 88 0F A1 01 05 96 07 FF
	53BD 06 92 07 61 48 25 FE
	53C4 08 93 0C 61 41 05 AF C7 FF
	53CD 08 94 00 A1 49 25 9E 47 FF
	53D6 08 95 00 E1 49 25 9E 47 FF
	53DF 0B 96 0D 21 41 04 1F 1A FA FC 7F F0
	53EB 06 97 07 61 09 25 FE
	53F2 08 A1 0F 61 40 05 96 07 FF
	53FB 0D A2 00 21 03 25 86 24 CC 9E 67 45 FF C0
	5409 0D A4 02 61 00 25 AC CF D6 7B E5 81 FF C0
	5417 0B A5 01 61 00 25 B0 07 CB 03 FF 80
	5423 0B A7 0E 21 C0 24 19 31 F9 C0 FF F0
	542F 0B A8 00 61 01 05 B0 07 CB 03 FF 80
	543B 08 B1 02 5B 08 07 96 07 FF
	5444 19 C1 00 1B FC 26 23 1E B9 CF 72 4C C7 83 B3 E1 F3 CF 23 F1 E8 F7 7B 7E 3F C0
	545E 1A C2 01 5B 81 8C 3F 08 E1 F8 FC 7F FC 08 6F F8 1F F0 49 BC EF F9 FC 1D 8F F8 FF
	5479 14 C3 0F 1B 01 06 43 A6 EF 7F C1 26 38 3C 4E 6B 5D 76 D7 F1 FE
	548E 1E D1 0B DB 00 26 03 2A 01 F9 2E 8F B3 FE 08 F2 59 1D 65 B7 7E 09 35 46 85 4B BF D7 3F 1F E0
	54AD 19 89 41 78 40 02 1D 38 E0 10 0F 82 47 C1 A3 83 68 3E 1E 8E C7 43 91 FF 1F E0		; Heels' 1st room, id #8940
	54C7 10 8A 43 F8 01 02 01 3E E0 58 62 33 1A 8D FF 1F E0									; Head's 1st room, id #8A40
	54D8 0B 61 59 38 14 0E 2D B3 FA 7F C7 F8												; Head's 3rd room, id #6150
	54E4 0E 64 51 78 10 0E 2D 3B E2 F3 DE 09 3F FF E0
	54F3 09 71 53 40 00 22 01 3E FF E0														; Head's 2nd room, id #7150
	54FD 11 74 54 80 04 3C 03 A3 E9 FF C0 B6 CF F7 C3 FF 8F F0
	550F 0F 84 54 80 80 1C 2F 13 E2 DA 5F 1F 0F FE 3F C0
	551F 06 85 5E 00 09 03 FE
	5526 11 95 55 00 08 22 1B 0A E2 13 AE 37 9D F2 7A BF E3 FC
	5538 0B A5 5E F8 00 3E 2D 8B E6 7F C7 F8
	5544 0E 24 6F 00 A4 03 8E 07 16 CF 79 BB DB F1 FE
	5553 08 25 62 78 01 8F 88 2F FF
	555C 15 30 61 C0 80 0D 8C FF C6 1F E2 07 C5 B7 F7 FD 07 83 41 7F 1F E0
	5572 0D 31 65 40 11 02 03 1D F9 50 F1 18 EE FF
	5580 0D 34 6F 00 14 13 8E 07 0A CD F9 3F E3 FC
	558E 06 41 66 40 48 23 FE
	5595 08 42 6E 00 21 03 8A 07 FF
	559E 08 43 6E 00 40 83 8A 3F FF
	55A7 13 44 61 F8 49 2B 88 05 C4 1E E2 03 F1 01 D8 83 6C 41 BF F8
	55BB 12 45 6C C0 E3 8C 2F 9C 92 4F C0 B6 7E 4F 18 90 4F C7 F8
	55CE 08 46 6F C0 49 03 8E 07 FF
	55D7 16 47 69 80 01 02 33 1F E3 51 4D 82 07 02 CA 55 39 94 CC 67 FC 7F 80
	55EE 0B 51 66 C0 48 22 1F 94 E9 FF C7 F8
	55FA 19 52 60 80 01 8C 23 03 C2 10 6C 2F BB FC 7F C0 B6 FF 8D C3 E0 76 3C 1F F1 FE
	5614 06 54 67 00 08 23 FE
	561B 06 56 67 40 08 23 FE
	5622 09 61 69 00 00 22 09 33 FF E0
	562C 0E 64 61 40 00 22 19 18 E2 32 7E 09 3F FF E0
	563B 11 66 61 00 40 22 39 C7 FF FE 3F E0 77 37 E4 FF 8F F0
	564D 0B 67 6F C0 25 02 33 0C F9 00 7F F0
	5659 08 68 6F C0 40 83 90 07 FF
	5662 1C 69 61 80 1D 02 0D 16 80 91 1F 95 B7 CA CB 8A E4 DA 8D 57 F8 16 C9 44 E2 91 59 F8 FF
	567F 08 77 6F C0 40 13 90 07 FF
	5688 10 78 68 80 C1 02 37 64 E1 72 3A 0B A3 F1 EF C7 F8
	5699 06 79 6F C0 09 23 FE
	56A0 15 89 60 00 10 3C 2F 26 F9 41 FC 41 38 B6 8F F9 FB E2 70 FF E3 FC
	56B6 0B 99 6E 78 00 4E 2D 8C E5 FF C7 F8
	56C2 12 A5 6E C0 FC 02 09 0B E2 32 4E 17 92 F5 7B 7A BF F1 FE
	56D5 06 A6 6D 80 41 03 FE
	56DC 0B A7 6D C0 41 02 03 21 E3 76 3F FE
	56E8 0B A8 6E 38 01 8E 2D 99 F0 FF C7 F8
	56F4 1D B5 63 40 04 3C 0D A5 F6 FF 7E BF F0 13 8B F1 F8 7F E0 23 13 D9 FF 81 6C 1F 13 FE 3F C0
	5712 1C C5 63 40 00 1C 2D BE FE FF 3F E0 23 69 F3 F9 7C 7C 3D 3E AF FC 03 64 79 BC 5F F8 FF
	572F 16 05 7F 78 10 0E 09 0E E1 3B 6F 9F D3 EB FF 00 D9 EF 37 BB FE 3F C0
	5746 1A 14 70 80 80 0C 17 39 F8 79 7C 3C 7E 20 7C 4E 47 C5 21 D8 27 75 79 BC 5F C7 F8
	5761 0B 15 74 00 15 22 15 02 E2 B1 CF FE
	576D 0B 25 72 40 00 22 19 31 E0 93 91 FE
	5779 15 98 70 C8 48 0A 1D 3F E2 FB FC 06 FC 0B 60 79 1F 7F F7 FC 7F 80
	578F 06 99 7E 48 01 0B FE
	5796 09 A8 7E 08 14 2A 17 09 FF E0
	57A0 14 B8 70 48 10 3C 27 38 F8 49 7C 2B 78 B6 F3 FB C2 E1 FF C7 F8
	57B5 08 BA 73 F8 08 0B 96 07 FF
	57BE 06 C8 76 C8 40 2B FE
	57C5 10 C9 7D 88 41 0A 1D 9B ED E8 F4 99 CC E7 FC 7F 80
	57D6 0E CA 70 88 41 2A 19 3C E3 38 0E 3F FC 7F 80
	57E5 08 CB 7E 08 09 0B 92 07 FF
	57EE 10 DB 72 48 08 2A 4D 23 E4 39 EF 37 2F E7 FF 1F E0
	57FF 0B EB 78 38 00 3E 2D 8C E5 FF C7 F8
	580B 0B 04 81 80 A0 02 03 24 E0 10 0F FE
	5817 0E 05 8F 40 01 02 1D 31 E1 33 2C 09 0E 1F E0
	5826 19 09 83 B8 10 1C 0D 06 F9 8C 71 79 4F 25 8E EC CA 39 0E 67 B3 9D EA FF C7 F8
	5840 19 0B 83 38 04 3C 2D 39 E0 33 1F 99 07 06 D3 7B BF DF 6F F8 0B C4 F4 7F E3 FC
	585A 1D 19 81 F8 48 61 99 04 0E C4 92 08 1F F0 0B 89 44 22 79 38 9A 4C 25 B1 D0 C4 52 1F E3 FC
	5878 17 1A 8D 78 E1 01 9C 07 CE E3 93 49 39 1E 7E 4F 3F 04 99 E9 34 FC 7F 80
	5890 18 1B 83 38 01 9D 88 2F 17 87 70 68 37 01 D3 7F 7F E0 5B 7D D6 F1 7F C7 F8
	58A9 0F 29 80 80 00 21 9B EF C1 3F E5 B7 F2 DD FF E0
	58B9 08 E9 81 00 48 01 96 07 FF
	58C2 15 EA 8C 78 43 0A 43 98 F0 7F C0 B6 6F B7 9B 91 D8 E4 7A 3F F8 FF
	58D8 09 EB 88 38 09 0A 09 0B FF E0
	58E2 10 F9 8F B8 24 3C 0D 36 E2 D8 BE 67 3B 9B FF 1F E0
	58F3 19 FA 89 B8 00 8C 2F 27 F9 88 F2 59 0E C5 17 E6 53 C2 36 1F F0 2D 88 FF 8F F0
	590D 13 FB 84 F8 1C 21 9C FF 11 9E E0 A9 EF 1E DE 7F 37 7F F1 FE
	5921 09 03 91 9B 0C 0E 09 1C FF E0
	592B 11 11 9B 1B 08 07 98 7C 00 94 30 3C BF A3 DF FF 1F E0
	593D 06 13 96 9B 08 27 FE
	5944 0F 20 9D DB A0 0F 99 CF CC 07 8E E6 B4 5B F1 FE
	5954 0E 21 90 1B 43 67 9D 3F 16 CC 76 23 1B F1 FE
	5963 13 22 9D DB 81 8C 5B 1E E1 DA 3F 1E 6F 7E 05 B3 FD 8F F8 FF
	5977 13 23 91 9B 01 BC 5B 0C E1 D9 FC FF E3 7E 05 B4 1C 4F F8 FF
	598B 11 03 A1 99 00 0E 09 1C FA 40 71 7D 27 B3 E9 FF 1F E0
	599D 0C 0D A3 D3 80 0E 2D 86 F3 77 BF E3 FC
	59AA 09 0E A8 53 41 28 63 24 FF E0
	59B4 0F 0F A8 93 01 28 23 77 D8 A0 FC 50 BE 28 7F FC
	59C4 14 20 AD DB 00 0E 07 21 D9 9F FC C1 F8 EE 77 3B 65 D2 DF C7 F8
	59D9 0D D0 A8 D3 09 08 23 4C E3 31 CF 82 37 FF
	59E7 11 DE A1 D3 80 0E 2F 2F E2 DA 7E FF FF FB C7 FF 8F F0
	59F9 06 DF AD 93 41 09 FE
	5A00 1F E0 A8 53 08 29 8A 37 C5 13 E2 8B C5 E5 0B 31 75 8C 9E 21 D7 F7 FF E0 5B 40 B7 EB E5 FF E3 FC
	5A20 08 F0 AE 93 01 29 8E 07 FF
	5A29 0D FE A0 13 90 0C 2F 3E F9 8F FC 40 FF F8
	5A37 06 FF AB 53 49 09 FE
	5A3E 18 03 B1 99 00 0E 47 20 1A 40 72 4D 1B 91 FE 05 F4 26 24 E4 52 99 BF 1F E0
	5A57 09 0D B3 D3 00 0E 09 06 FF E0
	5A61 0B 10 B0 9B 08 27 A0 07 CB 17 FF 80
	5A6D 12 20 BD DB 00 26 23 20 F9 9C BC C0 58 EE 69 44 BF 1F E0
	5A80 0C 2C B7 D3 80 0E 47 83 EE 79 3F E3 FC
	5A8D 0B 2D B0 13 41 09 A0 07 CB 03 FF 80
	5A99 16 2E B1 93 01 08 49 1C 21 71 B9 A3 C4 D1 FF E8 F1 C4 77 7C 3F F8 FF
	5AB0 17 DE B1 D3 00 0E 09 3D E0 59 FA F9 7D FE 05 B7 97 AC 38 3F F1 FF 1F E0
	5AC8 1D 03 C1 9B 00 3E 55 3E C1 53 FC 2F 09 FA 40 71 6C 7C 5E F0 79 7D 3E EF 73 B6 FD FC 7F 80
	5AE6 0B 0C CD 13 E0 0E 2D 9F 93 CF C7 F8
	5AF2 0B 0D C3 D3 01 08 39 03 E0 90 6F FE
	5AFE 0B 2C C7 D3 00 0E 09 03 F8 80 7F F0
	5B0A 0B D1 C1 DB 10 0F 88 07 C4 1F FF 80
	5B16 0C D4 C6 5B 10 0E 49 BC FD F8 FF E3 FC
	5B23 08 DC CF 93 10 0F 98 87 FF
	5B2C 14 DE C1 D3 14 0E 09 38 E2 DB AC 78 1C BF 47 63 FF 37 7B F1 FE
	5B41 10 E1 C8 1B 20 26 01 28 62 D2 F8 2F 2E 99 87 CF F0
	5B52 12 E2 C8 1B 80 86 07 13 E0 12 F7 98 7C 17 D7 CB A7 E3 FC
	5B65 12 E3 C0 DB 4B 07 A3 1F C3 12 0F 32 20 9B 07 00 EF C7 F8
	5B78 0B E4 CE 1B 01 26 63 36 9A 29 7F F0
	5B84 12 EC CF 53 20 3C 1D 15 E0 70 AC 55 56 F9 88 7C CA 3F F8
	5B97 0E ED CF 53 80 8D 98 87 16 C4 F9 BB DF F1 FE
	5BA6 06 EE CE D3 03 29 FE
	5BAD 0E F3 C4 5B 14 26 15 1C E2 39 BF 27 FC 7F 80
	5BBC 16 03 DF 99 00 06 23 23 C0 31 CC 17 92 F5 75 7B 7E 3F 27 73 FE 3F C0
	5BD3 06 0C DD 13 08 09 FE
	5BDA 16 1C D3 93 08 28 23 26 FA 2E F0 D8 8E 24 DC CE 5A 3D 9F 8F FC 7F 80
	5BF1 1C 2C D7 D3 00 28 03 14 41 51 BE 1F AC 5A 3F 27 77 F0 49 94 6E 39 27 9F 4D 65 FC 7F 80
	5C0E 08 88 D0 13 40 09 96 07 FF
	5C17 19 89 D1 93 E1 88 03 1E 79 C0 71 1C D7 8B FE 09 33 1E 0E F4 9A 3F 27 9F 8F F0
	5C31 09 8A DC D3 C1 08 03 24 FF E0
	5C3B 0F 8B D0 93 09 09 A0 07 16 CE 79 3B 7E 3F F8 FF
	5C4B 08 9B DF 13 48 29 8E 07 FF
	5C54 0E 9C D1 93 1D 09 95 C7 28 CE 44 BA 5B F1 FE
	5C63 15 AB D1 93 E0 6C 53 80 94 4F E7 53 89 F8 16 CF C9 E0 90 39 F8 FF
	5C79 0D AC D1 D3 09 29 A0 07 11 CA 7B 3F E3 FC
	5C87 10 BC D4 53 08 28 07 3A E2 D0 46 01 04 58 80 BF F0
	5C98 12 CC D1 53 FC 28 3D 3C 99 CF 7C 30 E0 B6 5F 2F FF 1F E0
	5CAB 06 CD DC 93 41 09 FE
	5CB2 18 CE D1 13 1D 08 09 07 E5 12 66 27 17 D8 A1 CC 2F F8 76 9A 2F CF FF 8F F0
	5CCB 11 D1 D1 DB 00 0E 09 03 F8 81 F0 BD FE DF 5F BF 1F E0
	5CDD 09 D4 D6 5B 00 0E 09 23 FF E0
	5CE7 19 DC DF 93 00 28 43 31 E0 33 10 2F B1 BA 3F C0 B6 C4 E7 32 59 6D BE 9B F1 FE
	5D01 15 DE D1 D3 00 28 2D 07 20 30 70 2B 01 E4 F0 0A 01 04 59 90 BF F0
	5D17 17 8A E0 B2 80 0E 43 1C C2 FA 4F 67 7B FE 05 B6 9D CE EF 7F CF FF 1F E0
	5D2F 10 8B E0 32 01 8F A6 47 2D 97 E1 6D FF 63 FE 3F C0
	5D40 0F C3 EF 1B A0 0E 57 4C D8 A0 72 4D 8F FC 7F 80
	5D50 11 C4 E8 1B 1D 06 39 B5 F9 FF C1 26 D3 E9 B4 9F 8F F0
	5D62 1E D1 E1 DB 00 0F 86 9B 17 88 E2 A9 FE D2 03 85 E2 61 37 F0 2D BF 8F A5 D0 E0 F2 4E FC 7F 80
	5D81 14 D4 E6 5B 00 26 49 A3 15 9C DF 6D 4B F8 0A CA 45 32 9F F1 FE
	5D96 08 00 F2 72 08 0B 96 07 FF
	5D9F 1E 10 F1 B2 14 3C 3F 4F E2 D8 4E 1F 9F F9 BB DF 80 EC 06 23 01 C7 E3 E1 B7 1D CE D7 FC 7F 80
	5DBE 10 20 F5 72 1C 7C 09 23 E2 DB BF E7 13 87 FF 1F E0
	5DCF 13 30 F0 B2 FC 2A 23 27 C2 D9 FB 3F 7F 3F FB FD EE E7 E3 FC
	5DE3 0B 31 FA 32 C1 0B 9D D7 CE 0B FF 80
	5DEF 13 32 FF B2 25 8C 2F 1C E2 DB 6E F7 2F 99 C9 F0 F6 7F E3 FC
	5E03 18 33 FF B2 10 8C 2F 8C F9 FB 7F E0 5B 63 F5 EE F7 B9 DC AE D7 67 FE 3F C0
	5E1C 11 40 F6 F2 04 5C 2D BC FA 7B 3B 75 3A 5D 0E FE 3F C0
	5E2E 11 42 FF B2 80 1C 2F 1C E2 DB 1F 57 6B BD CE FF 8F F0
	5E40 10 43 FE F2 81 BD 98 07 17 89 F1 6C DF 2F FE 3F C0
	5E51 06 44 FD 32 61 8B FE
	5E58 10 45 F9 32 E3 0E 5B 10 9A 78 51 6C FC 62 7E 3F C0
	5E69 15 46 F1 B2 41 0A 15 3C A3 BB DF DF FC 0B 6F 77 9B 4F DE FC 7F 80
	5E7F 12 47 F8 32 12 0E 2F B5 F8 FF C0 B6 83 E1 F3 FB FF C7 F8
	5E92 14 50 F6 F2 10 1C 2F A4 FA 7B 3A 9F F0 2D BC EE 73 38 9F F1 FE
	5EA7 12 57 F4 72 04 2A 37 B2 F1 F5 3F E0 3B 6B E5 EA FF C7 F8
	5EBA 06 60 FB B2 24 2B FE
	5EC1 0D 61 FB B2 40 8A 15 14 C2 31 4F 83 CF FF
	5ECF 06 62 F4 B2 49 0B FE
	5ED6 17 63 F1 F2 01 0A 23 24 E2 F3 98 4B AA F2 F4 FF E0 5B 70 BC BF EF C7 F8
	5EEE 13 67 F4 72 08 1A 23 24 C4 3A AF AF 93 AB CC E5 76 FF E3 FC
	5F02 18 70 F9 B2 08 1A 03 26 D9 4A 4C A5 38 56 BB 3D BF 02 D9 EF 37 BB FE 3F C0
	5F1B 0B 72 F6 72 08 2A 23 23 F8 A0 7F F0
	5F27 14 77 F4 B2 08 2B 8A 0F 1B BA 70 EC 5F 8B A7 DB F5 FC FF E3 FC
	5F3C 0E 80 F1 72 A0 5C 2F 23 E2 DA 7E 1F FC 7F 80
	5F4B 17 81 F9 F2 A1 8C 5B 18 E1 DA CF 66 D3 29 CC CA 6F C0 B6 67 BF BF 1F E0
	5F63 08 82 FE 32 41 2B 92 07 FF
	5F6C 10 83 F9 B2 05 0A 2D 0F 81 D3 2F 81 87 C1 03 FF 80
	5F7D 0D 87 F0 F2 48 6B 9D EF C4 1E 62 01 3F C0
	5F8B 1A 88 F1 32 E1 8C 27 36 C1 50 4D 84 AF D3 83 E2 85 C5 B5 1D 8F 07 9F 3F BF 1F E0
	5FA6 06 89 FC F2 41 0B FE
	5FAD 19 8B F0 32 01 0A 15 01 F8 80 4C 50 38 24 FF 80 68 FB 7F F0 1D 84 FE 7F C7 F8
	5FC7 17 93 F9 B2 40 1A 1B 29 F8 18 7C 10 38 76 CB D5 DB ED E6 EA 3C AF F8 FF
	5FDF 10 94 F8 32 C3 0A 5D 24 E0 31 BE 33 A3 EE 7F C7 F8
	5FF0 0B 95 F0 32 41 0A 63 1C C1 D1 CF FE
	5FFC 0F 96 F0 72 41 0A 19 3F E1 D8 BE 1F 4B FE 3F C0
	600C 06 97 F6 B2 03 AB FE
	6013 11 C3 FF 19 00 0E 47 33 44 9B 11 B5 D9 DD CE FF 8F F0
	6025 1A D1 F9 D9 00 0E 09 10 F9 94 7C C4 38 1E DB 6F BF 02 DA AF BF C3 91 CF FF 8F F0
	6040 0F 41 01 E1 40 05 AF 2F D7 8B E5 B7 F2 DD FF E0
	6050 12 42 01 21 41 65 AC EF D6 6B 8B 60 E0 50 2E 16 FC 7F 80
	6063 0B 44 02 61 01 25 B2 17 25 9D FF F0
	606F 08 34 04 A1 48 25 B4 37 FF
	6078 0D 14 09 61 19 05 B2 1F 11 98 7C E5 FF F8
	6086 0B 13 01 A1 41 05 B0 07 CB 03 FF 80
	6092 25 9A F1 B2 00 2A 37 17 DA 2E 4D 17 38 BC 87 E5 75 F3 37 F9 80 F1 5D C1 AF FE 02 B3 FB F0 2D A0 EF F5 BA FF F1 FE
	60B8 12 8A F0 B2 FD 0A 5D 24 E2 B8 9F F8 16 CF D7 FB FB F1 FE
	60CB 19 00 B1 9B 0C 07 A3 24 03 9C 42 88 FA D1 93 80 4B D9 26 23 F1 67 6F BF C7 F8
	60E5 00

Room_List2: ;; 71 more rooms
	;; <length> <high_id> <low_id in [7:4]; data in [3:0]> <data n bytes>
	60E6 06 79 11 E8 60 0F FE
	60ED 0B 7A 18 68 21 01 8A 0F C5 1F FF 80
	60F9 0B 7B 18 68 40 80 6F 0B F8 A0 7F F0
	6105 0B 7C 1A 28 82 00 23 9C F1 FF C7 F8
	6111 0B 7D 11 A8 02 8E 09 1B FA 40 7F F0
	611D 15 77 29 28 FC 00 23 09 E0 B9 FA FE 7F FE 00 F6 3D 3F 27 FC 7F 80
	6133 14 78 21 68 43 80 03 39 62 73 D5 85 57 05 DC CE A7 73 D7 F8 FF
	6148 08 79 21 E8 19 01 9C F7 FF
	6151 0F 7D 21 A8 04 0D AB FF D5 FF 02 46 FE 90 1F FC
	6161 0D 87 26 A8 08 20 1F 9C F2 76 FC 7F F1 FE
	616F 19 89 27 A8 04 20 69 2B BA 87 FD 42 39 16 CE 69 3F 00 BA 3F 65 EE 79 3F 1F E0
	6189 06 97 21 E8 00 7F FE
	6190 19 99 27 A8 08 11 A9 87 34 D5 E4 F7 E0 17 57 CB 81 C3 20 91 3A A5 4F FE 3F C0
	61AA 08 9D 27 28 08 61 A9 3F FF
	61B3 08 A9 2E 68 48 61 9D 7F FF
	61BC 0D AA 24 E8 41 00 23 3D E0 B0 5F A9 0E FF
	61CA 06 AB 2D 68 41 01 FE
	61D1 16 AC 28 E8 82 0C 5B 1F E0 B9 BE C7 FC 07 E3 F1 1B 5D BF 73 FE 3F C0
	61E8 06 AD 2E A8 E1 21 FE
	61EF 17 AE 26 68 09 00 45 03 A0 72 BE 1F 03 E0 B8 CA 24 2F 17 CC C6 7F C7 F8
	6207 12 B9 27 E8 08 20 37 73 E1 FA 4C E6 B3 C9 DC EA 7F C7 F8
	621A 12 BE 20 28 08 40 4B 20 E6 72 9E 0B AF EB 76 FE 3F F1 FE
	622D 14 C9 23 28 10 4C 45 A9 94 DA 75 3F 9D CF FC 02 E0 FF 9F F1 FE
	6242 15 CB 24 68 B4 00 1F 05 E6 75 BC 2B AC F2 7F C0 2E 6F F7 FF 1F E0
	6258 09 CD 23 E8 61 80 6B 23 FF E0
	6262 09 CE 2B A8 41 20 67 23 FF E0
	626C 12 CF 21 68 0B 00 17 9B EE 7F C0 2E 62 21 10 A8 7F C7 F8
	627F 0E D8 29 A8 C0 00 03 1A E2 3A 0E DF FC 7F 80
	628E 06 D9 24 A8 09 21 FE
	6295 0B DB 25 A8 08 20 33 A4 ED FF C7 F8
	62A1 08 DF 25 28 08 61 9D 3F FF
	62AA 11 E9 20 28 14 5C 45 80 EC 7E 3F E0 17 77 C4 FF 8F F0
	62BC 0B EB 27 28 D8 20 0B BB DD FF C7 F8
	62C8 0B EC 28 E8 42 00 6D B3 E6 7F C7 F8
	62D4 24 ED 2E A8 22 8C 65 0B E1 F8 DB B5 26 FE 01 F6 BE DF 2F 57 BB FF 00 D9 9E 8F 27 FE 02 71 BC CE 57 DB FE 3F C0
	62F9 1E EE 2E A8 A0 8C 65 34 E1 FB 1B 95 BA ED 7F 01 3B 1F 97 CF EB F6 FF 80 6D 77 9B BD FF 1F E0
	6318 0B EF 20 68 03 21 A9 E7 CB 0F FF 80
	6324 18 F9 21 A8 40 21 82 17 0F D1 F7 3F E0 47 37 E4 FF 80 2E BD 5F 2F FF 1F E0
	633D 06 FA 2D E8 41 01 FE
	6344 13 FB 23 68 01 20 17 3E E2 B2 4E 0B B9 FC EE 6F 33 97 F8 FF
	6358 1A 97 31 E8 00 0E 0D 8F E3 FF C0 46 03 83 C2 E1 F1 38 BC 6F F8 00 CF F9 FF E3 FC
	6373 09 97 41 E8 08 00 09 00 FF E0
	637D 1C A7 43 A8 00 20 05 24 E6 72 3F A8 06 11 D0 F9 7F E0 0F 03 F9 FF 80 5D 22 92 7E 3F C0
	639A 06 3B 33 00 09 23 FE
	63A1 08 1B 3F 80 08 03 96 07 FF
	63AA 08 39 3E 00 40 03 96 07 FF
	63B3 09 2B 37 40 08 22 55 24 FF E0
	63BD 16 4A 37 C0 14 23 86 FE C3 63 07 6B 2D 92 C7 5B FC 0B 6A FD 9F F1 FE
	63D4 15 4B 31 40 E0 7D 8C DF C6 7B E3 19 F1 A4 E2 DA 78 1C 12 7E 3F C0
	63EA 17 4C 30 80 09 02 55 3A E6 F1 2F 8E 07 0E CB 6C B4 7D CE BE EB 7E 3F C0
	6402 14 5C 32 C0 10 33 8A 2F C5 0B 87 67 7C 5F F0 23 A5 ED 7F C7 F8
	6417 13 6C 3F 40 03 A2 6D 24 E2 D1 97 98 03 0B C7 76 7E BF F1 FE
	642B 24 69 31 80 FC 02 23 24 E2 D0 8E 2B 08 C5 70 9C 09 09 E2 D9 7E FD EE 79 08 FF 80 EC 0F 07 15 CA C8 F4 77 E3 FC
	6450 1B 8A 39 80 41 02 37 DA F2 FF C0 76 B7 39 F3 E6 74 B4 7F 2E 97 2B 9B ED FA FF C7 F8
	646C 17 58 30 C0 83 0C 17 3C E2 F8 4E E7 73 7E 05 B4 11 88 07 7F CF FF 1F E0
	6484 19 57 31 00 40 72 6D 38 C3 12 3A 17 A3 5C 7F C0 B6 11 86 E3 71 C8 F4 7F F1 FE
	649E 09 47 34 40 08 22 7B 1B FF E0
	64A8 14 3A 31 80 DB 82 03 00 58 82 31 6D 3F 7F BF 9E F3 D9 F7 E3 FC
	64BD 1D 8E 35 F9 00 86 76 8D E5 7A 5E 77 AD FE FF AE FC 1D 23 71 5C 97 1D CB 77 AD EF 3F 1F E0
	64DB 19 5A 38 40 0B 22 17 30 E2 32 2E 2D A0 8C 4F C0 76 CB D5 E3 ED F4 B9 5F F1 FE
	64F5 2B 8D 31 F9 20 06 2B 10 E7 55 8C 77 58 F9 8F FD B0 FE D8 FC 5B 1F D7 EB E7 FF FF EF F8 3C C8 E4 72 39 1C 8E 47 7E 09 32 19 1D F8 FF
	6521 1B 59 3B 80 41 02 35 14 82 B1 BF 80 44 C1 E3 85 EA FA 87 F0 05 94 4E 25 1B 93 F1 FE
	653D 10 79 34 00 08 22 6F 64 F9 00 70 ED 57 B7 FE 3F C0
	654E 0D 69 21 80 00 0E 2D 07 E2 F0 6F 88 2F FF
	655C 12 6A 38 80 C1 62 23 AF F8 7F C0 B6 7E CF 6F DB FF C7 F8
	656F 1A 37 31 80 0C 02 23 1B E7 D1 EC 1D 8F E7 7B FD DD EF 36 9F 2D 97 CF D7 F7 E3 FC
	658A 22 6B 39 00 83 0D 98 8F 1E C8 54 74 9D 4E 97 FC 07 6D E6 D7 5B F8 16 D8 F6 24 11 FF 3F CE E6 F3 DF 8F F0
	65AD 08 CC 2C 28 C1 01 9C 17 FF
	65B6 19 89 31 C0 E0 22 23 3E C2 73 88 57 3E E2 D3 8B 88 1F 14 C8 FA 7D 9D 4F F8 FF
	65D0 25 8B 30 40 01 8D 8D CF C6 67 E1 89 C0 22 F8 7B 01 C3 E3 E1 F8 DF F0 2D B8 FC 6E 25 1D 7F F8 24 C7 D5 AB F7 F1 FE
	65F6 08 8D 21 A8 14 1D 88 07 FF
	65FF 00

;; -----------------------------------------------------------------------------------------------------------
;; The data block from 6600 to ADBF after loading is moved to 70D8-B897 (+0AD8) at
;; initialisation (Init_table_and_crtc function.
;; This move frees the gap 6600 to 70D7 for buffers and data tables
;; -----------------------------------------------------------------------------------------------------------

;; -----------------------------------------------------------------------------------------------------------
	6600-66FF																Table of values used by the blit routines
	6700-67FF																buffer
	6800-68FF																buffer
RevTable:
	6900-69FF																; Table of values used by
Backgrd:
	6A00-6A3F																; data???
Objects:
	6A40-6E2F																Objects buffer
	6E30-???
	6FC0-6FC9																Buffer (key scanning)
	6FCA-???

;; -----------------------------------------------------------------------------------------------------------
;; Again, everything below this point has been moved by #0AD8 at init (70D8 was placed at 6600 before Entry).
.PanelFlips:
	70D8 00 00 00 00 00 00 00 00
.SpriteFlips_buffer:														; flipped sprite
	70E0 DATABYTE 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

;; -----------------------------------------------------------------------------------------------------------
img_wall_deco:
img_blacktooth_walls:
img_blacktooth_wall_0:
	; 4 bytes * 56 : interlaced : wall1 + maskwall1 + wall2 + maskwall2 (each are 1byte wide*56)
	70F0 00 00 03 03 03 03 FF FF 0E 0E 00 00 39 38 55 00
	7100 E2 E0 2B 00 85 80 55 00 82 98 2B 00 01 3C 55 00
	7110 00 24 00 00 49 09 15 15 9E 1E 80 80 57 17 55 40
	7120 AF 2F 4B 40 33 33 A5 A0 AC 2C AB A0 2F 2F 45 40
	7130 96 16 B3 B0 40 00 50 50 9E 1E E9 E9 2F 2F E8 E8
	7140 6F 6F 6B 68 9F 1F 65 60 6F 6F 6B 68 6F 6F 65 60
	7150 6F 6F 6B 68 5F 5F 49 48 9F 1F 48 48 4E 4E 89 89
	7160 9E 1E 40 40 41 41 C9 C8 5F 5F 93 90 5F 5F 59 58
	7170 42 42 C3 C0 1D 1D C5 C0 5D 5D CB C0 2D 2D C0 C0
	7180 6D 6D D5 D5 9D 1D 80 80 3C 3C 0B 00 39 39 95 80
	7190 02 02 0B 00 1B 1B 95 80 23 23 80 8A 3B 3B 80 95
	71A0 3B 3B 80 8B 3B 3B 80 95 3B 3B 00 2B 38 38 C0 C5
	71B0 3B 3B F0 F0 20 20 60 60 1C 1C 00 00 1E 1E 00 00
	71C0 0C 0C 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ..............@@ ..............@@
         ......@@@@@@@@@@ ......@@@@@@@@@@
         ....@@@......... ....@@@.........
         ..@@@..@.@.@.@.@ ..@@@...........
         @@@...@...@.@.@@ @@@.............
         @....@.@.@.@.@.@ @...............
         @.....@...@.@.@@ @..@@...........
         .......@.@.@.@.@ ..@@@@..........
         ................ ..@..@..........
         .@..@..@...@.@.@ ....@..@...@.@.@
         @..@@@@.@....... ...@@@@.@.......
         .@.@.@@@.@.@.@.@ ...@.@@@.@......
         @.@.@@@@.@..@.@@ ..@.@@@@.@......
         ..@@..@@@.@..@.@ ..@@..@@@.@.....
         @.@.@@..@.@.@.@@ ..@.@@..@.@.....
         ..@.@@@@.@...@.@ ..@.@@@@.@......
         @..@.@@.@.@@..@@ ...@.@@.@.@@....
         .@.......@.@.... .........@.@....
         @..@@@@.@@@.@..@ ...@@@@.@@@.@..@
         ..@.@@@@@@@.@... ..@.@@@@@@@.@...
         .@@.@@@@.@@.@.@@ .@@.@@@@.@@.@...
         @..@@@@@.@@..@.@ ...@@@@@.@@.....
         .@@.@@@@.@@.@.@@ .@@.@@@@.@@.@...
         .@@.@@@@.@@..@.@ .@@.@@@@.@@.....
         .@@.@@@@.@@.@.@@ .@@.@@@@.@@.@...
         .@.@@@@@.@..@..@ .@.@@@@@.@..@...
         @..@@@@@.@..@... ...@@@@@.@..@...
         .@..@@@.@...@..@ .@..@@@.@...@..@
         @..@@@@..@...... ...@@@@..@......
         .@.....@@@..@..@ .@.....@@@..@...
         .@.@@@@@@..@..@@ .@.@@@@@@..@....
         .@.@@@@@.@.@@..@ .@.@@@@@.@.@@...
         .@....@.@@....@@ .@....@.@@......
         ...@@@.@@@...@.@ ...@@@.@@@......
         .@.@@@.@@@..@.@@ .@.@@@.@@@......
         ..@.@@.@@@...... ..@.@@.@@@......
         .@@.@@.@@@.@.@.@ .@@.@@.@@@.@.@.@
         @..@@@.@@....... ...@@@.@@.......
         ..@@@@......@.@@ ..@@@@..........
         ..@@@..@@..@.@.@ ..@@@..@@.......
         ......@.....@.@@ ......@.........
         ...@@.@@@..@.@.@ ...@@.@@@.......
         ..@...@@@....... ..@...@@@...@.@.
         ..@@@.@@@....... ..@@@.@@@..@.@.@
         ..@@@.@@@....... ..@@@.@@@...@.@@
         ..@@@.@@@....... ..@@@.@@@..@.@.@
         ..@@@.@@........ ..@@@.@@..@.@.@@
         ..@@@...@@...... ..@@@...@@...@.@
         ..@@@.@@@@@@.... ..@@@.@@@@@@....
         ..@......@@..... ..@......@@.....
         ...@@@.......... ...@@@..........
         ...@@@@......... ...@@@@.........
         ....@@.......... ....@@..........
         ................ ................
         ................ ................
         ................ ................

img_blacktooth_wall_1:
	71D0 00 00 03 03 00 00 07 07 00 00 30 30 00 00 D7 D0
	71E0 03 03 D7 D0 0F 0F 17 10 3C 3C D7 10 53 50 D7 10
	71F0 8F 80 DB 18 1F 00 D4 14 9F 00 33 33 9C 00 D4 D0
	7200 93 03 17 10 8C 0C D7 10 B3 30 D7 10 8F 00 D7 10
	7210 1F 00 D7 10 9F 80 D3 10 1F 00 D4 14 9F 00 33 33
	7220 9C 00 D4 D0 93 03 17 10 8C 0C D7 10 B3 30 D7 10
	7230 8F 00 D7 10 1F 00 D7 10 9F 80 D3 10 1F 00 D4 14
	7240 9F 00 33 33 9C 00 D4 D0 93 03 17 10 8C 0C D7 10
	7250 B3 30 D7 10 8F 00 D7 10 1F 00 D7 10 9F 80 DB 18
	7260 1F 00 D4 14 9F 00 33 33 9C 00 D4 D0 93 03 17 10
	7270 8C 0C D7 10 B3 30 D7 10 8F 00 D7 10 1F 00 C0 00
	7280 9F 80 00 0B 1C 00 00 2D 90 00 00 BD 80 02 00 DD
	7290 80 0B 00 DA 80 2D 00 D8 00 3D 00 A0 00 DD 00 80
	72A0 00 DA 00 00 00 D8 00 00 00 A0 00 00 00 80 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ..............@@ ..............@@
         .............@@@ .............@@@
         ..........@@.... ..........@@....
         ........@@.@.@@@ ........@@.@....
         ......@@@@.@.@@@ ......@@@@.@....
         ....@@@@...@.@@@ ....@@@@...@....
         ..@@@@..@@.@.@@@ ..@@@@.....@....
         .@.@..@@@@.@.@@@ .@.@.......@....
         @...@@@@@@.@@.@@ @..........@@...
         ...@@@@@@@.@.@.. ...........@.@..
         @..@@@@@..@@..@@ ..........@@..@@
         @..@@@..@@.@.@.. ........@@.@....
         @..@..@@...@.@@@ ......@@...@....
         @...@@..@@.@.@@@ ....@@.....@....
         @.@@..@@@@.@.@@@ ..@@.......@....
         @...@@@@@@.@.@@@ ...........@....
         ...@@@@@@@.@.@@@ ...........@....
         @..@@@@@@@.@..@@ @..........@....
         ...@@@@@@@.@.@.. ...........@.@..
         @..@@@@@..@@..@@ ..........@@..@@
         @..@@@..@@.@.@.. ........@@.@....
         @..@..@@...@.@@@ ......@@...@....
         @...@@..@@.@.@@@ ....@@.....@....
         @.@@..@@@@.@.@@@ ..@@.......@....
         @...@@@@@@.@.@@@ ...........@....
         ...@@@@@@@.@.@@@ ...........@....
         @..@@@@@@@.@..@@ @..........@....
         ...@@@@@@@.@.@.. ...........@.@..
         @..@@@@@..@@..@@ ..........@@..@@
         @..@@@..@@.@.@.. ........@@.@....
         @..@..@@...@.@@@ ......@@...@....
         @...@@..@@.@.@@@ ....@@.....@....
         @.@@..@@@@.@.@@@ ..@@.......@....
         @...@@@@@@.@.@@@ ...........@....
         ...@@@@@@@.@.@@@ ...........@....
         @..@@@@@@@.@@.@@ @..........@@...
         ...@@@@@@@.@.@.. ...........@.@..
         @..@@@@@..@@..@@ ..........@@..@@
         @..@@@..@@.@.@.. ........@@.@....
         @..@..@@...@.@@@ ......@@...@....
         @...@@..@@.@.@@@ ....@@.....@....
         @.@@..@@@@.@.@@@ ..@@.......@....
         @...@@@@@@.@.@@@ ...........@....
         ...@@@@@@@...... ................
         @..@@@@@........ @...........@.@@
         ...@@@.......... ..........@.@@.@
         @..@............ ........@.@@@@.@
         @............... ......@.@@.@@@.@
         @............... ....@.@@@@.@@.@.
         @............... ..@.@@.@@@.@@...
         ................ ..@@@@.@@.@.....
         ................ @@.@@@.@@.......
         ................ @@.@@.@.........
         ................ @@.@@...........
         ................ @.@.............
         ................ @...............

img_blacktooth_wall_2:
	72B0 00 00 03 03 00 00 07 07 00 00 30 30 00 00 D7 D0
	72C0 03 03 D7 D0 0F 0F 17 10 3C 3C D7 10 53 50 D7 10
	72D0 8F 80 DB 18 1F 00 D4 14 9F 00 33 33 9C 00 C4 C0
	72E0 93 03 17 10 8C 0C C7 00 B3 30 17 10 8C 00 67 60
	72F0 10 00 87 80 87 87 83 80 1F 1F 84 84 99 19 83 93
	7300 93 13 84 B0 9B 1B 07 70 9E 1E 07 F0 9C 1D 07 E0
	7310 90 13 07 C0 00 0F 07 80 80 9F 03 00 00 1E 84 84
	7320 81 19 83 83 87 07 84 80 9D 1D 87 80 9C 1C 87 80
	7330 99 19 87 80 8D 0D 97 90 0F 0F 97 90 83 83 5B 18
	7340 18 00 D4 14 9F 00 33 33 9C 00 D4 D0 93 03 17 10
	7350 8C 0C D7 10 B3 30 D7 10 8F 00 D7 10 1F 00 C0 00
	7360 9F 80 00 0B 1C 00 00 2D 90 00 00 BD 80 02 00 DD
	7370 80 0B 00 DA 80 2D 00 D8 00 3D 00 A0 00 DD 00 80
	7380 00 DA 00 00 00 D8 00 00 00 A0 00 00 00 80 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

	         ..............@@ ..............@@
         .............@@@ .............@@@
         ..........@@.... ..........@@....
         ........@@.@.@@@ ........@@.@....
         ......@@@@.@.@@@ ......@@@@.@....
         ....@@@@...@.@@@ ....@@@@...@....
         ..@@@@..@@.@.@@@ ..@@@@.....@....
         .@.@..@@@@.@.@@@ .@.@.......@....
         @...@@@@@@.@@.@@ @..........@@...
         ...@@@@@@@.@.@.. ...........@.@..
         @..@@@@@..@@..@@ ..........@@..@@
         @..@@@..@@...@.. ........@@......
         @..@..@@...@.@@@ ......@@...@....
         @...@@..@@...@@@ ....@@..........
         @.@@..@@...@.@@@ ..@@.......@....
         @...@@...@@..@@@ .........@@.....
         ...@....@....@@@ ........@.......
         @....@@@@.....@@ @....@@@@.......
         ...@@@@@@....@.. ...@@@@@@....@..
         @..@@..@@.....@@ ...@@..@@..@..@@
         @..@..@@@....@.. ...@..@@@.@@....
         @..@@.@@.....@@@ ...@@.@@.@@@....
         @..@@@@......@@@ ...@@@@.@@@@....
         @..@@@.......@@@ ...@@@.@@@@.....
         @..@.........@@@ ...@..@@@@......
         .............@@@ ....@@@@@.......
         @.............@@ @..@@@@@........
         ........@....@.. ...@@@@.@....@..
         @......@@.....@@ ...@@..@@.....@@
         @....@@@@....@.. .....@@@@.......
         @..@@@.@@....@@@ ...@@@.@@.......
         @..@@@..@....@@@ ...@@@..@.......
         @..@@..@@....@@@ ...@@..@@.......
         @...@@.@@..@.@@@ ....@@.@@..@....
         ....@@@@@..@.@@@ ....@@@@@..@....
         @.....@@.@.@@.@@ @.....@@...@@...
         ...@@...@@.@.@.. ...........@.@..
         @..@@@@@..@@..@@ ..........@@..@@
         @..@@@..@@.@.@.. ........@@.@....
         @..@..@@...@.@@@ ......@@...@....
         @...@@..@@.@.@@@ ....@@.....@....
         @.@@..@@@@.@.@@@ ..@@.......@....
         @...@@@@@@.@.@@@ ...........@....
         ...@@@@@@@...... ................
         @..@@@@@........ @...........@.@@
         ...@@@.......... ..........@.@@.@
         @..@............ ........@.@@@@.@
         @............... ......@.@@.@@@.@
         @............... ....@.@@@@.@@.@.
         @............... ..@.@@.@@@.@@...
         ................ ..@@@@.@@.@.....
         ................ @@.@@@.@@.......
         ................ @@.@@.@.........
         ................ @@.@@...........
         ................ @.@.............
         ................ @...............

img_market_walls:
img_market_wall_0:
	; 4 bytes * 56 : interlaced : wall1 + maskwall1 + wall2 + maskwall2 (each are 1byte wide*56)
	7390 00 00 03 00 00 00 0F 00 00 00 3E 00 00 00 D9 00
	73A0 03 00 67 00 0D 00 95 00 36 00 76 00 D9 00 F0 01
	73B0 E7 00 E0 07 97 00 80 1F 76 00 60 6F D1 01 F0 F7
	73C0 67 07 F8 FB 9F 1F FC FD 0F 6F FC FC 07 F7 F2 F2
	73D0 03 FB CE CE 01 FD 3E 3E 00 FC FE FE 00 F2 FC FC
	73E0 00 CE 79 79 00 3E 05 05 00 FE 1A 1A 00 FC DD DD
	73F0 00 7A A3 A3 00 01 5D 5D 00 00 3A BA C0 00 1D 5D
	7400 C0 00 0B 2B DC 1C 03 13 DA 1A 01 09 DD 1D C0 C4
	7410 C3 03 A0 A3 DD 1D C0 CC DA 1A 02 30 DC 1C 0E C0
	7420 C0 03 2E 00 C0 0C EE 00 C2 10 ED 00 CE 00 E1 00
	7430 DE 00 C5 00 DE 00 05 10 DC 00 65 00 C1 00 F5 00
	7440 C3 00 F5 00 C0 00 F1 00 C0 00 0D 0C C0 00 39 38
	7450 C0 00 E5 E0 C3 03 80 80 CE 0E 00 00 D8 18 00 00
	7460 C0 00 00 00 C0 00 00 00 C0 00 00 00 80 00 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:
         ..............@@ ................
         ............@@@@ ................
         ..........@@@@@. ................
         ........@@.@@..@ ................
         ......@@.@@..@@@ ................
         ....@@.@@..@.@.@ ................
         ..@@.@@..@@@.@@. ................
         @@.@@..@@@@@.... ...............@
         @@@..@@@@@@..... .............@@@
         @..@.@@@@....... ...........@@@@@
         .@@@.@@..@@..... .........@@.@@@@
         @@.@...@@@@@.... .......@@@@@.@@@
         .@@..@@@@@@@@... .....@@@@@@@@.@@
         @..@@@@@@@@@@@.. ...@@@@@@@@@@@.@
         ....@@@@@@@@@@.. .@@.@@@@@@@@@@..
         .....@@@@@@@..@. @@@@.@@@@@@@..@.
         ......@@@@..@@@. @@@@@.@@@@..@@@.
         .......@..@@@@@. @@@@@@.@..@@@@@.
         ........@@@@@@@. @@@@@@..@@@@@@@.
         ........@@@@@@.. @@@@..@.@@@@@@..
         .........@@@@..@ @@..@@@..@@@@..@
         .............@.@ ..@@@@@......@.@
         ...........@@.@. @@@@@@@....@@.@.
         ........@@.@@@.@ @@@@@@..@@.@@@.@
         ........@.@...@@ .@@@@.@.@.@...@@
         .........@.@@@.@ .......@.@.@@@.@
         ..........@@@.@. ........@.@@@.@.
         @@.........@@@.@ .........@.@@@.@
         @@..........@.@@ ..........@.@.@@
         @@.@@@........@@ ...@@@.....@..@@
         @@.@@.@........@ ...@@.@.....@..@
         @@.@@@.@@@...... ...@@@.@@@...@..
         @@....@@@.@..... ......@@@.@...@@
         @@.@@@.@@@...... ...@@@.@@@..@@..
         @@.@@.@.......@. ...@@.@...@@....
         @@.@@@......@@@. ...@@@..@@......
         @@........@.@@@. ......@@........
         @@......@@@.@@@. ....@@..........
         @@....@.@@@.@@.@ ...@............
         @@..@@@.@@@....@ ................
         @@.@@@@.@@...@.@ ................
         @@.@@@@......@.@ ...........@....
         @@.@@@...@@..@.@ ................
         @@.....@@@@@.@.@ ................
         @@....@@@@@@.@.@ ................
         @@......@@@@...@ ................
         @@..........@@.@ ............@@..
         @@........@@@..@ ..........@@@...
         @@......@@@..@.@ ........@@@.....
         @@....@@@....... ......@@@.......
         @@..@@@......... ....@@@.........
         @@.@@........... ...@@...........
         @@.............. ................
         @@.............. ................
         @@.............. ................
         @............... ................

img_market_wall_1:
	7470 00 00 03 00 00 00 0F 00 00 00 3E 00 00 00 D9 00
	7480 03 00 67 00 0D 00 95 00 36 00 76 00 D9 00 F0 01
	7490 E7 00 E0 07 97 00 80 1F 76 00 60 6F D1 01 F0 F7
	74A0 67 07 F8 FB 9F 1F FC FD 0F 6F FC FC 07 F7 F2 F2
	74B0 03 FB CE CE 01 FD 3E 3E 00 FC FE FE 00 F2 FC FC
	74C0 00 CE 79 78 00 3E 05 00 00 FE 05 00 00 FC 05 00
	74D0 00 7A 05 00 00 01 05 00 00 00 05 80 C0 C0 05 40
	74E0 A0 A0 05 20 DC DC 05 10 3A 3A 01 08 DD DD C1 C4
	74F0 A3 A3 A0 A2 DD DD C0 CC 3A 3A 02 30 DC DC 0E C0
	7500 A0 A3 2E 00 C0 CC EE 00 02 30 ED 00 0E C0 E1 00
	7510 2E 00 C5 00 EE 00 05 10 EC 00 65 00 E1 00 F5 00
	7520 C3 00 F5 00 00 00 F1 00 80 00 0D 0C 80 00 39 38
	7530 80 00 E5 E0 83 03 80 80 8E 0E 00 00 B8 38 00 00
	7540 A0 20 00 00 80 00 00 00 80 00 00 00 80 00 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ..............@@ ................
         ............@@@@ ................
         ..........@@@@@. ................
         ........@@.@@..@ ................
         ......@@.@@..@@@ ................
         ....@@.@@..@.@.@ ................
         ..@@.@@..@@@.@@. ................
         @@.@@..@@@@@.... ...............@
         @@@..@@@@@@..... .............@@@
         @..@.@@@@....... ...........@@@@@
         .@@@.@@..@@..... .........@@.@@@@
         @@.@...@@@@@.... .......@@@@@.@@@
         .@@..@@@@@@@@... .....@@@@@@@@.@@
         @..@@@@@@@@@@@.. ...@@@@@@@@@@@.@
         ....@@@@@@@@@@.. .@@.@@@@@@@@@@..
         .....@@@@@@@..@. @@@@.@@@@@@@..@.
         ......@@@@..@@@. @@@@@.@@@@..@@@.
         .......@..@@@@@. @@@@@@.@..@@@@@.
         ........@@@@@@@. @@@@@@..@@@@@@@.
         ........@@@@@@.. @@@@..@.@@@@@@..
         .........@@@@..@ @@..@@@..@@@@...
         .............@.@ ..@@@@@.........
         .............@.@ @@@@@@@.........
         .............@.@ @@@@@@..........
         .............@.@ .@@@@.@.........
         .............@.@ .......@........
         .............@.@ ........@.......
         @@...........@.@ @@.......@......
         @.@..........@.@ @.@.......@.....
         @@.@@@.......@.@ @@.@@@.....@....
         ..@@@.@........@ ..@@@.@.....@...
         @@.@@@.@@@.....@ @@.@@@.@@@...@..
         @.@...@@@.@..... @.@...@@@.@...@.
         @@.@@@.@@@...... @@.@@@.@@@..@@..
         ..@@@.@.......@. ..@@@.@...@@....
         @@.@@@......@@@. @@.@@@..@@......
         @.@.......@.@@@. @.@...@@........
         @@......@@@.@@@. @@..@@..........
         ......@.@@@.@@.@ ..@@............
         ....@@@.@@@....@ @@..............
         ..@.@@@.@@...@.@ ................
         @@@.@@@......@.@ ...........@....
         @@@.@@...@@..@.@ ................
         @@@....@@@@@.@.@ ................
         @@....@@@@@@.@.@ ................
         ........@@@@...@ ................
         @...........@@.@ ............@@..
         @.........@@@..@ ..........@@@...
         @.......@@@..@.@ ........@@@.....
         @.....@@@....... ......@@@.......
         @...@@@......... ....@@@.........
         @.@@@........... ..@@@...........
         @.@............. ..@.............
         @............... ................
         @............... ................
         @............... ................

img_market_wall_2:
	7550 00 00 03 00 00 00 0F 00 00 00 3E 00 00 00 D9 00
	7560 03 00 67 00 0D 00 95 00 36 00 76 00 D9 00 F0 01
	7570 E7 00 E0 07 8F 00 80 1F 6E 00 60 6F C9 01 F0 F7
	7580 67 07 F8 FB 9F 1F FC FD 0F 6F FC FC 07 F7 F2 F2
	7590 03 FB CE CE 01 FD 3E 3E 00 FC FE FE 00 F2 FC FC
	75A0 00 CE 78 78 00 3E 06 00 00 FE 06 00 00 FC 06 00
	75B0 00 78 36 00 00 00 76 00 01 00 36 00 85 00 C6 00
	75C0 85 00 E6 00 89 00 E6 00 AE 00 62 00 AF 00 04 04
	75D0 8F 00 4A 0A B3 00 1C 1C BC 00 6A 68 80 00 B6 B0
	75E0 DB 1B 66 60 AD 2D 96 80 DB 1B 36 00 80 00 16 80
	75F0 BE 00 06 60 BF 00 86 10 BF 00 E6 00 8F 00 F6 00
	7600 83 00 F6 00 80 00 F6 00 80 00 36 00 80 00 08 00
	7610 80 00 06 00 80 00 00 00 80 00 00 00 80 00 00 00
	7620 80 00 00 00 80 00 00 00 80 00 00 00 80 00 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ..............@@ ................
         ............@@@@ ................
         ..........@@@@@. ................
         ........@@.@@..@ ................
         ......@@.@@..@@@ ................
         ....@@.@@..@.@.@ ................
         ..@@.@@..@@@.@@. ................
         @@.@@..@@@@@.... ...............@
         @@@..@@@@@@..... .............@@@
         @...@@@@@....... ...........@@@@@
         .@@.@@@..@@..... .........@@.@@@@
         @@..@..@@@@@.... .......@@@@@.@@@
         .@@..@@@@@@@@... .....@@@@@@@@.@@
         @..@@@@@@@@@@@.. ...@@@@@@@@@@@.@
         ....@@@@@@@@@@.. .@@.@@@@@@@@@@..
         .....@@@@@@@..@. @@@@.@@@@@@@..@.
         ......@@@@..@@@. @@@@@.@@@@..@@@.
         .......@..@@@@@. @@@@@@.@..@@@@@.
         ........@@@@@@@. @@@@@@..@@@@@@@.
         ........@@@@@@.. @@@@..@.@@@@@@..
         .........@@@@... @@..@@@..@@@@...
         .............@@. ..@@@@@.........
         .............@@. @@@@@@@.........
         .............@@. @@@@@@..........
         ..........@@.@@. .@@@@...........
         .........@@@.@@. ................
         .......@..@@.@@. ................
         @....@.@@@...@@. ................
         @....@.@@@@..@@. ................
         @...@..@@@@..@@. ................
         @.@.@@@..@@...@. ................
         @.@.@@@@.....@.. .............@..
         @...@@@@.@..@.@. ............@.@.
         @.@@..@@...@@@.. ...........@@@..
         @.@@@@...@@.@.@. .........@@.@...
         @.......@.@@.@@. ........@.@@....
         @@.@@.@@.@@..@@. ...@@.@@.@@.....
         @.@.@@.@@..@.@@. ..@.@@.@@.......
         @@.@@.@@..@@.@@. ...@@.@@........
         @..........@.@@. ........@.......
         @.@@@@@......@@. .........@@.....
         @.@@@@@@@....@@. ...........@....
         @.@@@@@@@@@..@@. ................
         @...@@@@@@@@.@@. ................
         @.....@@@@@@.@@. ................
         @.......@@@@.@@. ................
         @.........@@.@@. ................
         @...........@... ................
         @............@@. ................
         @............... ................
         @............... ................
         @............... ................
         @............... ................
         @............... ................
         @............... ................
         @............... ................

img_egyptus_walls:
img_egyptus_wall_0:
	; 4 bytes * 56 : interlaced : wall1 + maskwall1 + wall2 + maskwall2 (each are 1byte wide*56)
	7630 00 00 03 03 00 00 0E 0E 00 00 38 38 00 00 E0 E6
	7640 03 03 80 9E 0E 0E 00 7C 38 39 02 E0 E0 E7 1E C0
	7650 80 9E 3C 00 01 7C F2 02 03 E0 CC 0C 1F C0 32 30
	7660 3C 00 CE C0 F3 03 3E 00 CC 0C F2 00 33 30 F6 00
	7670 CF C0 3A 00 3E 00 16 40 FE 00 3A 00 EB 00 D6 00
	7680 A7 00 3E 00 CF 00 DE 00 EF 00 3A 00 D7 00 FE 00
	7690 DF 00 FC 00 F7 00 F2 02 CF 00 CC 0C FF 00 32 30
	76A0 FC 00 CE C0 F3 03 3E 00 CC 0C FE 00 33 30 FE 00
	76B0 CF C0 FE 00 3E 00 7E 00 FC 00 3E 80 F8 00 1E C0
	76C0 F0 01 0E E0 E0 01 06 F0 C0 01 06 E0 C0 03 1E 80
	76D0 E0 02 7C 00 F9 00 F2 02 FF 00 CC 0C FF 00 32 30
	76E0 FC 00 CE C0 F3 03 3E 00 CC 0C FC 00 33 30 E0 02
	76F0 CF C0 C0 1E 3E 00 00 3C FC 01 00 F0 E0 03 00 C0
	7700 C0 1F 00 00 00 3C 00 00 00 F0 00 00 00 C0 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ..............@@ ..............@@
         ............@@@. ............@@@.
         ..........@@@... ..........@@@...
         ........@@@..... ........@@@..@@.
         ......@@@....... ......@@@..@@@@.
         ....@@@......... ....@@@..@@@@@..
         ..@@@.........@. ..@@@..@@@@.....
         @@@........@@@@. @@@..@@@@@......
         @.........@@@@.. @..@@@@.........
         .......@@@@@..@. .@@@@@........@.
         ......@@@@..@@.. @@@.........@@..
         ...@@@@@..@@..@. @@........@@....
         ..@@@@..@@..@@@. ........@@......
         @@@@..@@..@@@@@. ......@@........
         @@..@@..@@@@..@. ....@@..........
         ..@@..@@@@@@.@@. ..@@............
         @@..@@@@..@@@.@. @@..............
         ..@@@@@....@.@@. .........@......
         @@@@@@@...@@@.@. ................
         @@@.@.@@@@.@.@@. ................
         @.@..@@@..@@@@@. ................
         @@..@@@@@@.@@@@. ................
         @@@.@@@@..@@@.@. ................
         @@.@.@@@@@@@@@@. ................
         @@.@@@@@@@@@@@.. ................
         @@@@.@@@@@@@..@. ..............@.
         @@..@@@@@@..@@.. ............@@..
         @@@@@@@@..@@..@. ..........@@....
         @@@@@@..@@..@@@. ........@@......
         @@@@..@@..@@@@@. ......@@........
         @@..@@..@@@@@@@. ....@@..........
         ..@@..@@@@@@@@@. ..@@............
         @@..@@@@@@@@@@@. @@..............
         ..@@@@@..@@@@@@. ................
         @@@@@@....@@@@@. ........@.......
         @@@@@......@@@@. ........@@......
         @@@@........@@@. .......@@@@.....
         @@@..........@@. .......@@@@@....
         @@...........@@. .......@@@@.....
         @@.........@@@@. ......@@@.......
         @@@......@@@@@.. ......@.........
         @@@@@..@@@@@..@. ..............@.
         @@@@@@@@@@..@@.. ............@@..
         @@@@@@@@..@@..@. ..........@@....
         @@@@@@..@@..@@@. ........@@......
         @@@@..@@..@@@@@. ......@@........
         @@..@@..@@@@@@.. ....@@..........
         ..@@..@@@@@..... ..@@..........@.
         @@..@@@@@@...... @@.........@@@@.
         ..@@@@@......... ..........@@@@..
         @@@@@@.......... .......@@@@@....
         @@@............. ......@@@@......
         @@.............. ...@@@@@........
         ................ ..@@@@..........
         ................ @@@@............
         ................ @@..............

img_egyptus_wall_1:
	7710 00 00 FF FF 03 03 80 80 0E 0E 00 2A 38 39 00 54
	7720 E0 E2 2A 00 81 94 54 00 8A A0 2A 00 15 40 54 00
	7730 20 00 2A 2A 1F 1F 94 80 7F 7F CA C0 7E 7E 54 40
	7740 F9 F8 AA 20 F7 F0 24 20 F1 F0 AA 20 F7 F0 B0 30
	7750 F7 F0 A2 20 F3 F0 00 18 30 34 02 B8 00 C7 00 F8
	7760 00 7F 02 F8 00 FF 00 F8 00 FF 02 78 00 FB 00 B8
	7770 00 EF 02 BA 00 F7 00 78 00 EF 02 50 00 FF 00 E0
	7780 00 FD 02 F0 00 FB 04 F0 00 FF 0A E0 00 EF 04 E0
	7790 00 7F 0A E0 00 FF 04 E0 00 7F 0A E0 00 BF 14 C0
	77A0 00 7F 0A C0 00 BF 14 C0 00 7D 0A C0 00 BF 14 C0
	77B0 00 7D 0A CA 00 BF 14 C0 00 7D 0A C0 00 BF 14 C0
	77C0 00 7D 0A C0 00 BF 04 E0 00 7E 00 F2 00 BF 00 F4
	77D0 00 5F 00 F0 00 AF 00 F0 00 5F 00 E0 00 AF 00 80
	77E0 00 5E 00 00 00 18 00 00 00 00 00 00 00 00 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ........@@@@@@@@ ........@@@@@@@@
         ......@@@....... ......@@@.......
         ....@@@......... ....@@@...@.@.@.
         ..@@@........... ..@@@..@.@.@.@..
         @@@.......@.@.@. @@@...@.........
         @......@.@.@.@.. @..@.@..........
         @...@.@...@.@.@. @.@.............
         ...@.@.@.@.@.@.. .@..............
         ..@.......@.@.@. ..........@.@.@.
         ...@@@@@@..@.@.. ...@@@@@@.......
         .@@@@@@@@@..@.@. .@@@@@@@@@......
         .@@@@@@..@.@.@.. .@@@@@@..@......
         @@@@@..@@.@.@.@. @@@@@.....@.....
         @@@@.@@@..@..@.. @@@@......@.....
         @@@@...@@.@.@.@. @@@@......@.....
         @@@@.@@@@.@@.... @@@@......@@....
         @@@@.@@@@.@...@. @@@@......@.....
         @@@@..@@........ @@@@.......@@...
         ..@@..........@. ..@@.@..@.@@@...
         ................ @@...@@@@@@@@...
         ..............@. .@@@@@@@@@@@@...
         ................ @@@@@@@@@@@@@...
         ..............@. @@@@@@@@.@@@@...
         ................ @@@@@.@@@.@@@...
         ..............@. @@@.@@@@@.@@@.@.
         ................ @@@@.@@@.@@@@...
         ..............@. @@@.@@@@.@.@....
         ................ @@@@@@@@@@@.....
         ..............@. @@@@@@.@@@@@....
         .............@.. @@@@@.@@@@@@....
         ............@.@. @@@@@@@@@@@.....
         .............@.. @@@.@@@@@@@.....
         ............@.@. .@@@@@@@@@@.....
         .............@.. @@@@@@@@@@@.....
         ............@.@. .@@@@@@@@@@.....
         ...........@.@.. @.@@@@@@@@......
         ............@.@. .@@@@@@@@@......
         ...........@.@.. @.@@@@@@@@......
         ............@.@. .@@@@@.@@@......
         ...........@.@.. @.@@@@@@@@......
         ............@.@. .@@@@@.@@@..@.@.
         ...........@.@.. @.@@@@@@@@......
         ............@.@. .@@@@@.@@@......
         ...........@.@.. @.@@@@@@@@......
         ............@.@. .@@@@@.@@@......
         .............@.. @.@@@@@@@@@.....
         ................ .@@@@@@.@@@@..@.
         ................ @.@@@@@@@@@@.@..
         ................ .@.@@@@@@@@@....
         ................ @.@.@@@@@@@@....
         ................ .@.@@@@@@@@.....
         ................ @.@.@@@@@.......
         ................ .@.@@@@.........
         ................ ...@@...........
         ................ ................
         ................ ................

img_penitentiary_walls:
img_penitentiary_wall_0:
	; 4 bytes * 56 : interlaced : wall1 + maskwall1 + wall2 + maskwall2 (each are 1byte wide*56)
	77F0 00 00 02 02 00 00 06 06 00 00 28 28 00 00 66 60
	7800 02 02 9C 80 06 06 72 00 29 28 D4 00 67 60 AA 00
	7810 9D 80 54 00 7A 00 A8 00 D5 00 50 00 AA 00 A6 00
	7820 D5 00 1C 00 AA 00 7A 00 D0 00 C4 00 A6 00 92 10
	7830 1C 00 64 60 71 01 80 90 C6 06 00 70 98 19 06 F0
	7840 D0 17 04 00 90 14 02 D0 D1 15 00 68 90 12 80 A8
	7850 10 16 80 AC 61 0D 00 4C C0 0C 00 0C 80 18 A0 0C
	7860 C1 18 00 18 80 18 42 18 C0 18 80 30 80 0C 02 70
	7870 00 0F 04 E0 60 07 0A 80 D0 00 10 00 AA 00 A6 00
	7880 D4 00 1C 00 AA 00 7A 00 D1 00 D4 00 A7 00 AA 00
	7890 1D 00 04 00 78 00 00 F0 D0 03 00 0C A0 0C 20 24
	78A0 C1 19 20 2A 81 31 20 2A 81 21 20 2A 09 69 20 2A
	78B0 09 49 20 22 09 C9 00 4C 08 4A 00 30 08 C8 00 C0
	78C0 00 B3 00 00 00 8C 00 00 00 B0 00 00 00 C0 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ..............@. ..............@.
         .............@@. .............@@.
         ..........@.@... ..........@.@...
         .........@@..@@. .........@@.....
         ......@.@..@@@.. ......@.@.......
         .....@@..@@@..@. .....@@.........
         ..@.@..@@@.@.@.. ..@.@...........
         .@@..@@@@.@.@.@. .@@.............
         @..@@@.@.@.@.@.. @...............
         .@@@@.@.@.@.@... ................
         @@.@.@.@.@.@.... ................
         @.@.@.@.@.@..@@. ................
         @@.@.@.@...@@@.. ................
         @.@.@.@..@@@@.@. ................
         @@.@....@@...@.. ................
         @.@..@@.@..@..@. ...........@....
         ...@@@...@@..@.. .........@@.....
         .@@@...@@....... .......@@..@....
         @@...@@......... .....@@..@@@....
         @..@@........@@. ...@@..@@@@@....
         @@.@.........@.. ...@.@@@........
         @..@..........@. ...@.@..@@.@....
         @@.@...@........ ...@.@.@.@@.@...
         @..@....@....... ...@..@.@.@.@...
         ...@....@....... ...@.@@.@.@.@@..
         .@@....@........ ....@@.@.@..@@..
         @@.............. ....@@......@@..
         @.......@.@..... ...@@.......@@..
         @@.....@........ ...@@......@@...
         @........@....@. ...@@......@@...
         @@......@....... ...@@.....@@....
         @.............@. ....@@...@@@....
         .............@.. ....@@@@@@@.....
         .@@.........@.@. .....@@@@.......
         @@.@.......@.... ................
         @.@.@.@.@.@..@@. ................
         @@.@.@.....@@@.. ................
         @.@.@.@..@@@@.@. ................
         @@.@...@@@.@.@.. ................
         @.@..@@@@.@.@.@. ................
         ...@@@.@.....@.. ................
         .@@@@........... ........@@@@....
         @@.@............ ......@@....@@..
         @.@.......@..... ....@@....@..@..
         @@.....@..@..... ...@@..@..@.@.@.
         @......@..@..... ..@@...@..@.@.@.
         @......@..@..... ..@....@..@.@.@.
         ....@..@..@..... .@@.@..@..@.@.@.
         ....@..@..@..... .@..@..@..@...@.
         ....@..@........ @@..@..@.@..@@..
         ....@........... .@..@.@...@@....
         ....@........... @@..@...@@......
         ................ @.@@..@@........
         ................ @...@@..........
         ................ @.@@............
         ................ @@..............

img_penitentiary_wall_1:
	78D0 00 00 22 22 02 02 76 76 06 06 88 88 29 28 54 00
	78E0 62 60 22 00 95 80 4C 0C 2A 00 1E 1E 51 00 0A 2A
	78F0 A6 06 00 30 5F 1F 80 80 3F 3F D2 D0 BC BC 98 98
	7900 D8 D8 92 90 DD DD 48 48 46 46 52 50 1B 9B 98 98
	7910 08 08 50 50 87 87 B0 B0 C8 C8 26 20 64 64 C4 C0
	7920 4B 4B 22 20 1D 1D C4 C0 21 21 22 20 1D 1D C4 C0
	7930 21 21 20 20 1D 1D C0 C0 22 22 0E 00 1C 1C 14 00
	7940 00 00 2A 00 0C 0C 14 00 03 03 8A 80 1B 1B C4 C0
	7950 3E 3E C8 C0 6E 6E C0 C0 67 67 8E 80 7F 7F 14 00
	7960 1A 1A 8A 80 69 69 84 80 31 31 CA C0 38 38 C4 C0
	7970 18 18 80 80 1C 1C 66 60 08 88 44 40 04 64 22 20
	7980 0C 4C C4 C0 10 51 0A 00 18 1B 14 80 10 51 0A 00
	7990 02 E2 80 80 03 43 E0 E0 80 80 C0 C0 E0 E0 00 00
	79A0 78 78 00 00 30 30 00 00 00 00 00 00 00 00 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ..........@...@. ..........@...@.
         ......@..@@@.@@. ......@..@@@.@@.
         .....@@.@...@... .....@@.@...@...
         ..@.@..@.@.@.@.. ..@.@...........
         .@@...@...@...@. .@@.............
         @..@.@.@.@..@@.. @...........@@..
         ..@.@.@....@@@@. ...........@@@@.
         .@.@...@....@.@. ..........@.@.@.
         @.@..@@......... .....@@...@@....
         .@.@@@@@@....... ...@@@@@@.......
         ..@@@@@@@@.@..@. ..@@@@@@@@.@....
         @.@@@@..@..@@... @.@@@@..@..@@...
         @@.@@...@..@..@. @@.@@...@..@....
         @@.@@@.@.@..@... @@.@@@.@.@..@...
         .@...@@..@.@..@. .@...@@..@.@....
         ...@@.@@@..@@... @..@@.@@@..@@...
         ....@....@.@.... ....@....@.@....
         @....@@@@.@@.... @....@@@@.@@....
         @@..@.....@..@@. @@..@.....@.....
         .@@..@..@@...@.. .@@..@..@@......
         .@..@.@@..@...@. .@..@.@@..@.....
         ...@@@.@@@...@.. ...@@@.@@@......
         ..@....@..@...@. ..@....@..@.....
         ...@@@.@@@...@.. ...@@@.@@@......
         ..@....@..@..... ..@....@..@.....
         ...@@@.@@@...... ...@@@.@@@......
         ..@...@.....@@@. ..@...@.........
         ...@@@.....@.@.. ...@@@..........
         ..........@.@.@. ................
         ....@@.....@.@.. ....@@..........
         ......@@@...@.@. ......@@@.......
         ...@@.@@@@...@.. ...@@.@@@@......
         ..@@@@@.@@..@... ..@@@@@.@@......
         .@@.@@@.@@...... .@@.@@@.@@......
         .@@..@@@@...@@@. .@@..@@@@.......
         .@@@@@@@...@.@.. .@@@@@@@........
         ...@@.@.@...@.@. ...@@.@.@.......
         .@@.@..@@....@.. .@@.@..@@.......
         ..@@...@@@..@.@. ..@@...@@@......
         ..@@@...@@...@.. ..@@@...@@......
         ...@@...@....... ...@@...@.......
         ...@@@...@@..@@. ...@@@...@@.....
         ....@....@...@.. @...@....@......
         .....@....@...@. .@@..@....@.....
         ....@@..@@...@.. .@..@@..@@......
         ...@........@.@. .@.@...@........
         ...@@......@.@.. ...@@.@@@.......
         ...@........@.@. .@.@...@........
         ......@.@....... @@@...@.@.......
         ......@@@@@..... .@....@@@@@.....
         @.......@@...... @.......@@......
         @@@............. @@@.............
         .@@@@........... .@@@@...........
         ..@@............ ..@@............
         ................ ................
         ................ ................

img_moonbase_walls:
img_moonbase_wall_0:
	; 4 bytes * 56 : interlaced : wall1 + maskwall1 + wall2 + maskwall2 (each are 1byte wide*56)
	79B0 00 00 0F 00 00 00 36 30 00 00 F8 F9 03 03 E0 E7
	79C0 0D 01 80 9E 1E 00 00 58 38 01 03 D0 60 07 0C 80
	79D0 80 1E 39 00 00 58 F2 00 03 D0 D0 00 0E 80 D4 00
	79E0 3F 00 B8 00 C7 00 F6 00 9B 00 B7 00 6D 00 EE 00
	79F0 3D 00 BE 00 B5 00 FD 00 99 00 F7 00 93 00 7F 00
	7A00 8F 00 C6 00 7B 00 3A 00 BE 00 F0 01 FC 00 20 06
	7A10 EB 00 01 19 F6 00 07 67 B0 01 07 B7 E0 06 43 5B
	7A20 81 19 E0 EC 07 67 F0 F7 07 B7 C0 CE 43 5B 01 38
	7A30 E0 EC 07 E0 F0 F7 1F 80 C0 CE 73 00 01 38 C3 08
	7A40 07 E0 03 08 1C 80 23 28 71 01 83 88 C2 02 23 28
	7A50 D9 19 83 88 C2 02 23 28 D9 19 83 88 C2 02 03 30
	7A60 D8 18 0F C0 C0 03 3E 00 C0 0C F9 01 C3 10 E6 06
	7A70 CF 00 98 1B FE 00 60 6C F9 01 80 B0 E6 06 00 C0
	7A80 98 1B 00 00 60 6C 00 00 80 B0 00 00 00 C0 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ............@@@@ ................
         ..........@@.@@. ..........@@....
         ........@@@@@... ........@@@@@..@
         ......@@@@@..... ......@@@@@..@@@
         ....@@.@@....... .......@@..@@@@.
         ...@@@@......... .........@.@@...
         ..@@@.........@@ .......@@@.@....
         .@@.........@@.. .....@@@@.......
         @.........@@@..@ ...@@@@.........
         ........@@@@..@. .@.@@...........
         ......@@@@.@.... @@.@............
         ....@@@.@@.@.@.. @...............
         ..@@@@@@@.@@@... ................
         @@...@@@@@@@.@@. ................
         @..@@.@@@.@@.@@@ ................
         .@@.@@.@@@@.@@@. ................
         ..@@@@.@@.@@@@@. ................
         @.@@.@.@@@@@@@.@ ................
         @..@@..@@@@@.@@@ ................
         @..@..@@.@@@@@@@ ................
         @...@@@@@@...@@. ................
         .@@@@.@@..@@@.@. ................
         @.@@@@@.@@@@.... ...............@
         @@@@@@....@..... .............@@.
         @@@.@.@@.......@ ...........@@..@
         @@@@.@@......@@@ .........@@..@@@
         @.@@.........@@@ .......@@.@@.@@@
         @@@......@....@@ .....@@..@.@@.@@
         @......@@@@..... ...@@..@@@@.@@..
         .....@@@@@@@.... .@@..@@@@@@@.@@@
         .....@@@@@...... @.@@.@@@@@..@@@.
         .@....@@.......@ .@.@@.@@..@@@...
         @@@..........@@@ @@@.@@..@@@.....
         @@@@.......@@@@@ @@@@.@@@@.......
         @@.......@@@..@@ @@..@@@.........
         .......@@@....@@ ..@@@.......@...
         .....@@@......@@ @@@.........@...
         ...@@@....@...@@ @.........@.@...
         .@@@...@@.....@@ .......@@...@...
         @@....@...@...@@ ......@...@.@...
         @@.@@..@@.....@@ ...@@..@@...@...
         @@....@...@...@@ ......@...@.@...
         @@.@@..@@.....@@ ...@@..@@...@...
         @@....@.......@@ ......@...@@....
         @@.@@.......@@@@ ...@@...@@......
         @@........@@@@@. ......@@........
         @@......@@@@@..@ ....@@.........@
         @@....@@@@@..@@. ...@.........@@.
         @@..@@@@@..@@... ...........@@.@@
         @@@@@@@..@@..... .........@@.@@..
         @@@@@..@@....... .......@@.@@....
         @@@..@@......... .....@@.@@......
         @..@@........... ...@@.@@........
         .@@............. .@@.@@..........
         @............... @.@@............
         ................ @@..............

img_moonbase_wall_1:
	7A90 00 00 0F 00 00 00 36 30 00 00 F8 F9 03 03 E0 E7
	7AA0 0D 01 80 9E 1E 00 00 58 38 01 03 D0 60 07 0F 80
	7AB0 80 1E 38 00 00 58 F6 00 03 D0 AF 00 00 80 E7 00
	7AC0 17 00 22 00 49 00 D1 00 12 00 6B 00 48 00 25 00
	7AD0 01 00 6B 00 00 00 DD 00 01 00 CF 00 03 00 36 00
	7AE0 0E 00 DF 00 F4 00 FE 00 DA 00 E8 01 DB 00 60 06
	7AF0 ED 00 81 19 FE 00 07 67 B8 01 07 B7 E0 06 43 5B
	7B00 81 19 E0 EC 07 67 F0 F7 07 B7 C0 CE 43 5B 01 38
	7B10 E0 EC 07 E0 F0 F7 1F 80 C0 CE 73 00 01 38 C3 08
	7B20 07 E0 03 08 1C 80 23 28 71 01 83 88 C2 02 23 28
	7B30 D9 19 83 88 C2 02 23 28 D9 19 83 88 C2 02 03 30
	7B40 D8 18 0F C0 C0 03 3E 00 C0 0C F9 01 C3 10 E6 06
	7B50 CF 00 98 1B FE 00 60 6C F9 01 80 B0 E6 06 00 C0
	7B60 98 1B 00 00 60 6C 00 00 80 B0 00 00 00 C0 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ............@@@@ ................
         ..........@@.@@. ..........@@....
         ........@@@@@... ........@@@@@..@
         ......@@@@@..... ......@@@@@..@@@
         ....@@.@@....... .......@@..@@@@.
         ...@@@@......... .........@.@@...
         ..@@@.........@@ .......@@@.@....
         .@@.........@@@@ .....@@@@.......
         @.........@@@... ...@@@@.........
         ........@@@@.@@. .@.@@...........
         ......@@@.@.@@@@ @@.@............
         ........@@@..@@@ @...............
         ...@.@@@..@...@. ................
         .@..@..@@@.@...@ ................
         ...@..@..@@.@.@@ ................
         .@..@.....@..@.@ ................
         .......@.@@.@.@@ ................
         ........@@.@@@.@ ................
         .......@@@..@@@@ ................
         ......@@..@@.@@. ................
         ....@@@.@@.@@@@@ ................
         @@@@.@..@@@@@@@. ................
         @@.@@.@.@@@.@... ...............@
         @@.@@.@@.@@..... .............@@.
         @@@.@@.@@......@ ...........@@..@
         @@@@@@@......@@@ .........@@..@@@
         @.@@@........@@@ .......@@.@@.@@@
         @@@......@....@@ .....@@..@.@@.@@
         @......@@@@..... ...@@..@@@@.@@..
         .....@@@@@@@.... .@@..@@@@@@@.@@@
         .....@@@@@...... @.@@.@@@@@..@@@.
         .@....@@.......@ .@.@@.@@..@@@...
         @@@..........@@@ @@@.@@..@@@.....
         @@@@.......@@@@@ @@@@.@@@@.......
         @@.......@@@..@@ @@..@@@.........
         .......@@@....@@ ..@@@.......@...
         .....@@@......@@ @@@.........@...
         ...@@@....@...@@ @.........@.@...
         .@@@...@@.....@@ .......@@...@...
         @@....@...@...@@ ......@...@.@...
         @@.@@..@@.....@@ ...@@..@@...@...
         @@....@...@...@@ ......@...@.@...
         @@.@@..@@.....@@ ...@@..@@...@...
         @@....@.......@@ ......@...@@....
         @@.@@.......@@@@ ...@@...@@......
         @@........@@@@@. ......@@........
         @@......@@@@@..@ ....@@.........@
         @@....@@@@@..@@. ...@.........@@.
         @@..@@@@@..@@... ...........@@.@@
         @@@@@@@..@@..... .........@@.@@..
         @@@@@..@@....... .......@@.@@....
         @@@..@@......... .....@@.@@......
         @..@@........... ...@@.@@........
         .@@............. .@@.@@..........
         @............... @.@@............
         ................ @@..............

img_moonbase_wall_2:
	7B70 00 00 0F 00 00 00 36 30 00 00 F8 F9 03 03 E0 E7
	7B80 0D 01 80 9E 1E 00 00 58 38 01 03 D0 60 07 05 80
	7B90 80 1E 02 00 00 58 00 00 02 D0 01 00 0F 80 06 00
	7BA0 36 00 DB 00 FD 00 BF 00 8F 00 F6 00 77 00 FD 00
	7BB0 FA 00 E0 00 FB 00 D8 00 67 00 D1 00 47 00 40 00
	7BC0 8D 00 E2 00 FF 00 FE 00 73 00 F8 01 ED 00 60 06
	7BD0 DE 00 81 19 D8 00 07 67 E0 01 07 B7 E0 06 43 5B
	7BE0 81 19 E0 EC 07 67 F0 F7 07 B7 C0 CE 43 5B 01 38
	7BF0 E0 EC 07 E0 F0 F7 1F 80 C0 CE 73 00 01 38 C3 08
	7C00 07 E0 03 08 1C 80 23 28 71 01 83 88 C2 02 23 28
	7C10 D9 19 83 88 C2 02 23 28 D9 19 83 88 C2 02 03 30
	7C20 D8 18 0F C0 C0 03 3E 00 C0 0C F9 01 C3 10 E6 06
	7C30 CF 00 98 1B FE 00 60 6C F9 01 80 B0 E6 06 00 C0
	7C40 98 1B 00 00 60 6C 00 00 80 B0 00 00 00 C0 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ............@@@@ ................
         ..........@@.@@. ..........@@....
         ........@@@@@... ........@@@@@..@
         ......@@@@@..... ......@@@@@..@@@
         ....@@.@@....... .......@@..@@@@.
         ...@@@@......... .........@.@@...
         ..@@@.........@@ .......@@@.@....
         .@@..........@.@ .....@@@@.......
         @.............@. ...@@@@.........
         ................ .@.@@...........
         ......@........@ @@.@............
         ....@@@@.....@@. @...............
         ..@@.@@.@@.@@.@@ ................
         @@@@@@.@@.@@@@@@ ................
         @...@@@@@@@@.@@. ................
         .@@@.@@@@@@@@@.@ ................
         @@@@@.@.@@@..... ................
         @@@@@.@@@@.@@... ................
         .@@..@@@@@.@...@ ................
         .@...@@@.@...... ................
         @...@@.@@@@...@. ................
         @@@@@@@@@@@@@@@. ................
         .@@@..@@@@@@@... ...............@
         @@@.@@.@.@@..... .............@@.
         @@.@@@@.@......@ ...........@@..@
         @@.@@........@@@ .........@@..@@@
         @@@..........@@@ .......@@.@@.@@@
         @@@......@....@@ .....@@..@.@@.@@
         @......@@@@..... ...@@..@@@@.@@..
         .....@@@@@@@.... .@@..@@@@@@@.@@@
         .....@@@@@...... @.@@.@@@@@..@@@.
         .@....@@.......@ .@.@@.@@..@@@...
         @@@..........@@@ @@@.@@..@@@.....
         @@@@.......@@@@@ @@@@.@@@@.......
         @@.......@@@..@@ @@..@@@.........
         .......@@@....@@ ..@@@.......@...
         .....@@@......@@ @@@.........@...
         ...@@@....@...@@ @.........@.@...
         .@@@...@@.....@@ .......@@...@...
         @@....@...@...@@ ......@...@.@...
         @@.@@..@@.....@@ ...@@..@@...@...
         @@....@...@...@@ ......@...@.@...
         @@.@@..@@.....@@ ...@@..@@...@...
         @@....@.......@@ ......@...@@....
         @@.@@.......@@@@ ...@@...@@......
         @@........@@@@@. ......@@........
         @@......@@@@@..@ ....@@.........@
         @@....@@@@@..@@. ...@.........@@.
         @@..@@@@@..@@... ...........@@.@@
         @@@@@@@..@@..... .........@@.@@..
         @@@@@..@@....... .......@@.@@....
         @@@..@@......... .....@@.@@......
         @..@@........... ...@@.@@........
         .@@............. .@@.@@..........
         @............... @.@@............
         ................ @@..............

img_moonbase_wall_3:
	7C50 00 00 0F 00 00 00 36 30 00 00 F8 F9 03 03 E0 E7
	7C60 0D 01 80 9E 1E 00 00 58 38 01 00 D0 60 07 08 80
	7C70 80 1E 1C 00 00 58 0E 60 00 D1 06 B0 0E 80 06 D0
	7C80 07 20 06 50 03 58 06 50 03 48 06 50 13 50 06 50
	7C90 1B 58 06 50 1B 58 06 50 1B 58 06 50 1B 58 06 50
	7CA0 0B 68 06 50 03 70 06 50 03 58 06 50 03 48 02 50
	7CB0 13 50 06 40 1B 58 06 00 1A 58 16 10 1A 58 E6 E0
	7CC0 1A 58 16 10 0A E8 E6 E0 02 B0 16 10 42 58 E2 E0
	7CD0 E2 E8 0E 00 F2 F0 06 30 C2 C8 06 D0 03 38 06 50
	7CE0 03 E0 06 50 1B 80 06 50 73 00 06 50 C3 00 06 50
	7CF0 DB 18 06 50 C3 00 06 50 DB 18 06 50 C3 00 06 50
	7D00 DB 18 06 50 C3 00 04 50 C3 08 01 51 C3 10 06 46
	7D10 CB 00 18 1B F6 00 60 6C F1 01 80 B0 E6 06 00 C0
	7D20 98 1B 00 00 60 6C 00 00 80 B0 00 00 00 C0 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ............@@@@ ................
         ..........@@.@@. ..........@@....
         ........@@@@@... ........@@@@@..@
         ......@@@@@..... ......@@@@@..@@@
         ....@@.@@....... .......@@..@@@@.
         ...@@@@......... .........@.@@...
         ..@@@........... .......@@@.@....
         .@@.........@... .....@@@@.......
         @..........@@@.. ...@@@@.........
         ............@@@. .@.@@....@@.....
         .............@@. @@.@...@@.@@....
         ....@@@......@@. @.......@@.@....
         .....@@@.....@@. ..@......@.@....
         ......@@.....@@. .@.@@....@.@....
         ......@@.....@@. .@..@....@.@....
         ...@..@@.....@@. .@.@.....@.@....
         ...@@.@@.....@@. .@.@@....@.@....
         ...@@.@@.....@@. .@.@@....@.@....
         ...@@.@@.....@@. .@.@@....@.@....
         ...@@.@@.....@@. .@.@@....@.@....
         ....@.@@.....@@. .@@.@....@.@....
         ......@@.....@@. .@@@.....@.@....
         ......@@.....@@. .@.@@....@.@....
         ......@@......@. .@..@....@.@....
         ...@..@@.....@@. .@.@.....@......
         ...@@.@@.....@@. .@.@@...........
         ...@@.@....@.@@. .@.@@......@....
         ...@@.@.@@@..@@. .@.@@...@@@.....
         ...@@.@....@.@@. .@.@@......@....
         ....@.@.@@@..@@. @@@.@...@@@.....
         ......@....@.@@. @.@@.......@....
         .@....@.@@@...@. .@.@@...@@@.....
         @@@...@.....@@@. @@@.@...........
         @@@@..@......@@. @@@@......@@....
         @@....@......@@. @@..@...@@.@....
         ......@@.....@@. ..@@@....@.@....
         ......@@.....@@. @@@......@.@....
         ...@@.@@.....@@. @........@.@....
         .@@@..@@.....@@. .........@.@....
         @@....@@.....@@. .........@.@....
         @@.@@.@@.....@@. ...@@....@.@....
         @@....@@.....@@. .........@.@....
         @@.@@.@@.....@@. ...@@....@.@....
         @@....@@.....@@. .........@.@....
         @@.@@.@@.....@@. ...@@....@.@....
         @@....@@.....@.. .........@.@....
         @@....@@.......@ ....@....@.@...@
         @@....@@.....@@. ...@.....@...@@.
         @@..@.@@...@@... ...........@@.@@
         @@@@.@@..@@..... .........@@.@@..
         @@@@...@@....... .......@@.@@....
         @@@..@@......... .....@@.@@......
         @..@@........... ...@@.@@........
         .@@............. .@@.@@..........
         @............... @.@@............
         ................ @@..............

img_bookworld_walls:
img_bookworld_wall_0:
	; 4 bytes * 56 : interlaced : wall1 + maskwall1 + wall2 + maskwall2 (each are 1byte wide*56)
	7D30 00 00 03 00 00 00 0C 00 00 00 38 01 00 00 E0 05
	7D40 03 00 80 15 0E 00 00 59 38 01 00 DD 60 07 00 04
	7D50 80 14 00 01 00 30 00 01 07 B0 00 01 0B A0 80 01
	7D60 0C A0 40 01 1E 80 C0 01 1F 80 D0 00 27 00 98 01
	7D70 08 88 48 41 31 81 18 01 3C 80 70 01 0F 80 C0 01
	7D80 20 A0 00 01 19 99 A0 A0 1E 1E 08 01 2D 8D 94 81
	7D90 50 00 0C 41 28 03 3C 81 74 00 78 01 7F 00 B8 81
	7DA0 5F 00 98 00 5E 00 70 05 4D 00 A0 85 0F 00 98 19
	7DB0 64 00 2C 2D 43 1B 0C 4D 06 B6 48 E9 06 96 00 40
	7DC0 07 07 B0 81 32 82 78 01 38 A0 D8 01 3E 80 3C 01
	7DD0 3F 90 7C 01 1F 80 BC 01 0F 84 B8 00 0F 00 D0 01
	7DE0 07 82 C0 01 07 80 D0 01 07 82 C0 01 07 80 D8 01
	7DF0 13 90 B8 01 2C A0 00 00 13 10 40 00 07 80 E0 00
	7E00 01 80 E0 00 00 80 00 00 00 80 00 00 00 80 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ..............@@ ................
         ............@@.. ................
         ..........@@@... ...............@
         ........@@@..... .............@.@
         ......@@@....... ...........@.@.@
         ....@@@......... .........@.@@..@
         ..@@@........... .......@@@.@@@.@
         .@@............. .....@@@.....@..
         @............... ...@.@.........@
         ................ ..@@...........@
         .....@@@........ @.@@...........@
         ....@.@@@....... @.@............@
         ....@@...@...... @.@............@
         ...@@@@.@@...... @..............@
         ...@@@@@@@.@.... @...............
         ..@..@@@@..@@... ...............@
         ....@....@..@... @...@....@.....@
         ..@@...@...@@... @......@.......@
         ..@@@@...@@@.... @..............@
         ....@@@@@@...... @..............@
         ..@............. @.@............@
         ...@@..@@.@..... @..@@..@@.@.....
         ...@@@@.....@... ...@@@@........@
         ..@.@@.@@..@.@.. @...@@.@@......@
         .@.@........@@.. .........@.....@
         ..@.@.....@@@@.. ......@@@......@
         .@@@.@...@@@@... ...............@
         .@@@@@@@@.@@@... ........@......@
         .@.@@@@@@..@@... ................
         .@.@@@@..@@@.... .............@.@
         .@..@@.@@.@..... ........@....@.@
         ....@@@@@..@@... ...........@@..@
         .@@..@....@.@@.. ..........@.@@.@
         .@....@@....@@.. ...@@.@@.@..@@.@
         .....@@..@..@... @.@@.@@.@@@.@..@
         .....@@......... @..@.@@..@......
         .....@@@@.@@.... .....@@@@......@
         ..@@..@..@@@@... @.....@........@
         ..@@@...@@.@@... @.@............@
         ..@@@@@...@@@@.. @..............@
         ..@@@@@@.@@@@@.. @..@...........@
         ...@@@@@@.@@@@.. @..............@
         ....@@@@@.@@@... @....@..........
         ....@@@@@@.@.... ...............@
         .....@@@@@...... @.....@........@
         .....@@@@@.@.... @..............@
         .....@@@@@...... @.....@........@
         .....@@@@@.@@... @..............@
         ...@..@@@.@@@... @..@...........@
         ..@.@@.......... @.@.............
         ...@..@@.@...... ...@............
         .....@@@@@@..... @...............
         .......@@@@..... @...............
         ................ @...............
         ................ @...............
         ................ @...............

img_bookworld_wall_1:
	7E10 00 00 E3 E0 00 00 30 34 08 08 30 37 11 10 B0 37
	7E20 37 30 C0 0B 33 30 C0 1D 35 34 C0 11 1D 1C 80 0C
	7E30 02 00 00 33 00 3C 00 C7 00 B3 10 07 00 8C A0 07
	7E40 00 B0 00 07 08 80 A0 03 05 80 50 04 08 00 A0 07
	7E50 04 80 10 07 01 81 C0 C7 07 87 E0 E7 0F 8F F0 F3
	7E60 37 B7 F8 F9 3B BB FC FC 3D 3D FE FE 3E BE F0 F1
	7E70 3F BF 4E 4E 3F BF B0 B1 3C BC 40 4D 3B BB 00 32
	7E80 24 A4 00 4C 10 13 00 33 00 8C 00 C3 00 B3 10 01
	7E90 00 8C 68 61 01 B0 18 01 05 80 F8 01 1A 98 F0 00
	7EA0 06 00 08 09 3E 80 F0 F1 3C 80 08 01 02 82 F8 01
	7EB0 3C BC F8 01 02 80 F8 01 3E 80 F0 00 3E 00 08 09
	7EC0 3E 80 F0 F1 3C 80 08 01 02 82 F8 01 3C BC F0 05
	7ED0 02 80 00 03 3E 80 00 CC 3C 01 00 30 00 80 00 C0
	7EE0 00 B3 00 00 00 8C 00 00 00 B0 00 00 00 C0 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ........@@@...@@ ........@@@.....
         ..........@@.... ..........@@.@..
         ....@.....@@.... ....@.....@@.@@@
         ...@...@@.@@.... ...@......@@.@@@
         ..@@.@@@@@...... ..@@........@.@@
         ..@@..@@@@...... ..@@.......@@@.@
         ..@@.@.@@@...... ..@@.@.....@...@
         ...@@@.@@....... ...@@@......@@..
         ......@......... ..........@@..@@
         ................ ..@@@@..@@...@@@
         ...........@.... @.@@..@@.....@@@
         ........@.@..... @...@@.......@@@
         ................ @.@@.........@@@
         ....@...@.@..... @.............@@
         .....@.@.@.@.... @............@..
         ....@...@.@..... .............@@@
         .....@.....@.... @............@@@
         .......@@@...... @......@@@...@@@
         .....@@@@@@..... @....@@@@@@..@@@
         ....@@@@@@@@.... @...@@@@@@@@..@@
         ..@@.@@@@@@@@... @.@@.@@@@@@@@..@
         ..@@@.@@@@@@@@.. @.@@@.@@@@@@@@..
         ..@@@@.@@@@@@@@. ..@@@@.@@@@@@@@.
         ..@@@@@.@@@@.... @.@@@@@.@@@@...@
         ..@@@@@@.@..@@@. @.@@@@@@.@..@@@.
         ..@@@@@@@.@@.... @.@@@@@@@.@@...@
         ..@@@@...@...... @.@@@@...@..@@.@
         ..@@@.@@........ @.@@@.@@..@@..@.
         ..@..@.......... @.@..@...@..@@..
         ...@............ ...@..@@..@@..@@
         ................ @...@@..@@....@@
         ...........@.... @.@@..@@.......@
         .........@@.@... @...@@...@@....@
         .......@...@@... @.@@...........@
         .....@.@@@@@@... @..............@
         ...@@.@.@@@@.... @..@@...........
         .....@@.....@... ............@..@
         ..@@@@@.@@@@.... @.......@@@@...@
         ..@@@@......@... @..............@
         ......@.@@@@@... @.....@........@
         ..@@@@..@@@@@... @.@@@@.........@
         ......@.@@@@@... @..............@
         ..@@@@@.@@@@.... @...............
         ..@@@@@.....@... ............@..@
         ..@@@@@.@@@@.... @.......@@@@...@
         ..@@@@......@... @..............@
         ......@.@@@@@... @.....@........@
         ..@@@@..@@@@.... @.@@@@.......@.@
         ......@......... @.............@@
         ..@@@@@......... @.......@@..@@..
         ..@@@@.......... .......@..@@....
         ................ @.......@@......
         ................ @.@@..@@........
         ................ @...@@..........
         ................ @.@@............
         ................ @@..............

img_safari_walls:
img_safari_wall_0:
	; 4 bytes * 56 : interlaced : wall1 + maskwall1 + wall2 + maskwall2 (each are 1byte wide*56)
	7EF0 00 00 00 10 01 00 80 18 01 00 80 38 01 00 80 1C
	7F00 02 12 40 5C 07 17 C0 CE 07 37 A0 AE 0B 2B E0 E0
	7F10 09 69 B2 B0 09 69 D2 D0 11 D1 CA C8 18 58 DA D8
	7F20 9C 1C E8 E8 9E 1E D4 D4 AE 2E E4 E4 AF 2F C4 C4
	7F30 A7 27 EC EC 23 23 F6 F6 A1 21 EA EA B1 31 F6 F6
	7F40 7C 7C EA EA 7F 7F F6 F6 7F 7F EA EA 5F 5F F2 F2
	7F50 47 47 E2 E2 43 43 F6 F6 40 40 EA EA 40 40 76 76
	7F60 47 47 EA EA 5F 5F F6 F6 7F 7F E2 E2 7C 7C 72 72
	7F70 50 50 EA EA 41 41 F6 F6 41 41 EA EA 47 47 F6 F6
	7F80 47 47 EA EA 5F 5F F4 F4 5F 5F EC EC 7E 7E E4 E4
	7F90 7C 7C E4 E4 B8 38 D8 D8 B1 31 EA E8 A1 21 DA D8
	7FA0 B3 33 EA E8 93 13 D2 D0 93 13 F2 F0 9B 1B D2 D0
	7FB0 AF 0F A4 A0 AF 0F E6 E0 A7 07 C8 C0 AA 02 40 40
	7FC0 54 01 00 80 D4 01 00 80 78 00 00 00 00 00 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ................ ...........@....
         .......@@....... ...........@@...
         .......@@....... ..........@@@...
         .......@@....... ...........@@@..
         ......@..@...... ...@..@..@.@@@..
         .....@@@@@...... ...@.@@@@@..@@@.
         .....@@@@.@..... ..@@.@@@@.@.@@@.
         ....@.@@@@@..... ..@.@.@@@@@.....
         ....@..@@.@@..@. .@@.@..@@.@@....
         ....@..@@@.@..@. .@@.@..@@@.@....
         ...@...@@@..@.@. @@.@...@@@..@...
         ...@@...@@.@@.@. .@.@@...@@.@@...
         @..@@@..@@@.@... ...@@@..@@@.@...
         @..@@@@.@@.@.@.. ...@@@@.@@.@.@..
         @.@.@@@.@@@..@.. ..@.@@@.@@@..@..
         @.@.@@@@@@...@.. ..@.@@@@@@...@..
         @.@..@@@@@@.@@.. ..@..@@@@@@.@@..
         ..@...@@@@@@.@@. ..@...@@@@@@.@@.
         @.@....@@@@.@.@. ..@....@@@@.@.@.
         @.@@...@@@@@.@@. ..@@...@@@@@.@@.
         .@@@@@..@@@.@.@. .@@@@@..@@@.@.@.
         .@@@@@@@@@@@.@@. .@@@@@@@@@@@.@@.
         .@@@@@@@@@@.@.@. .@@@@@@@@@@.@.@.
         .@.@@@@@@@@@..@. .@.@@@@@@@@@..@.
         .@...@@@@@@...@. .@...@@@@@@...@.
         .@....@@@@@@.@@. .@....@@@@@@.@@.
         .@......@@@.@.@. .@......@@@.@.@.
         .@.......@@@.@@. .@.......@@@.@@.
         .@...@@@@@@.@.@. .@...@@@@@@.@.@.
         .@.@@@@@@@@@.@@. .@.@@@@@@@@@.@@.
         .@@@@@@@@@@...@. .@@@@@@@@@@...@.
         .@@@@@...@@@..@. .@@@@@...@@@..@.
         .@.@....@@@.@.@. .@.@....@@@.@.@.
         .@.....@@@@@.@@. .@.....@@@@@.@@.
         .@.....@@@@.@.@. .@.....@@@@.@.@.
         .@...@@@@@@@.@@. .@...@@@@@@@.@@.
         .@...@@@@@@.@.@. .@...@@@@@@.@.@.
         .@.@@@@@@@@@.@.. .@.@@@@@@@@@.@..
         .@.@@@@@@@@.@@.. .@.@@@@@@@@.@@..
         .@@@@@@.@@@..@.. .@@@@@@.@@@..@..
         .@@@@@..@@@..@.. .@@@@@..@@@..@..
         @.@@@...@@.@@... ..@@@...@@.@@...
         @.@@...@@@@.@.@. ..@@...@@@@.@...
         @.@....@@@.@@.@. ..@....@@@.@@...
         @.@@..@@@@@.@.@. ..@@..@@@@@.@...
         @..@..@@@@.@..@. ...@..@@@@.@....
         @..@..@@@@@@..@. ...@..@@@@@@....
         @..@@.@@@@.@..@. ...@@.@@@@.@....
         @.@.@@@@@.@..@.. ....@@@@@.@.....
         @.@.@@@@@@@..@@. ....@@@@@@@.....
         @.@..@@@@@..@... .....@@@@@......
         @.@.@.@..@...... ......@..@......
         .@.@.@.......... .......@@.......
         @@.@.@.......... .......@@.......
         .@@@@........... ................
         ................ ................

img_safari_wall_1:
	7FD0 00 00 00 10 00 00 00 38 00 00 00 38 00 00 00 3C
	7FE0 00 10 00 5C 00 18 00 7E 00 38 00 BE 00 3C 00 78
	7FF0 00 5C 82 00 00 7E AA 00 00 BE AA 00 00 78 DA 00
	8000 82 00 AE 00 AA 00 78 00 AA 00 86 00 DA 00 FA 00
	8010 AE 00 AA 00 78 00 D6 00 86 00 56 00 FC 00 AA 00
	8020 AA 00 AA 00 AA 00 AA 00 B6 00 D6 00 AA 00 D4 00
	8030 AA 00 AA 00 56 00 AA 00 DA 00 EA 00 AA 00 5A 00
	8040 B4 00 AA 00 B6 00 AA 00 AA 00 AA 00 AA 00 DC 00
	8050 AA 00 AA 00 B4 00 AA 00 56 00 AE 00 6A 00 78 00
	8060 AA 00 86 00 AA 00 FA 00 AE 00 AA 00 78 00 AA 00
	8070 86 00 AA 00 FA 00 B4 00 AA 00 B6 00 AA 00 AA 00
	8080 AA 00 AA 00 B4 00 AA 00 B6 00 AA 00 AA 00 AA 00
	8090 AA 00 54 00 AA 00 D6 00 AA 00 78 00 AA 00 00 00
	80A0 54 00 00 00 D6 00 00 00 78 00 00 00 00 00 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         ................ ...........@....
         ................ ..........@@@...
         ................ ..........@@@...
         ................ ..........@@@@..
         ................ ...@.....@.@@@..
         ................ ...@@....@@@@@@.
         ................ ..@@@...@.@@@@@.
         ................ ..@@@@...@@@@...
         ........@.....@. .@.@@@..........
         ........@.@.@.@. .@@@@@@.........
         ........@.@.@.@. @.@@@@@.........
         ........@@.@@.@. .@@@@...........
         @.....@.@.@.@@@. ................
         @.@.@.@..@@@@... ................
         @.@.@.@.@....@@. ................
         @@.@@.@.@@@@@.@. ................
         @.@.@@@.@.@.@.@. ................
         .@@@@...@@.@.@@. ................
         @....@@..@.@.@@. ................
         @@@@@@..@.@.@.@. ................
         @.@.@.@.@.@.@.@. ................
         @.@.@.@.@.@.@.@. ................
         @.@@.@@.@@.@.@@. ................
         @.@.@.@.@@.@.@.. ................
         @.@.@.@.@.@.@.@. ................
         .@.@.@@.@.@.@.@. ................
         @@.@@.@.@@@.@.@. ................
         @.@.@.@..@.@@.@. ................
         @.@@.@..@.@.@.@. ................
         @.@@.@@.@.@.@.@. ................
         @.@.@.@.@.@.@.@. ................
         @.@.@.@.@@.@@@.. ................
         @.@.@.@.@.@.@.@. ................
         @.@@.@..@.@.@.@. ................
         .@.@.@@.@.@.@@@. ................
         .@@.@.@..@@@@... ................
         @.@.@.@.@....@@. ................
         @.@.@.@.@@@@@.@. ................
         @.@.@@@.@.@.@.@. ................
         .@@@@...@.@.@.@. ................
         @....@@.@.@.@.@. ................
         @@@@@.@.@.@@.@.. ................
         @.@.@.@.@.@@.@@. ................
         @.@.@.@.@.@.@.@. ................
         @.@.@.@.@.@.@.@. ................
         @.@@.@..@.@.@.@. ................
         @.@@.@@.@.@.@.@. ................
         @.@.@.@.@.@.@.@. ................
         @.@.@.@..@.@.@.. ................
         @.@.@.@.@@.@.@@. ................
         @.@.@.@..@@@@... ................
         @.@.@.@......... ................
         .@.@.@.......... ................
         @@.@.@@......... ................
         .@@@@........... ................
         ................ ................

img_safari_wall_2:
	80B0 00 00 00 10 00 00 00 18 00 00 00 38 00 00 00 3C
	80C0 00 10 00 5C 00 18 00 7E 00 38 00 BE 00 3C 00 78
	80D0 00 5C 82 00 00 7E AA 00 00 BE AA 00 00 78 DA 00
	80E0 82 00 AE 00 AA 00 F8 00 AA 00 80 04 DA 00 00 7C
	80F0 AE 00 00 78 78 00 00 38 00 84 00 30 00 7C 00 10
	8100 00 78 00 00 00 38 00 00 00 30 00 00 00 10 00 00
	8110 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	8120 00 00 00 10 00 00 00 18 00 00 00 38 00 00 00 3C
	8130 00 10 00 5C 00 18 00 7E 00 38 00 BE 00 3C 00 78
	8140 00 5C 86 00 00 7E FA 00 00 BE AA 00 00 78 AA 00
	8150 86 00 AA 00 FA 00 B4 00 AA 00 B6 00 AA 00 AA 00
	8160 AA 00 AA 00 B4 00 AA 00 B6 00 AA 00 AA 00 AA 00
	8170 AA 00 54 00 AA 00 D6 00 AA 00 78 00 AA 00 00 00
	8180 54 00 00 00 D6 00 00 00 78 00 00 00 00 00 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:
         ................ ...........@....
         ................ ...........@@...
         ................ ..........@@@...
         ................ ..........@@@@..
         ................ ...@.....@.@@@..
         ................ ...@@....@@@@@@.
         ................ ..@@@...@.@@@@@.
         ................ ..@@@@...@@@@...
         ........@.....@. .@.@@@..........
         ........@.@.@.@. .@@@@@@.........
         ........@.@.@.@. @.@@@@@.........
         ........@@.@@.@. .@@@@...........
         @.....@.@.@.@@@. ................
         @.@.@.@.@@@@@... ................
         @.@.@.@.@....... .............@..
         @@.@@.@......... .........@@@@@..
         @.@.@@@......... .........@@@@...
         .@@@@........... ..........@@@...
         ................ @....@....@@....
         ................ .@@@@@.....@....
         ................ .@@@@...........
         ................ ..@@@...........
         ................ ..@@............
         ................ ...@............
         ................ ................
         ................ ................
         ................ ................
         ................ ................
         ................ ...........@....
         ................ ...........@@...
         ................ ..........@@@...
         ................ ..........@@@@..
         ................ ...@.....@.@@@..
         ................ ...@@....@@@@@@.
         ................ ..@@@...@.@@@@@.
         ................ ..@@@@...@@@@...
         ........@....@@. .@.@@@..........
         ........@@@@@.@. .@@@@@@.........
         ........@.@.@.@. @.@@@@@.........
         ........@.@.@.@. .@@@@...........
         @....@@.@.@.@.@. ................
         @@@@@.@.@.@@.@.. ................
         @.@.@.@.@.@@.@@. ................
         @.@.@.@.@.@.@.@. ................
         @.@.@.@.@.@.@.@. ................
         @.@@.@..@.@.@.@. ................
         @.@@.@@.@.@.@.@. ................
         @.@.@.@.@.@.@.@. ................
         @.@.@.@..@.@.@.. ................
         @.@.@.@.@@.@.@@. ................
         @.@.@.@..@@@@... ................
         @.@.@.@......... ................
         .@.@.@.......... ................
         @@.@.@@......... ................
         .@@@@........... ................
         ................ ................

img_prison_walls:
img_prison_wall_0:
	; 4 bytes * 56 : interlaced : wall1 + maskwall1 + wall2 + maskwall2 (each are 1byte wide*56)
	; wall1
	8190 01 01 83 83 01 01 0F 4F 00 03 3C BC 00 01 30 B3
	81A0 02 02 40 4C 0F 0F 00 31 3C 3C 08 C1 F0 F3 10 01
	81B0 C0 CC 28 81 00 31 10 81 08 C1 28 81 10 01 10 81
	81C0 28 81 28 81 10 81 10 81
	; mask wall1
	81C8 28 81 28 81 10 81 10 81
	81D0 28 81 28 81 10 81 10 81 28 81 28 81 10 81 10 81
	81E0 28 81 20 81 10 81 0C 81 28 81 3C 81 10 81 0E 80
	81F0 20 81 33 B0 0C 81 0C 8C 34 81 33 83 3E 80 7D 01
	; wall2
	8200 3F 80 FD 01 3F 80 F1 01 3F 80 CD 01 7F 00 3D 01
	8210 EC 00 FD 01 F3 00 FD 01 4F 00 FD 01 3F 00 FD 01
	8220 7F 00 F3 03 7F 00 CC 0C 7F 00 33 30 3C 00 CF C0
	8230 73 03 3F 00 4D 0D 7F 00
	; mask wall2
	8238 31 31 7F 00 CD C1 6E 00
	8240 3D 01 79 01 FD 01 67 07 FD 01 10 10 FC 00 70 73
	8250 F9 01 00 09 E7 07 00 3A 90 10 00 90 70 73 00 A0
	8260 00 09 00 00 00 3A 00 00 00 90 00 00 00 A0 00 00
	; displaying the images and masks as "wall1+wall2 mask1+mask2"
	; so it is easier to see, we have the following results:

         .......@@.....@@ .......@@.....@@
         .......@....@@@@ .......@.@..@@@@
         ..........@@@@.. ......@@@.@@@@..
         ..........@@.... .......@@.@@..@@
         ......@..@...... ......@..@..@@..
         ....@@@@........ ....@@@@..@@...@
         ..@@@@......@... ..@@@@..@@.....@
         @@@@.......@.... @@@@..@@.......@
         @@........@.@... @@..@@..@......@
         ...........@.... ..@@...@@......@
         ....@.....@.@... @@.....@@......@
         ...@.......@.... .......@@......@
         ..@.@.....@.@... @......@@......@
         ...@.......@.... @......@@......@
         ..@.@.....@.@... @......@@......@
         ...@.......@.... @......@@......@
         ..@.@.....@.@... @......@@......@
         ...@.......@.... @......@@......@
         ..@.@.....@.@... @......@@......@
         ...@.......@.... @......@@......@
         ..@.@.....@..... @......@@......@
         ...@........@@.. @......@@......@
         ..@.@.....@@@@.. @......@@......@
         ...@........@@@. @......@@.......
         ..@.......@@..@@ @......@@.@@....
         ....@@......@@.. @......@@...@@..
         ..@@.@....@@..@@ @......@@.....@@
         ..@@@@@..@@@@@.@ @..............@
         ..@@@@@@@@@@@@.@ @..............@
         ..@@@@@@@@@@...@ @..............@
         ..@@@@@@@@..@@.@ @..............@
         .@@@@@@@..@@@@.@ ...............@
         @@@.@@..@@@@@@.@ ...............@
         @@@@..@@@@@@@@.@ ...............@
         .@..@@@@@@@@@@.@ ...............@
         ..@@@@@@@@@@@@.@ ...............@
         .@@@@@@@@@@@..@@ ..............@@
         .@@@@@@@@@..@@.. ............@@..
         .@@@@@@@..@@..@@ ..........@@....
         ..@@@@..@@..@@@@ ........@@......
         .@@@..@@..@@@@@@ ......@@........
         .@..@@.@.@@@@@@@ ....@@.@........
         ..@@...@.@@@@@@@ ..@@...@........
         @@..@@.@.@@.@@@. @@.....@........
         ..@@@@.@.@@@@..@ .......@.......@
         @@@@@@.@.@@..@@@ .......@.....@@@
         @@@@@@.@...@.... .......@...@....
         @@@@@@...@@@.... .........@@@..@@
         @@@@@..@........ .......@....@..@
         @@@..@@@........ .....@@@..@@@.@.
         @..@............ ...@....@..@....
         .@@@............ .@@@..@@@.@.....
         ................ ....@..@........
         ................ ..@@@.@.........
         ................ @..@............
         ................ @.@.............

;; -----------------------------------------------------------------------------------------------------------
img_3x56.bin: Doorways (Blacktooth, Prison, BookWorld, Market)
img_doorway_L_type_0:				;; SPR_DOORL:      EQU $00
	8270 00 00 CC 00 03 F3 00 0C CD 00 3F 3D 00 4C DE 00
	8280 F3 D9 01 ED E6 0D DD 9C 3A BE 6F 4B 79 8E 31 66
	8290 B8 1C 18 E4 7F 7B 9E 3C 1E 3F 0E 39 73 03 63 7B
	82A0 38 14 36 1E F3 8E 2E E7 DC 72 EC D8 2C ED B0 0A
	82B0 CE 60 62 D7 E0 78 DB C0 3E B3 C0 3F 2F 80 4F 1F
	82C0 80 73 5F 80 2C 53 00 0B 6B 00 62 7B 00 79 7B 00
	82D0 3E 7B 00 3F 6B 00 4F 53 00 73 5F 00 2C 5F 00 0B
	82E0 67 00 62 5F 00 79 5F 00 3E 53 00 3F 6B 00 4F 7B
	82F0 00 73 7B 00 2C 7B 00 0B 6B 00 62 53 00 79 5F 00
	8300 3E 5F 00 3F 67 00 4F 7B 00 63 7B 00 38 74 00 0E
	8310 70 00 03 40 00 00 00 00

	     ................@@..@@..
         ..............@@@@@@..@@
         ............@@..@@..@@.@
         ..........@@@@@@..@@@@.@
         .........@..@@..@@.@@@@.
         ........@@@@..@@@@.@@..@
         .......@@@@.@@.@@@@..@@.
         ....@@.@@@.@@@.@@..@@@..
         ..@@@.@.@.@@@@@..@@.@@@@
         .@..@.@@.@@@@..@@...@@@.
         ..@@...@.@@..@@.@.@@@...
         ...@@@.....@@...@@@..@..
         .@@@@@@@.@@@@.@@@..@@@@.
         ..@@@@.....@@@@...@@@@@@
         ....@@@...@@@..@.@@@..@@
         ......@@.@@...@@.@@@@.@@
         ..@@@......@.@....@@.@@.
         ...@@@@.@@@@..@@@...@@@.
         ..@.@@@.@@@..@@@@@.@@@..
         .@@@..@.@@@.@@..@@.@@...
         ..@.@@..@@@.@@.@@.@@....
         ....@.@.@@..@@@..@@.....
         .@@...@.@@.@.@@@@@@.....
         .@@@@...@@.@@.@@@@......
         ..@@@@@.@.@@..@@@@......
         ..@@@@@@..@.@@@@@.......
         .@..@@@@...@@@@@@.......
         .@@@..@@.@.@@@@@@.......
         ..@.@@...@.@..@@........
         ....@.@@.@@.@.@@........
         .@@...@..@@@@.@@........
         .@@@@..@.@@@@.@@........
         ..@@@@@..@@@@.@@........
         ..@@@@@@.@@.@.@@........
         .@..@@@@.@.@..@@........
         .@@@..@@.@.@@@@@........
         ..@.@@...@.@@@@@........
         ....@.@@.@@..@@@........
         .@@...@..@.@@@@@........
         .@@@@..@.@.@@@@@........
         ..@@@@@..@.@..@@........
         ..@@@@@@.@@.@.@@........
         .@..@@@@.@@@@.@@........
         .@@@..@@.@@@@.@@........
         ..@.@@...@@@@.@@........
         ....@.@@.@@.@.@@........
         .@@...@..@.@..@@........
         .@@@@..@.@.@@@@@........
         ..@@@@@..@.@@@@@........
         ..@@@@@@.@@..@@@........
         .@..@@@@.@@@@.@@........
         .@@...@@.@@@@.@@........
         ..@@@....@@@.@..........
         ....@@@..@@@............
         ......@@.@..............
         ........................

	8318 FF FC C0 FF F3 F3 FF C0
	8320 C1 FF 80 01 FF 40 C0 FC F3 C1 F1 E1 E6 CD C1 9C
	8330 B8 80 6F 48 01 8E B0 06 B8 9C 18 E4 7F 7B 9E BC
	8340 1E 3F CE 38 73 C3 60 7B B8 10 36 DE F3 8E 8E E7
	8350 DD 02 EC DB 00 ED B7 80 CE 6F 60 C7 EF 78 C3 DF
	8360 BE 83 DF BF 0F BF 0F 1F BF 03 1F BF 00 13 7F 80
	8370 03 7F 60 03 7F 78 03 7F BE 03 7F BF 03 7F 0F 13
	8380 7F 03 1F 7F 00 1F 7F 80 07 7F 60 1F 7F 78 1F 7F
	8390 BE 13 7F BF 03 7F 0F 03 7F 03 03 7F 00 03 7F 80
	83A0 03 7F 60 13 7F 78 1F 7F BE 1F 7F BF 07 7F 0F 03
	83B0 7F 03 03 7F 80 04 FF C0 03 FF F0 0F FF FC BF FF

         @@@@@@@@@@@@@@..@@......
         @@@@@@@@@@@@..@@@@@@..@@
         @@@@@@@@@@......@@.....@
         @@@@@@@@@..............@
         @@@@@@@@.@......@@......
         @@@@@@..@@@@..@@@@.....@
         @@@@...@@@@....@@@@..@@.
         @@..@@.@@@.....@@..@@@..
         @.@@@...@........@@.@@@@
         .@..@..........@@...@@@.
         @.@@.........@@.@.@@@...
         @..@@@.....@@...@@@..@..
         .@@@@@@@.@@@@.@@@..@@@@.
         @.@@@@.....@@@@...@@@@@@
         @@..@@@...@@@....@@@..@@
         @@....@@.@@......@@@@.@@
         @.@@@......@......@@.@@.
         @@.@@@@.@@@@..@@@...@@@.
         @...@@@.@@@..@@@@@.@@@.@
         ......@.@@@.@@..@@.@@.@@
         ........@@@.@@.@@.@@.@@@
         @.......@@..@@@..@@.@@@@
         .@@.....@@...@@@@@@.@@@@
         .@@@@...@@....@@@@.@@@@@
         @.@@@@@.@.....@@@@.@@@@@
         @.@@@@@@....@@@@@.@@@@@@
         ....@@@@...@@@@@@.@@@@@@
         ......@@...@@@@@@.@@@@@@
         ...........@..@@.@@@@@@@
         @.............@@.@@@@@@@
         .@@...........@@.@@@@@@@
         .@@@@.........@@.@@@@@@@
         @.@@@@@.......@@.@@@@@@@
         @.@@@@@@......@@.@@@@@@@
         ....@@@@...@..@@.@@@@@@@
         ......@@...@@@@@.@@@@@@@
         ...........@@@@@.@@@@@@@
         @............@@@.@@@@@@@
         .@@........@@@@@.@@@@@@@
         .@@@@......@@@@@.@@@@@@@
         @.@@@@@....@..@@.@@@@@@@
         @.@@@@@@......@@.@@@@@@@
         ....@@@@......@@.@@@@@@@
         ......@@......@@.@@@@@@@
         ..............@@.@@@@@@@
         @.............@@.@@@@@@@
         .@@........@..@@.@@@@@@@
         .@@@@......@@@@@.@@@@@@@
         @.@@@@@....@@@@@.@@@@@@@
         @.@@@@@@.....@@@.@@@@@@@
         ....@@@@......@@.@@@@@@@
         ......@@......@@.@@@@@@@
         @............@..@@@@@@@@
         @@............@@@@@@@@@@
         @@@@........@@@@@@@@@@@@
         @@@@@@..@.@@@@@@@@@@@@@@

img_doorway_R_type_0: 		; SPR_DOORR:      EQU $01
	83C0 00 00 00 00 03 C0 00 0C D0 00 3F 38 00 CC DC 03
	83D0 F3 D8 0C CD E4 33 3D 98 7C DE 70 F3 59 BC CF 66
	83E0 38 1F 9A E4 1E 63 9C 19 EE 7C 06 39 3C 1C 63 DC
	83F0 7F 9D CC FE 7E F4 00 E6 10 00 DE EC 00 DD F4 00
	8400 61 B6 00 7D B6 00 1E 76 00 27 EE 00 09 E6 00 62
	8410 FA 00 78 FA 00 3E 6A 00 3F 66 00 4F 6E 00 73 66
	8420 00 2C 6A 00 0B 6C 00 62 7C 00 79 7A 00 3E 7C 00
	8430 3F 6C 00 4F 6A 00 73 66 00 2C 6E 00 0B 66 00 62
	8440 6A 00 79 7A 00 3E 7A 00 3F 66 00 4F 6E 00 63 6E
	8450 00 38 6C 00 0E 70 00 03 40 00 00 00 00 00 00 00
	8460 00 00 00 00 00 00 00 00

         ........................
         ..............@@@@......
         ............@@..@@.@....
         ..........@@@@@@..@@@...
         ........@@..@@..@@.@@@..
         ......@@@@@@..@@@@.@@...
         ....@@..@@..@@.@@@@..@..
         ..@@..@@..@@@@.@@..@@...
         .@@@@@..@@.@@@@..@@@....
         @@@@..@@.@.@@..@@.@@@@..
         @@..@@@@.@@..@@...@@@...
         ...@@@@@@..@@.@.@@@..@..
         ...@@@@..@@...@@@..@@@..
         ...@@..@@@@.@@@..@@@@@..
         .....@@...@@@..@..@@@@..
         ...@@@...@@...@@@@.@@@..
         .@@@@@@@@..@@@.@@@..@@..
         @@@@@@@..@@@@@@.@@@@.@..
         ........@@@..@@....@....
         ........@@.@@@@.@@@.@@..
         ........@@.@@@.@@@@@.@..
         .........@@....@@.@@.@@.
         .........@@@@@.@@.@@.@@.
         ...........@@@@..@@@.@@.
         ..........@..@@@@@@.@@@.
         ............@..@@@@..@@.
         .........@@...@.@@@@@.@.
         .........@@@@...@@@@@.@.
         ..........@@@@@..@@.@.@.
         ..........@@@@@@.@@..@@.
         .........@..@@@@.@@.@@@.
         .........@@@..@@.@@..@@.
         ..........@.@@...@@.@.@.
         ............@.@@.@@.@@..
         .........@@...@..@@@@@..
         .........@@@@..@.@@@@.@.
         ..........@@@@@..@@@@@..
         ..........@@@@@@.@@.@@..
         .........@..@@@@.@@.@.@.
         .........@@@..@@.@@..@@.
         ..........@.@@...@@.@@@.
         ............@.@@.@@..@@.
         .........@@...@..@@.@.@.
         .........@@@@..@.@@@@.@.
         ..........@@@@@..@@@@.@.
         ..........@@@@@@.@@..@@.
         .........@..@@@@.@@.@@@.
         .........@@...@@.@@.@@@.
         ..........@@@....@@.@@..
         ............@@@..@@@....
         ..............@@.@......
         ........................
         ........................
         ........................
         ........................
         ........................

	8468 FF FC 3F FF F0 0F FF CC
	8470 17 FF 3F 3B FC 0C 1D F0 00 19 CC 0C 05 03 3C 1B
	8480 70 1E 71 F3 19 BD C1 06 39 01 1A E5 00 63 9D 01
	8490 EE 7D 06 38 3D 1C 60 1D 7F 9C 0D FE 7E 05 00 E6
	84A0 01 FE DE E1 FE DD F1 FF 61 B0 FF 7D B0 FF 1E 70
	84B0 FF 87 E0 FF 81 E0 FF 60 F8 FF 78 F8 FF BE 68 FF
	84C0 BF 60 FF 0F 60 FF 03 60 FF 80 68 FF 80 6C FF 60
	84D0 7C FF 78 78 FF BE 7C FF BF 6C FF 0F 68 FF 03 60
	84E0 FF 80 60 FF 80 60 FF 60 68 FF 78 78 FF BE 78 FF
	84F0 BF 60 FF 0F 60 FF 03 60 FF 80 61 FF C0 73 FF F0
	8500 4F FF FC BF FF FF FF FF FF FF FF FF FF FF FF FF

         @@@@@@@@@@@@@@....@@@@@@
         @@@@@@@@@@@@........@@@@
         @@@@@@@@@@..@@.....@.@@@
         @@@@@@@@..@@@@@@..@@@.@@
         @@@@@@......@@.....@@@.@
         @@@@...............@@..@
         @@..@@......@@.......@.@
         ......@@..@@@@.....@@.@@
         .@@@.......@@@@..@@@...@
         @@@@..@@...@@..@@.@@@@.@
         @@.....@.....@@...@@@..@
         .......@...@@.@.@@@..@.@
         .........@@...@@@..@@@.@
         .......@@@@.@@@..@@@@@.@
         .....@@...@@@.....@@@@.@
         ...@@@...@@........@@@.@
         .@@@@@@@@..@@@......@@.@
         @@@@@@@..@@@@@@......@.@
         ........@@@..@@........@
         @@@@@@@.@@.@@@@.@@@....@
         @@@@@@@.@@.@@@.@@@@@...@
         @@@@@@@@.@@....@@.@@....
         @@@@@@@@.@@@@@.@@.@@....
         @@@@@@@@...@@@@..@@@....
         @@@@@@@@@....@@@@@@.....
         @@@@@@@@@......@@@@.....
         @@@@@@@@.@@.....@@@@@...
         @@@@@@@@.@@@@...@@@@@...
         @@@@@@@@@.@@@@@..@@.@...
         @@@@@@@@@.@@@@@@.@@.....
         @@@@@@@@....@@@@.@@.....
         @@@@@@@@......@@.@@.....
         @@@@@@@@@........@@.@...
         @@@@@@@@@........@@.@@..
         @@@@@@@@.@@......@@@@@..
         @@@@@@@@.@@@@....@@@@...
         @@@@@@@@@.@@@@@..@@@@@..
         @@@@@@@@@.@@@@@@.@@.@@..
         @@@@@@@@....@@@@.@@.@...
         @@@@@@@@......@@.@@.....
         @@@@@@@@@........@@.....
         @@@@@@@@@........@@.....
         @@@@@@@@.@@......@@.@...
         @@@@@@@@.@@@@....@@@@...
         @@@@@@@@@.@@@@@..@@@@...
         @@@@@@@@@.@@@@@@.@@.....
         @@@@@@@@....@@@@.@@.....
         @@@@@@@@......@@.@@.....
         @@@@@@@@@........@@....@
         @@@@@@@@@@.......@@@..@@
         @@@@@@@@@@@@.....@..@@@@
         @@@@@@@@@@@@@@..@.@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

img_doorway_L_type_1:				; Doorways (Moon base)
	8510 00 00 0E 00 00 38 00 00 E2 00 03 9B 00 0E 3B 00
	8520 39 BB 00 F3 BB 03 6B B8 0C 5B B3 11 5B 8C 27 5B
	8530 33 2F 58 CA 73 53 38 4C 4C D0 43 73 E0 44 CC C0
	8540 46 BF 00 4A 8F 00 4C B2 00 4E BC 00 52 8D 00 4C
	8550 B0 C0 52 87 20 4C B8 E0 52 87 C0 5C BF 80 5E BF
	8560 00 5E BE 00 5E BC 00 5E B8 00 5E B3 00 5E A8 C0
	8570 5E 87 20 4E B8 E0 50 87 C0 5C BF 80 5E BF 00 5E
	8580 BE 00 5E BC 00 5E B8 00 5E B3 00 5E A8 C0 5E 87
	8590 20 4E B8 E0 50 87 C0 5C BF 80 5E BF 00 5E BE 00
	85A0 5E BC 00 5E B8 00 5E B4 00 4E A6 00 32 8C 00 0C
	85B0 B0 00 03 C0 00 00 00 00

         ....................@@@.
         ..................@@@...
         ................@@@...@.
         ..............@@@..@@.@@
         ............@@@...@@@.@@
         ..........@@@..@@.@@@.@@
         ........@@@@..@@@.@@@.@@
         ......@@.@@.@.@@@.@@@...
         ....@@...@.@@.@@@.@@..@@
         ...@...@.@.@@.@@@...@@..
         ..@..@@@.@.@@.@@..@@..@@
         ..@.@@@@.@.@@...@@..@.@.
         .@@@..@@.@.@..@@..@@@...
         .@..@@...@..@@..@@.@....
         .@....@@.@@@..@@@@@.....
         .@...@..@@..@@..@@......
         .@...@@.@.@@@@@@........
         .@..@.@.@...@@@@........
         .@..@@..@.@@..@.........
         .@..@@@.@.@@@@..........
         .@.@..@.@...@@.@........
         .@..@@..@.@@....@@......
         .@.@..@.@....@@@..@.....
         .@..@@..@.@@@...@@@.....
         .@.@..@.@....@@@@@......
         .@.@@@..@.@@@@@@@.......
         .@.@@@@.@.@@@@@@........
         .@.@@@@.@.@@@@@.........
         .@.@@@@.@.@@@@..........
         .@.@@@@.@.@@@...........
         .@.@@@@.@.@@..@@........
         .@.@@@@.@.@.@...@@......
         .@.@@@@.@....@@@..@.....
         .@..@@@.@.@@@...@@@.....
         .@.@....@....@@@@@......
         .@.@@@..@.@@@@@@@.......
         .@.@@@@.@.@@@@@@........
         .@.@@@@.@.@@@@@.........
         .@.@@@@.@.@@@@..........
         .@.@@@@.@.@@@...........
         .@.@@@@.@.@@..@@........
         .@.@@@@.@.@.@...@@......
         .@.@@@@.@....@@@..@.....
         .@..@@@.@.@@@...@@@.....
         .@.@....@....@@@@@......
         .@.@@@..@.@@@@@@@.......
         .@.@@@@.@.@@@@@@........
         .@.@@@@.@.@@@@@.........
         .@.@@@@.@.@@@@..........
         .@.@@@@.@.@@@...........
         .@.@@@@.@.@@.@..........
         .@..@@@.@.@..@@.........
         ..@@..@.@...@@..........
         ....@@..@.@@............
         ......@@@@..............
         ........................

	85B8 FF FF CE FF FF 38 FF FC
	85C0 E0 FF F3 98 FF CE 38 FF 38 38 FC F0 38 F3 68 38
	85D0 EC 58 33 D0 58 0C A0 58 30 A0 58 C0 70 53 01 4C
	85E0 4C 07 53 70 0F 50 C0 1F 50 80 3F 40 80 7F 40 80
	85F0 FF 40 80 FF 40 81 3F 40 80 DF 50 87 2F 4C B8 EF
	8600 52 87 DF 5C BF BF 5E BF 7F 5E BE FF 5E BD FF 5E
	8610 B8 FF 5E B3 3F 5E A0 DF 5E 87 2F 4E B8 EF 50 87
	8620 DF 5C BF BF 5E BF 7F 5E BE FF 5E BD FF 5E B8 FF
	8630 5E B3 3F 5E A0 DF 5E 87 2F 4E B8 EF 50 87 DF 5C
	8640 BF BF 5E BF 7F 5E BE FF 5E BD FF 5E BB FF 5E B5
	8650 FF 4E A6 FF B2 8D FF CC B3 FF F3 CF FF FC 3F FF

         @@@@@@@@@@@@@@@@@@..@@@.
         @@@@@@@@@@@@@@@@..@@@...
         @@@@@@@@@@@@@@..@@@.....
         @@@@@@@@@@@@..@@@..@@...
         @@@@@@@@@@..@@@...@@@...
         @@@@@@@@..@@@.....@@@...
         @@@@@@..@@@@......@@@...
         @@@@..@@.@@.@.....@@@...
         @@@.@@...@.@@.....@@..@@
         @@.@.....@.@@.......@@..
         @.@......@.@@.....@@....
         @.@......@.@@...@@......
         .@@@.....@.@..@@.......@
         .@..@@...@..@@.......@@@
         .@.@..@@.@@@........@@@@
         .@.@....@@.........@@@@@
         .@.@....@.........@@@@@@
         .@......@........@@@@@@@
         .@......@.......@@@@@@@@
         .@......@.......@@@@@@@@
         .@......@......@..@@@@@@
         .@......@.......@@.@@@@@
         .@.@....@....@@@..@.@@@@
         .@..@@..@.@@@...@@@.@@@@
         .@.@..@.@....@@@@@.@@@@@
         .@.@@@..@.@@@@@@@.@@@@@@
         .@.@@@@.@.@@@@@@.@@@@@@@
         .@.@@@@.@.@@@@@.@@@@@@@@
         .@.@@@@.@.@@@@.@@@@@@@@@
         .@.@@@@.@.@@@...@@@@@@@@
         .@.@@@@.@.@@..@@..@@@@@@
         .@.@@@@.@.@.....@@.@@@@@
         .@.@@@@.@....@@@..@.@@@@
         .@..@@@.@.@@@...@@@.@@@@
         .@.@....@....@@@@@.@@@@@
         .@.@@@..@.@@@@@@@.@@@@@@
         .@.@@@@.@.@@@@@@.@@@@@@@
         .@.@@@@.@.@@@@@.@@@@@@@@
         .@.@@@@.@.@@@@.@@@@@@@@@
         .@.@@@@.@.@@@...@@@@@@@@
         .@.@@@@.@.@@..@@..@@@@@@
         .@.@@@@.@.@.....@@.@@@@@
         .@.@@@@.@....@@@..@.@@@@
         .@..@@@.@.@@@...@@@.@@@@
         .@.@....@....@@@@@.@@@@@
         .@.@@@..@.@@@@@@@.@@@@@@
         .@.@@@@.@.@@@@@@.@@@@@@@
         .@.@@@@.@.@@@@@.@@@@@@@@
         .@.@@@@.@.@@@@.@@@@@@@@@
         .@.@@@@.@.@@@.@@@@@@@@@@
         .@.@@@@.@.@@.@.@@@@@@@@@
         .@..@@@.@.@..@@.@@@@@@@@
         @.@@..@.@...@@.@@@@@@@@@
         @@..@@..@.@@..@@@@@@@@@@
         @@@@..@@@@..@@@@@@@@@@@@
         @@@@@@....@@@@@@@@@@@@@@

img_doorway_R_type_1:
	8660 00 00 00 00 00 00 00 00 00 00 03 C0 00 0E 30 00
	8670 38 C8 00 E6 74 03 8F 3A 0E 67 92 38 F3 CE 66 79
	8680 32 1F 3C C2 0F 93 02 07 CC 62 13 33 72 18 C6 EA
	8690 67 2E DA FC 6D DA 00 5D B2 00 03 4A 00 28 32 00
	86A0 5C CA 00 B3 3A 00 CC FA 00 33 FA 00 0F FA 00 03
	86B0 FA 00 04 FA 00 08 32 00 14 8A 00 2D 32 00 5C CA
	86C0 00 B3 3A 00 CC FA 00 33 FA 00 0F FA 00 03 FA 00
	86D0 04 FA 00 08 32 00 14 8A 00 2D 32 00 5C CA 00 B3
	86E0 3A 00 CC FA 00 33 FA 00 0F FA 00 03 FA 00 08 F2
	86F0 00 18 0C 00 06 B0 00 01 C0 00 00 00 00 00 00 00
	8700 00 00 00 00 00 00 00 00

         ........................
         ........................
         ........................
         ..............@@@@......
         ............@@@...@@....
         ..........@@@...@@..@...
         ........@@@..@@..@@@.@..
         ......@@@...@@@@..@@@.@.
         ....@@@..@@..@@@@..@..@.
         ..@@@...@@@@..@@@@..@@@.
         .@@..@@..@@@@..@..@@..@.
         ...@@@@@..@@@@..@@....@.
         ....@@@@@..@..@@......@.
         .....@@@@@..@@...@@...@.
         ...@..@@..@@..@@.@@@..@.
         ...@@...@@...@@.@@@.@.@.
         .@@..@@@..@.@@@.@@.@@.@.
         @@@@@@...@@.@@.@@@.@@.@.
         .........@.@@@.@@.@@..@.
         ..............@@.@..@.@.
         ..........@.@.....@@..@.
         .........@.@@@..@@..@.@.
         ........@.@@..@@..@@@.@.
         ........@@..@@..@@@@@.@.
         ..........@@..@@@@@@@.@.
         ............@@@@@@@@@.@.
         ..............@@@@@@@.@.
         .............@..@@@@@.@.
         ............@.....@@..@.
         ...........@.@..@...@.@.
         ..........@.@@.@..@@..@.
         .........@.@@@..@@..@.@.
         ........@.@@..@@..@@@.@.
         ........@@..@@..@@@@@.@.
         ..........@@..@@@@@@@.@.
         ............@@@@@@@@@.@.
         ..............@@@@@@@.@.
         .............@..@@@@@.@.
         ............@.....@@..@.
         ...........@.@..@...@.@.
         ..........@.@@.@..@@..@.
         .........@.@@@..@@..@.@.
         ........@.@@..@@..@@@.@.
         ........@@..@@..@@@@@.@.
         ..........@@..@@@@@@@.@.
         ............@@@@@@@@@.@.
         ..............@@@@@@@.@.
         ............@...@@@@..@.
         ...........@@.......@@..
         .............@@.@.@@....
         ...............@@@......
         ........................
         ........................
         ........................
         ........................
         ........................

	8708 FF FF FF FF FF FF FF FC
	8710 3F FF F3 CF FF CE 37 FF 38 CB FC E0 75 F3 80 3A
	8720 CE 60 12 38 F0 0E 60 78 32 00 3C CA 00 13 1A 00
	8730 0C 0A 10 30 02 18 C0 02 67 00 02 FC 00 02 00 00
	8740 02 FF 80 0A FF A8 32 FF 5C CA FE B3 3A FE CC FA
	8750 FF 33 FA FF CF FA FF F3 FA FF F4 FA FF E8 32 FF
	8760 D4 0A FF AC 32 FF 5C CA FE B3 3A FE CC FA FF 33
	8770 FA FF CF FA FF F3 FA FF F4 FA FF E8 32 FF D4 0A
	8780 FF AC 32 FF 5C CA FE B3 3A FE CC FA FF 33 FA FF
	8790 CF FA FF F3 FA FF E8 F2 FF D8 0D FF E6 B3 FF F9
	87A0 CF FF FE 3F FF FF FF FF FF FF FF FF FF FF FF FF

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@....@@@@@@
         @@@@@@@@@@@@..@@@@..@@@@
         @@@@@@@@@@..@@@...@@.@@@
         @@@@@@@@..@@@...@@..@.@@
         @@@@@@..@@@......@@@.@.@
         @@@@..@@@.........@@@.@.
         @@..@@@..@@........@..@.
         ..@@@...@@@@........@@@.
         .@@......@@@@.....@@..@.
         ..........@@@@..@@..@.@.
         ...........@..@@...@@.@.
         ............@@......@.@.
         ...@......@@..........@.
         ...@@...@@............@.
         .@@..@@@..............@.
         @@@@@@................@.
         ......................@.
         @@@@@@@@@...........@.@.
         @@@@@@@@@.@.@.....@@..@.
         @@@@@@@@.@.@@@..@@..@.@.
         @@@@@@@.@.@@..@@..@@@.@.
         @@@@@@@.@@..@@..@@@@@.@.
         @@@@@@@@..@@..@@@@@@@.@.
         @@@@@@@@@@..@@@@@@@@@.@.
         @@@@@@@@@@@@..@@@@@@@.@.
         @@@@@@@@@@@@.@..@@@@@.@.
         @@@@@@@@@@@.@.....@@..@.
         @@@@@@@@@@.@.@......@.@.
         @@@@@@@@@.@.@@....@@..@.
         @@@@@@@@.@.@@@..@@..@.@.
         @@@@@@@.@.@@..@@..@@@.@.
         @@@@@@@.@@..@@..@@@@@.@.
         @@@@@@@@..@@..@@@@@@@.@.
         @@@@@@@@@@..@@@@@@@@@.@.
         @@@@@@@@@@@@..@@@@@@@.@.
         @@@@@@@@@@@@.@..@@@@@.@.
         @@@@@@@@@@@.@.....@@..@.
         @@@@@@@@@@.@.@......@.@.
         @@@@@@@@@.@.@@....@@..@.
         @@@@@@@@.@.@@@..@@..@.@.
         @@@@@@@.@.@@..@@..@@@.@.
         @@@@@@@.@@..@@..@@@@@.@.
         @@@@@@@@..@@..@@@@@@@.@.
         @@@@@@@@@@..@@@@@@@@@.@.
         @@@@@@@@@@@@..@@@@@@@.@.
         @@@@@@@@@@@.@...@@@@..@.
         @@@@@@@@@@.@@.......@@.@
         @@@@@@@@@@@..@@.@.@@..@@
         @@@@@@@@@@@@@..@@@..@@@@
         @@@@@@@@@@@@@@@...@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

img_doorway_L_type_2:				; Doorways (Safari + Penitentiary + Egyptus)
	87B0 00 00 FC 00 01 FA 00 0B F6 00 1B E3 00 2B EC 00
	87C0 ED E8 03 96 E6 0E 7B 75 19 E5 B9 27 9E 1E 1E 79
	87D0 E1 39 E7 1F 67 DE FE 1F BD C5 3C 3B BB 03 7B 7D
	87E0 3E 7B 7D 6D 7B BE 56 BD DE 6F B6 2E 3C 1F F6 03
	87F0 CF F2 3E E3 C0 6D 78 00 56 E5 00 6F 9A 00 3C 6D
	8800 00 03 D6 00 3E 80 00 6D 7A 00 56 FD 00 6F 7E 00
	8810 3C FF F8 03 7D F0 3E 9F F8 6D 63 E8 56 E5 F0 6F
	8820 9A B0 3C 6D 20 03 D6 00 3E EC 00 6D 7A 00 56 E5
	8830 00 6F 9A 00 38 6D 00 07 D6 00 3E EC 00 6D 7A 00
	8840 56 E5 00 6F 9A 00 38 6D 00 06 D6 00 3D 6C 00 0E
	8850 F0 00 01 80 00 00 00 00

         ................@@@@@@..
         ...............@@@@@@.@.
         ............@.@@@@@@.@@.
         ...........@@.@@@@@...@@
         ..........@.@.@@@@@.@@..
         ........@@@.@@.@@@@.@...
         ......@@@..@.@@.@@@..@@.
         ....@@@..@@@@.@@.@@@.@.@
         ...@@..@@@@..@.@@.@@@..@
         ..@..@@@@..@@@@....@@@@.
         ...@@@@..@@@@..@@@@....@
         ..@@@..@@@@..@@@...@@@@@
         .@@..@@@@@.@@@@.@@@@@@@.
         ...@@@@@@.@@@@.@@@...@.@
         ..@@@@....@@@.@@@.@@@.@@
         ......@@.@@@@.@@.@@@@@.@
         ..@@@@@..@@@@.@@.@@@@@.@
         .@@.@@.@.@@@@.@@@.@@@@@.
         .@.@.@@.@.@@@@.@@@.@@@@.
         .@@.@@@@@.@@.@@...@.@@@.
         ..@@@@.....@@@@@@@@@.@@.
         ......@@@@..@@@@@@@@..@.
         ..@@@@@.@@@...@@@@......
         .@@.@@.@.@@@@...........
         .@.@.@@.@@@..@.@........
         .@@.@@@@@..@@.@.........
         ..@@@@...@@.@@.@........
         ......@@@@.@.@@.........
         ..@@@@@.@...............
         .@@.@@.@.@@@@.@.........
         .@.@.@@.@@@@@@.@........
         .@@.@@@@.@@@@@@.........
         ..@@@@..@@@@@@@@@@@@@...
         ......@@.@@@@@.@@@@@....
         ..@@@@@.@..@@@@@@@@@@...
         .@@.@@.@.@@...@@@@@.@...
         .@.@.@@.@@@..@.@@@@@....
         .@@.@@@@@..@@.@.@.@@....
         ..@@@@...@@.@@.@..@.....
         ......@@@@.@.@@.........
         ..@@@@@.@@@.@@..........
         .@@.@@.@.@@@@.@.........
         .@.@.@@.@@@..@.@........
         .@@.@@@@@..@@.@.........
         ..@@@....@@.@@.@........
         .....@@@@@.@.@@.........
         ..@@@@@.@@@.@@..........
         .@@.@@.@.@@@@.@.........
         .@.@.@@.@@@..@.@........
         .@@.@@@@@..@@.@.........
         ..@@@....@@.@@.@........
         .....@@.@@.@.@@.........
         ..@@@@.@.@@.@@..........
         ....@@@.@@@@............
         .......@@...............
         ........................

	8858 FF FE FC FF F1 F8 FF E3
	8860 F0 FF C3 E3 FF 03 E0 FC 01 E0 F0 10 E0 E0 78 70
	8870 C1 E0 38 87 80 1E DE 01 E0 B8 07 00 60 1E 00 80
	8880 3C 01 80 38 3B C0 78 7D 80 78 7D 01 78 3E 10 3C
	8890 1E 00 36 2E 80 1F F6 C0 0F F2 80 03 CD 01 00 3F
	88A0 10 00 7F 00 02 7F 80 00 7F C0 10 FF 80 01 FF 01
	88B0 78 FF 10 FC 7F 00 7E 07 80 FF FB C0 7D F7 80 1F
	88C0 FB 01 03 EB 10 01 F7 00 02 B7 80 00 2F C0 10 DF
	88D0 80 01 FF 01 00 FF 10 00 7F 00 02 7F 80 00 7F C0
	88E0 10 FF 80 01 FF 01 00 FF 10 00 7F 00 02 7F 80 00
	88F0 7F C0 10 FF 81 01 FF C0 03 FF F0 0F FF FE 7F FF

         @@@@@@@@@@@@@@@.@@@@@@..
         @@@@@@@@@@@@...@@@@@@...
         @@@@@@@@@@@...@@@@@@....
         @@@@@@@@@@....@@@@@...@@
         @@@@@@@@......@@@@@.....
         @@@@@@.........@@@@.....
         @@@@.......@....@@@.....
         @@@......@@@@....@@@....
         @@.....@@@@.......@@@...
         @....@@@@..........@@@@.
         @@.@@@@........@@@@.....
         @.@@@........@@@........
         .@@........@@@@.........
         @.........@@@@.........@
         @.........@@@.....@@@.@@
         @@.......@@@@....@@@@@.@
         @........@@@@....@@@@@.@
         .......@.@@@@.....@@@@@.
         ...@......@@@@.....@@@@.
         ..........@@.@@...@.@@@.
         @..........@@@@@@@@@.@@.
         @@..........@@@@@@@@..@.
         @.............@@@@..@@.@
         .......@..........@@@@@@
         ...@.............@@@@@@@
         ..............@..@@@@@@@
         @................@@@@@@@
         @@.........@....@@@@@@@@
         @..............@@@@@@@@@
         .......@.@@@@...@@@@@@@@
         ...@....@@@@@@...@@@@@@@
         .........@@@@@@......@@@
         @.......@@@@@@@@@@@@@.@@
         @@.......@@@@@.@@@@@.@@@
         @..........@@@@@@@@@@.@@
         .......@......@@@@@.@.@@
         ...@...........@@@@@.@@@
         ..............@.@.@@.@@@
         @.................@.@@@@
         @@.........@....@@.@@@@@
         @..............@@@@@@@@@
         .......@........@@@@@@@@
         ...@.............@@@@@@@
         ..............@..@@@@@@@
         @................@@@@@@@
         @@.........@....@@@@@@@@
         @..............@@@@@@@@@
         .......@........@@@@@@@@
         ...@.............@@@@@@@
         ..............@..@@@@@@@
         @................@@@@@@@
         @@.........@....@@@@@@@@
         @......@.......@@@@@@@@@
         @@............@@@@@@@@@@
         @@@@........@@@@@@@@@@@@
         @@@@@@@..@@@@@@@@@@@@@@@

img_doorway_R_type_2:
	8900 00 00 00 00 01 CE 00 0F 3C 00 3C F0 00 CB CE 07
	8910 37 3C 1F D8 F8 7F ED E4 3C 35 86 00 DA 7A 00 AA
	8920 FC 00 6D 1C 00 14 EE 00 35 F6 00 53 36 00 6E D6
	8930 00 9D EE 00 73 EC 00 ED F4 00 DE F0 00 3E 74 00
	8940 DF 32 00 CF 54 00 E3 4A 00 ED 2C 00 6C D0 00 AA
	8950 EC 00 8D DA 00 DF 1E 00 70 DE 00 0F BE 00 7C 7E
	8960 00 D9 EC 00 A7 FC 00 D5 F8 00 73 FA 00 06 78 00
	8970 79 90 00 DA 64 00 AD 8A 00 DF 34 00 70 DA 00 0F
	8980 AC 00 7D D8 00 DA F4 00 AD CA 00 DF 34 00 70 DA
	8990 00 0D AC 00 7A D8 00 1D E0 00 03 00 00 00 00 00
	89A0 00 00 00 00 00 00 00 00

         ........................
         ...............@@@..@@@.
         ............@@@@..@@@@..
         ..........@@@@..@@@@....
         ........@@..@.@@@@..@@@.
         .....@@@..@@.@@@..@@@@..
         ...@@@@@@@.@@...@@@@@...
         .@@@@@@@@@@.@@.@@@@..@..
         ..@@@@....@@.@.@@....@@.
         ........@@.@@.@..@@@@.@.
         ........@.@.@.@.@@@@@@..
         .........@@.@@.@...@@@..
         ...........@.@..@@@.@@@.
         ..........@@.@.@@@@@.@@.
         .........@.@..@@..@@.@@.
         .........@@.@@@.@@.@.@@.
         ........@..@@@.@@@@.@@@.
         .........@@@..@@@@@.@@..
         ........@@@.@@.@@@@@.@..
         ........@@.@@@@.@@@@....
         ..........@@@@@..@@@.@..
         ........@@.@@@@@..@@..@.
         ........@@..@@@@.@.@.@..
         ........@@@...@@.@..@.@.
         ........@@@.@@.@..@.@@..
         .........@@.@@..@@.@....
         ........@.@.@.@.@@@.@@..
         ........@...@@.@@@.@@.@.
         ........@@.@@@@@...@@@@.
         .........@@@....@@.@@@@.
         ............@@@@@.@@@@@.
         .........@@@@@...@@@@@@.
         ........@@.@@..@@@@.@@..
         ........@.@..@@@@@@@@@..
         ........@@.@.@.@@@@@@...
         .........@@@..@@@@@@@.@.
         .............@@..@@@@...
         .........@@@@..@@..@....
         ........@@.@@.@..@@..@..
         ........@.@.@@.@@...@.@.
         ........@@.@@@@@..@@.@..
         .........@@@....@@.@@.@.
         ............@@@@@.@.@@..
         .........@@@@@.@@@.@@...
         ........@@.@@.@.@@@@.@..
         ........@.@.@@.@@@..@.@.
         ........@@.@@@@@..@@.@..
         .........@@@....@@.@@.@.
         ............@@.@@.@.@@..
         .........@@@@.@.@@.@@...
         ...........@@@.@@@@.....
         ..............@@........
         ........................
         ........................
         ........................
         ........................

	89A8 FF FE 31 FF F0 0E FF C0
	89B0 3C FF 00 F1 F8 03 C0 E7 07 01 9F C0 03 7F E0 01
	89C0 3C 30 00 00 18 78 00 08 FD 00 0C 1D 00 04 0E 00
	89D0 04 06 00 00 06 00 00 C6 00 01 EE 00 03 ED 00 0D
	89E0 F5 00 1E F3 00 3E 71 00 DF 30 FE CF 14 FE E3 00
	89F0 FE E1 21 FF 60 01 FE 22 0D FE 00 1A FE 00 1E FF
	8A00 00 1E FF 80 3E FF 00 7E FE 01 ED FE 27 FC FE 05
	8A10 F8 FF 03 F8 FF 86 79 FF 01 93 FE 02 61 FE 20 00
	8A20 FE 00 04 FF 00 00 FF 80 21 FF 00 03 FE 02 01 FE
	8A30 20 00 FE 00 04 FF 00 00 FF 80 21 FF 02 03 FF 80
	8A40 07 FF E0 1F FF FC FF FF FF FF FF FF FF FF FF FF

         @@@@@@@@@@@@@@@...@@...@
         @@@@@@@@@@@@........@@@.
         @@@@@@@@@@........@@@@..
         @@@@@@@@........@@@@...@
         @@@@@.........@@@@......
         @@@..@@@.....@@@.......@
         @..@@@@@@@............@@
         .@@@@@@@@@@............@
         ..@@@@....@@............
         ...........@@....@@@@...
         ............@...@@@@@@.@
         ............@@.....@@@.@
         .............@......@@@.
         .............@.......@@.
         .....................@@.
         ................@@...@@.
         ...............@@@@.@@@.
         ..............@@@@@.@@.@
         ............@@.@@@@@.@.@
         ...........@@@@.@@@@..@@
         ..........@@@@@..@@@...@
         ........@@.@@@@@..@@....
         @@@@@@@.@@..@@@@...@.@..
         @@@@@@@.@@@...@@........
         @@@@@@@.@@@....@..@....@
         @@@@@@@@.@@............@
         @@@@@@@...@...@.....@@.@
         @@@@@@@............@@.@.
         @@@@@@@............@@@@.
         @@@@@@@@...........@@@@.
         @@@@@@@@@.........@@@@@.
         @@@@@@@@.........@@@@@@.
         @@@@@@@........@@@@.@@.@
         @@@@@@@...@..@@@@@@@@@..
         @@@@@@@......@.@@@@@@...
         @@@@@@@@......@@@@@@@...
         @@@@@@@@@....@@..@@@@..@
         @@@@@@@@.......@@..@..@@
         @@@@@@@.......@..@@....@
         @@@@@@@...@.............
         @@@@@@@..............@..
         @@@@@@@@................
         @@@@@@@@@.........@....@
         @@@@@@@@..............@@
         @@@@@@@.......@........@
         @@@@@@@...@.............
         @@@@@@@..............@..
         @@@@@@@@................
         @@@@@@@@@.........@....@
         @@@@@@@@......@.......@@
         @@@@@@@@@............@@@
         @@@@@@@@@@@........@@@@@
         @@@@@@@@@@@@@@..@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

;; -----------------------------------------------------------------------------------------------------------
img_3x32.bin:				; SPR_VISOROHALF: EQU $10
	8A50 00 00 00 00 18 00 01 E7 00 07 F9 C0 01 FE E0 1C
	8A60 7F 70 3F 3F B0 3F 9F CC 5F CF 3E 4F EC FA 33 E3
	8A70 E2 4D CF 86 72 3E 02 7C F8 06 5D C4 02 46 E8 06
	8A80 76 C8 46 3D E0 EE 1E C8 FC 06 E1 70 09 E3 F4 06
	8A90 FF 0C 0B 3C 38 0D C0 F0 2E F7 C4 47 7F 12 33 9C
	8AA0 4C 0C C1 30 03 18 C0 00 C3 00 00 3C 00 00 00 00

	     ........................
         ...........@@...........
         .......@@@@..@@@........
         .....@@@@@@@@..@@@......
         .......@@@@@@@@.@@@.....
         ...@@@...@@@@@@@.@@@....
         ..@@@@@@..@@@@@@@.@@....
         ..@@@@@@@..@@@@@@@..@@..
         .@.@@@@@@@..@@@@..@@@@@.
         .@..@@@@@@@.@@..@@@@@.@.
         ..@@..@@@@@...@@@@@...@.
         .@..@@.@@@..@@@@@....@@.
         .@@@..@...@@@@@.......@.
         .@@@@@..@@@@@........@@.
         .@.@@@.@@@...@........@.
         .@...@@.@@@.@........@@.
         .@@@.@@.@@..@....@...@@.
         ..@@@@.@@@@.....@@@.@@@.
         ...@@@@.@@..@...@@@@@@..
         .....@@.@@@....@.@@@....
         ....@..@@@@...@@@@@@.@..
         .....@@.@@@@@@@@....@@..
         ....@.@@..@@@@....@@@...
         ....@@.@@@......@@@@....
         ..@.@@@.@@@@.@@@@@...@..
         .@...@@@.@@@@@@@...@..@.
         ..@@..@@@..@@@...@..@@..
         ....@@..@@.....@..@@....
         ......@@...@@...@@......
         ........@@....@@........
         ..........@@@@..........
         ........................

							; SPR_VISORCHALF: EQU $11
	8AB0 FF E7 FF FE 00 FF F8 00 3F F0 00 1F E0 00 0F C0
	8AC0 00 07 80 00 03 80 00 0D 40 00 3E 40 00 FA 30 03
	8AD0 E2 0C 0F 86 02 3E 02 00 F8 06 01 C0 02 00 E0 06
	8AE0 00 C0 46 81 E0 EE C0 C0 FD E0 E1 73 E1 E3 F1 F0
	8AF0 FF 01 E0 3C 03 C0 00 03 A0 00 05 40 00 02 B0 00
	8B00 0D CC 00 33 F3 00 CF FC C3 3F FF 3C FF FF C3 FF

         @@@@@@@@@@@..@@@@@@@@@@@
         @@@@@@@.........@@@@@@@@
         @@@@@.............@@@@@@
         @@@@...............@@@@@
         @@@.................@@@@
         @@...................@@@
         @.....................@@
         @...................@@.@
         .@................@@@@@.
         .@..............@@@@@.@.
         ..@@..........@@@@@...@.
         ....@@......@@@@@....@@.
         ......@...@@@@@.......@.
         ........@@@@@........@@.
         .......@@@............@.
         ........@@@..........@@.
         ........@@.......@...@@.
         @......@@@@.....@@@.@@@.
         @@......@@......@@@@@@.@
         @@@.....@@@....@.@@@..@@
         @@@....@@@@...@@@@@@...@
         @@@@....@@@@@@@@.......@
         @@@.......@@@@........@@
         @@....................@@
         @.@..................@.@
         .@....................@.
         @.@@................@@.@
         @@..@@............@@..@@
         @@@@..@@........@@..@@@@
         @@@@@@..@@....@@..@@@@@@
         @@@@@@@@..@@@@..@@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_VISORO:     EQU $12
	8B10 00 00 00 00 1C 00 00 E3 80 03 FC E0 04 7F 70 0F
	8B20 1F B8 0F CF DC 1F E7 EC 5F F3 EA 6F FB F2 57 F9
	8B30 E4 69 FD 9A 56 38 66 59 C3 9E 5E 3C 7E 5B C3 E6
	8B40 58 FF DE 2E FF FC 07 FF F8 29 FF E4 30 3F 18 3F
	8B50 C0 F0 0F 1F E0 00 7F 90 27 F8 74 47 FB E2 33 FF
	8B60 CC 0C FF 30 03 18 C0 00 C3 00 00 3C 00 00 00 00

         ........................
         ...........@@@..........
         ........@@@...@@@.......
         ......@@@@@@@@..@@@.....
         .....@...@@@@@@@.@@@....
         ....@@@@...@@@@@@.@@@...
         ....@@@@@@..@@@@@@.@@@..
         ...@@@@@@@@..@@@@@@.@@..
         .@.@@@@@@@@@..@@@@@.@.@.
         .@@.@@@@@@@@@.@@@@@@..@.
         .@.@.@@@@@@@@..@@@@..@..
         .@@.@..@@@@@@@.@@..@@.@.
         .@.@.@@...@@@....@@..@@.
         .@.@@..@@@....@@@..@@@@.
         .@.@@@@...@@@@...@@@@@@.
         .@.@@.@@@@....@@@@@..@@.
         .@.@@...@@@@@@@@@@.@@@@.
         ..@.@@@.@@@@@@@@@@@@@@..
         .....@@@@@@@@@@@@@@@@...
         ..@.@..@@@@@@@@@@@@..@..
         ..@@......@@@@@@...@@...
         ..@@@@@@@@......@@@@....
         ....@@@@...@@@@@@@@.....
         .........@@@@@@@@..@....
         ..@..@@@@@@@@....@@@.@..
         .@...@@@@@@@@.@@@@@...@.
         ..@@..@@@@@@@@@@@@..@@..
         ....@@..@@@@@@@@..@@....
         ......@@...@@...@@......
         ........@@....@@........
         ..........@@@@..........
         ........................

							; SPR_VISORC:     EQU $13
	8B70 FF E3 FF FF 00 7F FC 00 1F F8 00 0F F0 00 07 E0
	8B80 00 03 C0 00 01 80 00 01 40 00 02 60 00 02 50 00
	8B90 04 68 00 18 46 00 60 41 C3 80 40 3C 00 40 00 00
	8BA0 40 00 00 A0 00 01 C0 00 03 80 00 01 80 00 03 80
	8BB0 00 07 C0 00 0F C0 00 03 A0 00 05 40 00 02 B0 00
	8BC0 0D CC 00 33 F3 00 CF FC C3 3F FF 3C FF FF C3 FF

         @@@@@@@@@@@...@@@@@@@@@@
         @@@@@@@@.........@@@@@@@
         @@@@@@.............@@@@@
         @@@@@...............@@@@
         @@@@.................@@@
         @@@...................@@
         @@.....................@
         @......................@
         .@....................@.
         .@@...................@.
         .@.@.................@..
         .@@.@..............@@...
         .@...@@..........@@.....
         .@.....@@@....@@@.......
         .@........@@@@..........
         .@......................
         .@......................
         @.@....................@
         @@....................@@
         @......................@
         @.....................@@
         @....................@@@
         @@..................@@@@
         @@....................@@
         @.@..................@.@
         .@....................@.
         @.@@................@@.@
         @@..@@............@@..@@
         @@@@..@@........@@..@@@@
         @@@@@@..@@....@@..@@@@@@
         @@@@@@@@..@@@@..@@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

img_3x24.bin:
img_3x24_0:
spr_head1:			; SPR_HEELS1:     EQU $18	3x24
					; (This is also the one used on the main menu and
					; on the crown ("Salute") screen, although flipped)
	8BD0 00 00 00 00 3E 00 01 F9 C0 07 C6 F0 0F BE F8 0F
	8DE0 C1 8C 1F FD AC 1B CF 76 07 97 46 3F BA 0A 3F A1
	8BF0 BC 7F 83 DC 77 9B D4 0F 7A BC 09 FC 68 02 EF 70
	8C00 0F FB 0E 1F 6E FA 1F B9 6C 07 C7 B0 01 FD D0 00
	8C10 76 C0 00 18 00 00 00 00

         ........................
         ..........@@@@@.........
         .......@@@@@@..@@@......
         .....@@@@@...@@.@@@@....
         ....@@@@@.@@@@@.@@@@@...
         ....@@@@@@.....@@...@@..
         ...@@@@@@@@@@@.@@.@.@@..
         ...@@.@@@@..@@@@.@@@.@@.
         .....@@@@..@.@@@.@...@@.
         ..@@@@@@@.@@@.@.....@.@.
         ..@@@@@@@.@....@@.@@@@..
         .@@@@@@@@.....@@@@.@@@..
         .@@@.@@@@..@@.@@@@.@.@..
         ....@@@@.@@@@.@.@.@@@@..
         ....@..@@@@@@@...@@.@...
         ......@.@@@.@@@@.@@@....
         ....@@@@@@@@@.@@....@@@.
         ...@@@@@.@@.@@@.@@@@@.@.
         ...@@@@@@.@@@..@.@@.@@..
         .....@@@@@...@@@@.@@....
         .......@@@@@@@.@@@.@....
         .........@@@.@@.@@......
         ...........@@...........
         ........................

img_3x24_0_mask:
	8C18 FF C1 FF FE 3E 3F F9 F9 CF F7 C0 F7 EF 80 FB EF
	8C28 C1 8D DF FD 8D DB CF 36 C7 87 06 BF 9A 0A BF 80
	8C38 3D 7F 80 1D 77 98 15 8F 78 3D E9 FC 6B F2 EF 71
    8C48 EF FB 0E DF 6E FA DF B9 6D E7 C7 B3 F9 FD D7 FE
	8C58 76 CF FF 99 3F FF E7 FF

         @@@@@@@@@@.....@@@@@@@@@
         @@@@@@@...@@@@@...@@@@@@
         @@@@@..@@@@@@..@@@..@@@@
         @@@@.@@@@@......@@@@.@@@
         @@@.@@@@@.......@@@@@.@@
         @@@.@@@@@@.....@@...@@.@
         @@.@@@@@@@@@@@.@@...@@.@
         @@.@@.@@@@..@@@@..@@.@@.
         @@...@@@@....@@@.....@@.
         @.@@@@@@@..@@.@.....@.@.
         @.@@@@@@@.........@@@@.@
         .@@@@@@@@..........@@@.@
         .@@@.@@@@..@@......@.@.@
         @...@@@@.@@@@.....@@@@.@
         @@@.@..@@@@@@@...@@.@.@@
         @@@@..@.@@@.@@@@.@@@...@
         @@@.@@@@@@@@@.@@....@@@.
         @@.@@@@@.@@.@@@.@@@@@.@.
         @@.@@@@@@.@@@..@.@@.@@.@
         @@@..@@@@@...@@@@.@@..@@
         @@@@@..@@@@@@@.@@@.@.@@@
         @@@@@@@..@@@.@@.@@..@@@@
         @@@@@@@@@..@@..@..@@@@@@
         @@@@@@@@@@@..@@@@@@@@@@@

	;;	 bit	 bit
	;;	image	mask	result
	;;	0 (.)   0 (.)	Black (X)
	;;	1 (@)   0 (.)	Color (c) (touch of color, depends on current color scheme)
	;;	0 (.)   1 (@)	Transparent (_)
	;;	1 (@)   1 (@)	Cream (.) (main body color)
	;;
	;;	addr:8BD0													 addr:8C18
	;;	00 00 00  ........................  @@@@@@@@@@.....@@@@@@@@@ FF C1 FF : __________XXXXX_________
	;;	00 3E 00  ..........@@@@@.........  @@@@@@@...@@@@@...@@@@@@ FE 3E 3F : _______XXX.....XXX______
	;;	01 F9 C0  .......@@@@@@..@@@......  @@@@@..@@@@@@..@@@..@@@@ F9 F9 CF : _____XX......XX...XX____
	;;	07 C6 F0  .....@@@@@...@@.@@@@....  @@@@.@@@@@......@@@@.@@@ F7 C0 F7 : ____X.....XXXccX....X___
	;;	0F BE F8  ....@@@@@.@@@@@.@@@@@...  @@@.@@@@@.......@@@@@.@@ EF 80 FB : ___X.....XcccccX.....X__
	;;	0F C1 8C  ....@@@@@@.....@@...@@..  @@@.@@@@@@.....@@...@@.@ EF C1 8D : ___X......XXXXX..XXX..X_
	;;	1F FD AC  ...@@@@@@@@@@@.@@.@.@@..  @@.@@@@@@@@@@@.@@...@@.@ DF FD 8D : __X...........X..XcX..X_
	;;	1B CF 76  ...@@.@@@@..@@@@.@@@.@@.  @@.@@.@@@@..@@@@..@@.@@. DB CF 36 : __X..X....XX....Xc..X..X
	;;	07 97 46  .....@@@@..@.@@@.@...@@.  @@...@@@@....@@@.....@@. C7 87 06 : __XXX....XXcX...XcXXX..X
	;;	3F BA 0A  ..@@@@@@@.@@@.@.....@.@.  @.@@@@@@@..@@.@.....@.@. BF 9A 0A : _X.......Xc..X.XXXXX.X.X
	;;	3F A1 BC  ..@@@@@@@.@....@@.@@@@..  @.@@@@@@@.........@@@@.@ BF 80 3D : _X.......XcXXXXccX....X_
	;;	7F 83 DC  .@@@@@@@@.....@@@@.@@@..  .@@@@@@@@..........@@@.@ 7F 80 1D : X........XXXXXccccX...X_
	;;	77 9B D4  .@@@.@@@@..@@.@@@@.@.@..  .@@@.@@@@..@@......@.@.@ 77 98 15 : X...X....XX..XccccX.X.X_
	;;	0F 7A BC  ....@@@@.@@@@.@.@.@@@@..  @...@@@@.@@@@.....@@@@.@ 8F 78 3D : _XXX....X....XcXcX....X_
	;;	09 FC 68  ....@..@@@@@@@...@@.@...  @@@.@..@@@@@@@...@@.@.@@ E9 FC 6B : ___X.XX.......XXX..X.X__
	;;	02 EF 70  ......@.@@@.@@@@.@@@....  @@@@..@.@@@.@@@@.@@@...@ F2 EF 71 : ____XX.X...X....X...XXX_
	;;	0F FB 0E  ....@@@@@@@@@.@@....@@@.  @@@.@@@@@@@@@.@@....@@@. EF FB 0E : ___X.........X..XXXX...X
	;;	1F 6E FA  ...@@@@@.@@.@@@.@@@@@.@.  @@.@@@@@.@@.@@@.@@@@@.@. DF 6E FA : __X.....X..X...X.....X.X
	;;	1F B9 6C  ...@@@@@@.@@@..@.@@.@@..  @@.@@@@@@.@@@..@.@@.@@.@ DF B9 6D : __X......X...XX.X..X..X_
	;;	07 C7 B0  .....@@@@@...@@@@.@@....  @@@..@@@@@...@@@@.@@..@@ E7 C7 B3 : ___XX.....XXX....X..XX__
	;;	01 FD D0  .......@@@@@@@.@@@.@....  @@@@@..@@@@@@@.@@@.@.@@@ F9 FD D7 : _____XX.......X...X.X___
	;;	00 76 C0  .........@@@.@@.@@......  @@@@@@@..@@@.@@.@@..@@@@ FE 76 CF : _______XX...X..X..XX____
	;;	00 18 00  ...........@@...........  @@@@@@@@@..@@..@..@@@@@@ FF 99 3F : _________XX..XX_XX______
	;;	00 00 00  ........................  @@@@@@@@@@@..@@@@@@@@@@@ FF E7 FF : ___________XX___________

img_3x24_1:			; SPR_HEELS2:     EQU $19	3x24
	8C60 00 00 00 00 3E 00 01 F9 C0 07 C6 F0 0F BE F8 0F
	8C70 C1 8C 1F FD AC 0B CF 76 37 97 46 7F BA 0A 7F A1
	8C80 BC 37 83 DC 0F 9B D4 0F 7A BC 09 FC 68 02 EF 74
	8C90 07 FB 08 0F 6E 60 0F B9 80 03 C7 C0 00 FE E0 00
	8CA0 3B 60 00 0C 00 00 00 00

         ........................
         ..........@@@@@.........
         .......@@@@@@..@@@......
         .....@@@@@...@@.@@@@....
         ....@@@@@.@@@@@.@@@@@...
         ....@@@@@@.....@@...@@..
         ...@@@@@@@@@@@.@@.@.@@..
         ....@.@@@@..@@@@.@@@.@@.
         ..@@.@@@@..@.@@@.@...@@.
         .@@@@@@@@.@@@.@.....@.@.
         .@@@@@@@@.@....@@.@@@@..
         ..@@.@@@@.....@@@@.@@@..
         ....@@@@@..@@.@@@@.@.@..
         ....@@@@.@@@@.@.@.@@@@..
         ....@..@@@@@@@...@@.@...
         ......@.@@@.@@@@.@@@.@..
         .....@@@@@@@@.@@....@...
         ....@@@@.@@.@@@..@@.....
         ....@@@@@.@@@..@@.......
         ......@@@@...@@@@@......
         ........@@@@@@@.@@@.....
         ..........@@@.@@.@@.....
         ............@@..........
         ........................

img_3x24_1_mask:
	8CA8 FF C1 FF FE 3E 3F F9 F9
	8CB0 CF F7 C0 F7 EF 80 FB EF C1 8D DF FD 8D CB CF 36
	8CC0 B7 87 06 7F 9A 0A 7F 80 3D B7 80 1D CF 98 15 EF
	8CD0 78 3D E9 FC 6B F2 EF 75 F7 FB 0B EF 6E 67 EF B9
	8CE0 9F F3 C7 DF FC FE EF FF 3B 6F FF CC 9F FF F3 FF

         @@@@@@@@@@.....@@@@@@@@@
         @@@@@@@...@@@@@...@@@@@@
         @@@@@..@@@@@@..@@@..@@@@
         @@@@.@@@@@......@@@@.@@@
         @@@.@@@@@.......@@@@@.@@
         @@@.@@@@@@.....@@...@@.@
         @@.@@@@@@@@@@@.@@...@@.@
         @@..@.@@@@..@@@@..@@.@@.
         @.@@.@@@@....@@@.....@@.
         .@@@@@@@@..@@.@.....@.@.
         .@@@@@@@@.........@@@@.@
         @.@@.@@@@..........@@@.@
         @@..@@@@@..@@......@.@.@
         @@@.@@@@.@@@@.....@@@@.@
         @@@.@..@@@@@@@...@@.@.@@
         @@@@..@.@@@.@@@@.@@@.@.@
         @@@@.@@@@@@@@.@@....@.@@
         @@@.@@@@.@@.@@@..@@..@@@
         @@@.@@@@@.@@@..@@..@@@@@
         @@@@..@@@@...@@@@@.@@@@@
         @@@@@@..@@@@@@@.@@@.@@@@
         @@@@@@@@..@@@.@@.@@.@@@@
         @@@@@@@@@@..@@..@..@@@@@
         @@@@@@@@@@@@..@@@@@@@@@@

					; SPR_HEELS3:     EQU $1A	3x24
	8CF0 00 00 00 00 3E 00 01 F9 C0 07 C6 F0 0F BE F8 0F
	8D00 C1 8C 1F FD AC 1B CF 76 67 97 46 7F BA 0A 7F A1
	8D10 BC 2F 83 DC 07 9B D4 0F 7A BC 09 FC 68 16 EF 70
	8D20 3F FB 0E 1F 6E FA 0F B8 EC 03 C7 70 00 DB 30 00
	8D30 60 00 00 00 00 00 00 00 FF C1 FF FE 3E 3F F9 F9
	8D40 CF F7 C0 F7 EF 80 FB EF C1 8D DF FD 8D 9B CF 36
	8D50 67 87 06 7F 9A 0A 7F 80 3D AF 80 1D D7 98 15 EF
	8D60 78 3D E9 FC 6B D6 EF 71 BF FB 0E DF 6E FA EF B8
	8D70 ED F3 C7 73 FC DB 37 FF 64 CF FF 9F FF FF FF FF

	     ........................
         ..........@@@@@.........
         .......@@@@@@..@@@......
         .....@@@@@...@@.@@@@....
         ....@@@@@.@@@@@.@@@@@...
         ....@@@@@@.....@@...@@..
         ...@@@@@@@@@@@.@@.@.@@..
         ...@@.@@@@..@@@@.@@@.@@.
         .@@..@@@@..@.@@@.@...@@.
         .@@@@@@@@.@@@.@.....@.@.
         .@@@@@@@@.@....@@.@@@@..
         ..@.@@@@@.....@@@@.@@@..
         .....@@@@..@@.@@@@.@.@..
         ....@@@@.@@@@.@.@.@@@@..
         ....@..@@@@@@@...@@.@...
         ...@.@@.@@@.@@@@.@@@....
         ..@@@@@@@@@@@.@@....@@@.
         ...@@@@@.@@.@@@.@@@@@.@.
         ....@@@@@.@@@...@@@.@@..
         ......@@@@...@@@.@@@....
         ........@@.@@.@@..@@....
         .........@@.............
         ........................
         ........................

         @@@@@@@@@@.....@@@@@@@@@
         @@@@@@@...@@@@@...@@@@@@
         @@@@@..@@@@@@..@@@..@@@@
         @@@@.@@@@@......@@@@.@@@
         @@@.@@@@@.......@@@@@.@@
         @@@.@@@@@@.....@@...@@.@
         @@.@@@@@@@@@@@.@@...@@.@
         @..@@.@@@@..@@@@..@@.@@.
         .@@..@@@@....@@@.....@@.
         .@@@@@@@@..@@.@.....@.@.
         .@@@@@@@@.........@@@@.@
         @.@.@@@@@..........@@@.@
         @@.@.@@@@..@@......@.@.@
         @@@.@@@@.@@@@.....@@@@.@
         @@@.@..@@@@@@@...@@.@.@@
         @@.@.@@.@@@.@@@@.@@@...@
         @.@@@@@@@@@@@.@@....@@@.
         @@.@@@@@.@@.@@@.@@@@@.@.
         @@@.@@@@@.@@@...@@@.@@.@
         @@@@..@@@@...@@@.@@@..@@
         @@@@@@..@@.@@.@@..@@.@@@
         @@@@@@@@.@@..@..@@..@@@@
         @@@@@@@@@..@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@


			; SPR_HEELSB1:     EQU $1B	3x24
	8D80 00 00 00 00 34 00 01 E7 00 06 1F C0 0F FB E8 0F
	8D90 FF F4 1F FE F4 1F FD 38 3F FC D8 2E FE E8 1F 1E
	8DA0 E8 3F EF 60 2F 77 60 3F B7 B0 16 4F C0 0F BF 20
	8DB0 17 F0 F0 39 F7 70 1E 7B F8 07 BD F8 03 FC 70 00
	8DC0 FC 00 00 38 00 00 00 00 FF CB FF FE 04 FF F8 07
	8DD0 3F F6 1F D7 EF FB EB EF FF F5 DF FE F5 DF FC 3B
	8DE0 BF FC 1B AE FE 0B DF 1E 0B BF EF 07 AF 77 07 BF
	8DF0 B7 87 D6 4F CF EF BF 2F D7 F0 F7 B9 F7 77 DE 7B
	8E00 FB E7 BD FB FB FC 77 FC FD 8F FF 3B FF FF C7 FF

         ........................
         ..........@@.@..........
         .......@@@@..@@@........
         .....@@....@@@@@@@......
         ....@@@@@@@@@.@@@@@.@...
         ....@@@@@@@@@@@@@@@@.@..
         ...@@@@@@@@@@@@.@@@@.@..
         ...@@@@@@@@@@@.@..@@@...
         ..@@@@@@@@@@@@..@@.@@...
         ..@.@@@.@@@@@@@.@@@.@...
         ...@@@@@...@@@@.@@@.@...
         ..@@@@@@@@@.@@@@.@@.....
         ..@.@@@@.@@@.@@@.@@.....
         ..@@@@@@@.@@.@@@@.@@....
         ...@.@@..@..@@@@@@......
         ....@@@@@.@@@@@@..@.....
         ...@.@@@@@@@....@@@@....
         ..@@@..@@@@@.@@@.@@@....
         ...@@@@..@@@@.@@@@@@@...
         .....@@@@.@@@@.@@@@@@...
         ......@@@@@@@@...@@@....
         ........@@@@@@..........
         ..........@@@...........
         ........................

         @@@@@@@@@@..@.@@@@@@@@@@
         @@@@@@@......@..@@@@@@@@
         @@@@@........@@@..@@@@@@
         @@@@.@@....@@@@@@@.@.@@@
         @@@.@@@@@@@@@.@@@@@.@.@@
         @@@.@@@@@@@@@@@@@@@@.@.@
         @@.@@@@@@@@@@@@.@@@@.@.@
         @@.@@@@@@@@@@@....@@@.@@
         @.@@@@@@@@@@@@.....@@.@@
         @.@.@@@.@@@@@@@.....@.@@
         @@.@@@@@...@@@@.....@.@@
         @.@@@@@@@@@.@@@@.....@@@
         @.@.@@@@.@@@.@@@.....@@@
         @.@@@@@@@.@@.@@@@....@@@
         @@.@.@@..@..@@@@@@..@@@@
         @@@.@@@@@.@@@@@@..@.@@@@
         @@.@.@@@@@@@....@@@@.@@@
         @.@@@..@@@@@.@@@.@@@.@@@
         @@.@@@@..@@@@.@@@@@@@.@@
         @@@..@@@@.@@@@.@@@@@@.@@
         @@@@@.@@@@@@@@...@@@.@@@
         @@@@@@..@@@@@@.@@...@@@@
         @@@@@@@@..@@@.@@@@@@@@@@
         @@@@@@@@@@...@@@@@@@@@@@

				; SPR_HEELSB2:     EQU $1C	3x24
	8E10 00 00 00 00 34 00 01 E7 00 06 1F CC 0F FB EC 0F
	8E20 FF F0 1F FE F0 1F FD 38 3F FC D8 2E CE E8 1F 36
	8E30 E8 3F F7 70 2F 6F 98 3F 9F E0 16 5F C0 2F BF 20
	8E40 57 E0 E0 79 F6 F0 3E 7B 70 0F FB F8 03 F8 F8 00
	8E50 70 30 00 00 00 00 00 00 FF CB FF FE 04 FF F8 07
	8E60 33 F6 1F CD EF FB ED EF FF F3 DF FE F7 DF FC 3B
	8E70 BF FC 1B AE CE 0B DF 36 0B BF F7 07 AF 6F 83 BF
	8E80 9F E7 D6 5F DF AF BF 2F 57 E0 EF 79 F6 F7 BE 7B
	8E90 77 CF FB FB F3 F8 FB FC 77 37 FF 8F CF FF FF FF

         ........................
         ..........@@.@..........
         .......@@@@..@@@........
         .....@@....@@@@@@@..@@..
         ....@@@@@@@@@.@@@@@.@@..
         ....@@@@@@@@@@@@@@@@....
         ...@@@@@@@@@@@@.@@@@....
         ...@@@@@@@@@@@.@..@@@...
         ..@@@@@@@@@@@@..@@.@@...
         ..@.@@@.@@..@@@.@@@.@...
         ...@@@@@..@@.@@.@@@.@...
         ..@@@@@@@@@@.@@@.@@@....
         ..@.@@@@.@@.@@@@@..@@...
         ..@@@@@@@..@@@@@@@@.....
         ...@.@@..@.@@@@@@@......
         ..@.@@@@@.@@@@@@..@.....
         .@.@.@@@@@@.....@@@.....
         .@@@@..@@@@@.@@.@@@@....
         ..@@@@@..@@@@.@@.@@@....
         ....@@@@@@@@@.@@@@@@@...
         ......@@@@@@@...@@@@@...
         .........@@@......@@....
         ........................
         ........................

         @@@@@@@@@@..@.@@@@@@@@@@
         @@@@@@@......@..@@@@@@@@
         @@@@@........@@@..@@..@@
         @@@@.@@....@@@@@@@..@@.@
         @@@.@@@@@@@@@.@@@@@.@@.@
         @@@.@@@@@@@@@@@@@@@@..@@
         @@.@@@@@@@@@@@@.@@@@.@@@
         @@.@@@@@@@@@@@....@@@.@@
         @.@@@@@@@@@@@@.....@@.@@
         @.@.@@@.@@..@@@.....@.@@
         @@.@@@@@..@@.@@.....@.@@
         @.@@@@@@@@@@.@@@.....@@@
         @.@.@@@@.@@.@@@@@.....@@
         @.@@@@@@@..@@@@@@@@..@@@
         @@.@.@@..@.@@@@@@@.@@@@@
         @.@.@@@@@.@@@@@@..@.@@@@
         .@.@.@@@@@@.....@@@.@@@@
         .@@@@..@@@@@.@@.@@@@.@@@
         @.@@@@@..@@@@.@@.@@@.@@@
         @@..@@@@@@@@@.@@@@@@@.@@
         @@@@..@@@@@@@...@@@@@.@@
         @@@@@@...@@@.@@@..@@.@@@
         @@@@@@@@@...@@@@@@..@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

			; SPR_HEELSB3:     EQU $1D	3x24
	8EA0 00 00 00 00 34 00 01 E7 00 06 1F D0 0F FB E0 0F
	8EB0 FF F0 1F FE F0 1F FD 38 3F FC D8 2E 7D D8 1F BD
	8EC0 D8 3F DD D0 2E 5D B0 3F BB 60 16 BA C0 0F 7D 00
	8ED0 03 F0 C0 04 FB C0 0B 3D 80 0F EE 00 03 FF 00 00
	8EE0 7F 00 00 0E 00 00 00 00 FF CB FF FE 04 FF F8 07
	8EF0 2F F6 1F D7 EF FB EF EF FF F7 DF FE F7 DF FC 3B
	8F00 BF FC 1B AE 7C 1B DF BC 1B BF DC 17 AE 5C 37 BF
	8F10 B8 6F D6 B8 DF EF 7D 3F F3 F0 DF F4 FB DF EB 3D
	8F20 BF EF EE 7F F3 FF 7F FC 7F 7F FF 8E FF FF F1 FF

         ........................
         ..........@@.@..........
         .......@@@@..@@@........
         .....@@....@@@@@@@.@....
         ....@@@@@@@@@.@@@@@.....
         ....@@@@@@@@@@@@@@@@....
         ...@@@@@@@@@@@@.@@@@....
         ...@@@@@@@@@@@.@..@@@...
         ..@@@@@@@@@@@@..@@.@@...
         ..@.@@@..@@@@@.@@@.@@...
         ...@@@@@@.@@@@.@@@.@@...
         ..@@@@@@@@.@@@.@@@.@....
         ..@.@@@..@.@@@.@@.@@....
         ..@@@@@@@.@@@.@@.@@.....
         ...@.@@.@.@@@.@.@@......
         ....@@@@.@@@@@.@........
         ......@@@@@@....@@......
         .....@..@@@@@.@@@@......
         ....@.@@..@@@@.@@.......
         ....@@@@@@@.@@@.........
         ......@@@@@@@@@@........
         .........@@@@@@@........
         ............@@@.........
         ........................

         @@@@@@@@@@..@.@@@@@@@@@@
         @@@@@@@......@..@@@@@@@@
         @@@@@........@@@..@.@@@@
         @@@@.@@....@@@@@@@.@.@@@
         @@@.@@@@@@@@@.@@@@@.@@@@
         @@@.@@@@@@@@@@@@@@@@.@@@
         @@.@@@@@@@@@@@@.@@@@.@@@
         @@.@@@@@@@@@@@....@@@.@@
         @.@@@@@@@@@@@@.....@@.@@
         @.@.@@@..@@@@@.....@@.@@
         @@.@@@@@@.@@@@.....@@.@@
         @.@@@@@@@@.@@@.....@.@@@
         @.@.@@@..@.@@@....@@.@@@
         @.@@@@@@@.@@@....@@.@@@@
         @@.@.@@.@.@@@...@@.@@@@@
         @@@.@@@@.@@@@@.@..@@@@@@
         @@@@..@@@@@@....@@.@@@@@
         @@@@.@..@@@@@.@@@@.@@@@@
         @@@.@.@@..@@@@.@@.@@@@@@
         @@@.@@@@@@@.@@@..@@@@@@@
         @@@@..@@@@@@@@@@.@@@@@@@
         @@@@@@...@@@@@@@.@@@@@@@
         @@@@@@@@@...@@@.@@@@@@@@
         @@@@@@@@@@@@...@@@@@@@@@

img_head_0:
				; SPR_HEAD1:     EQU $1E	3x24
				; (This is also the one used on the main menu and
				; on the crown ("Salute") screen)
	8F30 00 00 00 00 7C 00 01 FF 00 03 FF 80 07 FE 40 07
	8F40 F3 C0 0F EF E0 0F FF 78 0F FB 44 0F FB 82 17 FF
	8F50 82 1B FF 02 37 FE 82 77 7E 04 2F 76 04 2E E7 1C
	8F60 2F 38 FC 77 CF 98 1B B6 00 0C F8 00 08 58 00 00
	8F70 30 00 00 00 00 00 00 00 FF 83 FF FE 7C FF FD FF
	8F80 7F FB FF BF F7 FE 5F F7 F3 DF EF EF EF EF FF 7F
	8F90 EF FB 47 EF FB 83 C7 FF 83 C3 FF 03 87 FE 83 07
	8FA0 7E 07 8F 76 07 8E E7 19 8F 38 E1 07 CF 83 83 86
	8FB0 67 E0 81 FF E3 03 FF F7 87 FF FF CF FF FF FF FF

         ........................
         .........@@@@@..........
         .......@@@@@@@@@........
         ......@@@@@@@@@@@.......
         .....@@@@@@@@@@..@......
         .....@@@@@@@..@@@@......
         ....@@@@@@@.@@@@@@@.....
         ....@@@@@@@@@@@@.@@@@...
         ....@@@@@@@@@.@@.@...@..
         ....@@@@@@@@@.@@@.....@.
         ...@.@@@@@@@@@@@@.....@.
         ...@@.@@@@@@@@@@......@.
         ..@@.@@@@@@@@@@.@.....@.
         .@@@.@@@.@@@@@@......@..
         ..@.@@@@.@@@.@@......@..
         ..@.@@@.@@@..@@@...@@@..
         ..@.@@@@..@@@...@@@@@@..
         .@@@.@@@@@..@@@@@..@@...
         ...@@.@@@.@@.@@.........
         ....@@..@@@@@...........
         ....@....@.@@...........
         ..........@@............
         ........................
         ........................

         @@@@@@@@@.....@@@@@@@@@@
         @@@@@@@..@@@@@..@@@@@@@@
         @@@@@@.@@@@@@@@@.@@@@@@@
         @@@@@.@@@@@@@@@@@.@@@@@@
         @@@@.@@@@@@@@@@..@.@@@@@
         @@@@.@@@@@@@..@@@@.@@@@@
         @@@.@@@@@@@.@@@@@@@.@@@@
         @@@.@@@@@@@@@@@@.@@@@@@@
         @@@.@@@@@@@@@.@@.@...@@@
         @@@.@@@@@@@@@.@@@.....@@
         @@...@@@@@@@@@@@@.....@@
         @@....@@@@@@@@@@......@@
         @....@@@@@@@@@@.@.....@@
         .....@@@.@@@@@@......@@@
         @...@@@@.@@@.@@......@@@
         @...@@@.@@@..@@@...@@..@
         @...@@@@..@@@...@@@....@
         .....@@@@@..@@@@@.....@@
         @.....@@@....@@..@@..@@@
         @@@.....@......@@@@@@@@@
         @@@...@@......@@@@@@@@@@
         @@@@.@@@@....@@@@@@@@@@@
         @@@@@@@@@@..@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

			; SPR_HEAD2:     EQU $1F	3x24
	8FC0 00 00 00 00 7C 00 01 FF 00 03 FF 80 07 FC 80 07
	8FD0 E7 C0 0F DF C0 0F FE F0 0F F6 88 0F F7 04 17 FF
	8FE0 04 77 FE 04 2F FD 04 2E FC 08 2E EC 0C 5D CF 3E
	8FF0 1E F0 DE 0F 3F 8C 16 DE 00 1B E0 00 05 60 00 00
	9000 C0 00 00 00 00 00 00 00

         ........................
         .........@@@@@..........
         .......@@@@@@@@@........
         ......@@@@@@@@@@@.......
         .....@@@@@@@@@..@.......
         .....@@@@@@..@@@@@......
         ....@@@@@@.@@@@@@@......
         ....@@@@@@@@@@@.@@@@....
         ....@@@@@@@@.@@.@...@...
         ....@@@@@@@@.@@@.....@..
         ...@.@@@@@@@@@@@.....@..
         .@@@.@@@@@@@@@@......@..
         ..@.@@@@@@@@@@.@.....@..
         ..@.@@@.@@@@@@......@...
         ..@.@@@.@@@.@@......@@..
         .@.@@@.@@@..@@@@..@@@@@.
         ...@@@@.@@@@....@@.@@@@.
         ....@@@@..@@@@@@@...@@..
         ...@.@@.@@.@@@@.........
         ...@@.@@@@@.............
         .....@.@.@@.............
         ........@@..............
         ........................
         ........................

	9008 FF 83 FF FE 7C FF FD FF 7F FB FF BF F7 FC* BF F7
	9018 E7 DF EF DF DF EF FE FF EF F6 8F EF F7 07 87 FF
	9028 07 07 FE 07 8F FD 07 8E FC 0B 8E EC 09 1D CF 30
	9038 9E F0 C0 EF 3F A1 C6 1E 73 C2 01 FF E0 0F FF FA
	9048 1F FF FF 3F FF FF FF FF

         @@@@@@@@@.....@@@@@@@@@@
         @@@@@@@..@@@@@..@@@@@@@@
         @@@@@@.@@@@@@@@@.@@@@@@@
         @@@@@.@@@@@@@@@@@.@@@@@@
         @@@@.@@@@@@@@@..@.@@@@@@
         @@@@.@@@@@@..@@@@@.@@@@@
         @@@.@@@@@@.@@@@@@@.@@@@@
         @@@.@@@@@@@@@@@.@@@@@@@@
         @@@.@@@@@@@@.@@.@...@@@@
         @@@.@@@@@@@@.@@@.....@@@
         @....@@@@@@@@@@@.....@@@
         .....@@@@@@@@@@......@@@
         @...@@@@@@@@@@.@.....@@@
         @...@@@.@@@@@@......@.@@
         @...@@@.@@@.@@......@..@
         ...@@@.@@@..@@@@..@@....
         @..@@@@.@@@@....@@......
         @@@.@@@@..@@@@@@@.@....@
         @@...@@....@@@@..@@@..@@
         @@....@........@@@@@@@@@
         @@@.........@@@@@@@@@@@@
         @@@@@.@....@@@@@@@@@@@@@
         @@@@@@@@..@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

			; SPR_HEAD3:     EQU $20	3x24
	9050 00 00 00 00 7C 00 01 FF 00 03 FF 80 07 FF 40 07
	9060 F9 C0 0F F7 E0 0F FF BC 0F FD A2 0F FD C1 07 FF
	9070 C1 09 FF 81 0B FF 41 1B BF 02 0B BB 02 0B B3 8C
	9080 0B BC 78 1B DF 80 05 E6 00 06 D8 00 07 7C 00 00
	9090 2C 00 00 18 00 00 00 00 FF 83 FF FE 7C FF FD FF
	90A0 7F FB FF BF F7 FF 5F F7 F9 DF EF F7 EF EF FF BF
	90B0 EF FD A3 EF FD C1 F7 FF C1 E1 FF 81 E3 FF 41 C3
	90C0 BF 03 E3 BB 03 E3 B3 8F E3 BC 73 C3 DF 87 E1 E6
	90D0 7F F0 C1 FF F0 41 FF F8 81 FF FF C3 FF FF E7 FF

         ........................
         .........@@@@@..........
         .......@@@@@@@@@........
         ......@@@@@@@@@@@.......
         .....@@@@@@@@@@@.@......
         .....@@@@@@@@..@@@......
         ....@@@@@@@@.@@@@@@.....
         ....@@@@@@@@@@@@@.@@@@..
         ....@@@@@@@@@@.@@.@...@.
         ....@@@@@@@@@@.@@@.....@
         .....@@@@@@@@@@@@@.....@
         ....@..@@@@@@@@@@......@
         ....@.@@@@@@@@@@.@.....@
         ...@@.@@@.@@@@@@......@.
         ....@.@@@.@@@.@@......@.
         ....@.@@@.@@..@@@...@@..
         ....@.@@@.@@@@...@@@@...
         ...@@.@@@@.@@@@@@.......
         .....@.@@@@..@@.........
         .....@@.@@.@@...........
         .....@@@.@@@@@..........
         ..........@.@@..........
         ...........@@...........
         ........................

         @@@@@@@@@.....@@@@@@@@@@
         @@@@@@@..@@@@@..@@@@@@@@
         @@@@@@.@@@@@@@@@.@@@@@@@
         @@@@@.@@@@@@@@@@@.@@@@@@
         @@@@.@@@@@@@@@@@.@.@@@@@
         @@@@.@@@@@@@@..@@@.@@@@@
         @@@.@@@@@@@@.@@@@@@.@@@@
         @@@.@@@@@@@@@@@@@.@@@@@@
         @@@.@@@@@@@@@@.@@.@...@@
         @@@.@@@@@@@@@@.@@@.....@
         @@@@.@@@@@@@@@@@@@.....@
         @@@....@@@@@@@@@@......@
         @@@...@@@@@@@@@@.@.....@
         @@....@@@.@@@@@@......@@
         @@@...@@@.@@@.@@......@@
         @@@...@@@.@@..@@@...@@@@
         @@@...@@@.@@@@...@@@..@@
         @@....@@@@.@@@@@@....@@@
         @@@....@@@@..@@..@@@@@@@
         @@@@....@@.....@@@@@@@@@
         @@@@.....@.....@@@@@@@@@
         @@@@@...@......@@@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@
         @@@@@@@@@@@..@@@@@@@@@@@

			; SPR_HEADB1:     EQU $21	3x24
	90E0 00 00 00 00 00 00 0F 3E 00 10 FF 80 21 FF C0 23
	90F0 FF E0 23 FF E0 27 FE F0 17 BF F0 17 5F F0 0C DF
	9100 F4 03 6F F0 07 77 F0 07 6F F0 0B 6F F4 3F 6F E8
	9110 7E F7 E0 69 CF C0 37 BF 80 01 3E 00 00 00 00 00
	9120 00 00 00 00 00 00 00 00 FF FF FF FF C1 FF FF 3E
	9130 7F F0 FF BF E1 FF DF E3 FF EF E3 FF EF E7 FE F7
	9140 F7 BF F7 F7 1F F3 FC 1F F1 FB 0F F3 F7 07 F7 F7
	9150 0F F3 CB 0F F1 8F 0F E3 06 07 E7 00 0F DF 80 3F
	9160 BF C8 3E 7F FE C1 FF FF FF FF FF FF FF FF FF FF

         ........................
         ........................
         ....@@@@..@@@@@.........
         ...@....@@@@@@@@@.......
         ..@....@@@@@@@@@@@......
         ..@...@@@@@@@@@@@@@.....
         ..@...@@@@@@@@@@@@@.....
         ..@..@@@@@@@@@@.@@@@....
         ...@.@@@@.@@@@@@@@@@....
         ...@.@@@.@.@@@@@@@@@....
         ....@@..@@.@@@@@@@@@.@..
         ......@@.@@.@@@@@@@@....
         .....@@@.@@@.@@@@@@@....
         .....@@@.@@.@@@@@@@@....
         ....@.@@.@@.@@@@@@@@.@..
         ..@@@@@@.@@.@@@@@@@.@...
         .@@@@@@.@@@@.@@@@@@.....
         .@@.@..@@@..@@@@@@......
         ..@@.@@@@.@@@@@@@.......
         .......@..@@@@@.........
         ........................
         ........................
         ........................
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@.....@@@@@@@@@
         @@@@@@@@..@@@@@..@@@@@@@
         @@@@....@@@@@@@@@.@@@@@@
         @@@....@@@@@@@@@@@.@@@@@
         @@@...@@@@@@@@@@@@@.@@@@
         @@@...@@@@@@@@@@@@@.@@@@
         @@@..@@@@@@@@@@.@@@@.@@@
         @@@@.@@@@.@@@@@@@@@@.@@@
         @@@@.@@@...@@@@@@@@@..@@
         @@@@@@.....@@@@@@@@@...@
         @@@@@.@@....@@@@@@@@..@@
         @@@@.@@@.....@@@@@@@.@@@
         @@@@.@@@....@@@@@@@@..@@
         @@..@.@@....@@@@@@@@...@
         @...@@@@....@@@@@@@...@@
         .....@@......@@@@@@..@@@
         ............@@@@@@.@@@@@
         @.........@@@@@@@.@@@@@@
         @@..@.....@@@@@..@@@@@@@
         @@@@@@@.@@.....@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

			; SPR_HEADB2:     EQU $22	3x24
	9170 00 00 00 00 00 00 1E 3E 00 21 FF 80 41 FF C0 43
	9180 FF E0 43 FF E0 47 7F 70 26 BF F0 25 CF F0 14 77
	9190 F0 0B B7 F0 03 D7 F0 03 D7 F0 01 DB F0 07 B7 E0
	91A0 0F 6F E0 1E EF C0 1A 2F 80 0C 1E 00 00 00 00 00
	91B0 00 00 00 00 00 00 00 00 FF FF FF FF C1 FF FE 3E
	91C0 7F E1 FF BF C1 FF DF C3 FF EF C3 FF EF C7 7F 77
	91D0 E6 3F F7 E4 0F F7 F4 07 F7 FB 87 F7 FB C7 F7 FB
	91E0 C7 F7 F9 C3 F7 F7 87 EF E3 0F EF C0 0F DF C0 0F
	91F0 BF E1 DE 7F F3 E1 FF FF FF FF FF FF FF FF FF FF

         ........................
         ........................
         ...@@@@...@@@@@.........
         ..@....@@@@@@@@@@.......
         .@.....@@@@@@@@@@@......
         .@....@@@@@@@@@@@@@.....
         .@....@@@@@@@@@@@@@.....
         .@...@@@.@@@@@@@.@@@....
         ..@..@@.@.@@@@@@@@@@....
         ..@..@.@@@..@@@@@@@@....
         ...@.@...@@@.@@@@@@@....
         ....@.@@@.@@.@@@@@@@....
         ......@@@@.@.@@@@@@@....
         ......@@@@.@.@@@@@@@....
         .......@@@.@@.@@@@@@....
         .....@@@@.@@.@@@@@@.....
         ....@@@@.@@.@@@@@@@.....
         ...@@@@.@@@.@@@@@@......
         ...@@.@...@.@@@@@.......
         ....@@.....@@@@.........
         ........................
         ........................
         ........................
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@.....@@@@@@@@@
         @@@@@@@...@@@@@..@@@@@@@
         @@@....@@@@@@@@@@.@@@@@@
         @@.....@@@@@@@@@@@.@@@@@
         @@....@@@@@@@@@@@@@.@@@@
         @@....@@@@@@@@@@@@@.@@@@
         @@...@@@.@@@@@@@.@@@.@@@
         @@@..@@...@@@@@@@@@@.@@@
         @@@..@......@@@@@@@@.@@@
         @@@@.@.......@@@@@@@.@@@
         @@@@@.@@@....@@@@@@@.@@@
         @@@@@.@@@@...@@@@@@@.@@@
         @@@@@.@@@@...@@@@@@@.@@@
         @@@@@..@@@....@@@@@@.@@@
         @@@@.@@@@....@@@@@@.@@@@
         @@@...@@....@@@@@@@.@@@@
         @@..........@@@@@@.@@@@@
         @@..........@@@@@.@@@@@@
         @@@....@@@.@@@@..@@@@@@@
         @@@@..@@@@@....@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

			; SPR_HEADB3:     EQU $23	3x24
	9200 00 00 00 00 00 00 07 3E 00 08 FF 80 11 FF C0 13
	9210 FF E0 13 FF E8 17 FD F0 0F 7F F0 0E BF F6 01 BF
	9220 F4 06 DF F0 0E EF F4 0E DF F6 2E DF F4 7E DF E8
	9230 6D EF E0 33 1F C0 02 FF 80 00 3E 00 00 00 00 00
	9240 00 00 00 00 00 00 00 00 FF FF FF FF C1 FF FF 3E
	9250 7F F8 FF BF F1 FF DF F3 FF E7 F3 FF E3 F7 FD F7
	9260 FF 7F F1 FE 3F F0 F8 3F F1 F6 1F F3 EE 0F F1 CE
	9270 1F F0 8E 1F F1 0E 1F E3 0C 0F E7 80 1F DF C8 FF
	9280 BF FD 3E 7F FF C1 FF FF FF FF FF FF FF FF FF FF

         ........................
         ........................
         .....@@@..@@@@@.........
         ....@...@@@@@@@@@.......
         ...@...@@@@@@@@@@@......
         ...@..@@@@@@@@@@@@@.....
         ...@..@@@@@@@@@@@@@.@...
         ...@.@@@@@@@@@.@@@@@....
         ....@@@@.@@@@@@@@@@@....
         ....@@@.@.@@@@@@@@@@.@@.
         .......@@.@@@@@@@@@@.@..
         .....@@.@@.@@@@@@@@@....
         ....@@@.@@@.@@@@@@@@.@..
         ....@@@.@@.@@@@@@@@@.@@.
         ..@.@@@.@@.@@@@@@@@@.@..
         .@@@@@@.@@.@@@@@@@@.@...
         .@@.@@.@@@@.@@@@@@@.....
         ..@@..@@...@@@@@@@......
         ......@.@@@@@@@@@.......
         ..........@@@@@.........
         ........................
         ........................
         ........................
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@.....@@@@@@@@@
         @@@@@@@@..@@@@@..@@@@@@@
         @@@@@...@@@@@@@@@.@@@@@@
         @@@@...@@@@@@@@@@@.@@@@@
         @@@@..@@@@@@@@@@@@@..@@@
         @@@@..@@@@@@@@@@@@@...@@
         @@@@.@@@@@@@@@.@@@@@.@@@
         @@@@@@@@.@@@@@@@@@@@...@
         @@@@@@@...@@@@@@@@@@....
         @@@@@.....@@@@@@@@@@...@
         @@@@.@@....@@@@@@@@@..@@
         @@@.@@@.....@@@@@@@@...@
         @@..@@@....@@@@@@@@@....
         @...@@@....@@@@@@@@@...@
         ....@@@....@@@@@@@@...@@
         ....@@......@@@@@@@..@@@
         @..........@@@@@@@.@@@@@
         @@..@...@@@@@@@@@.@@@@@@
         @@@@@@.@..@@@@@..@@@@@@@
         @@@@@@@@@@.....@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

						; SPR_VAPE1:      EQU $24
	9290 00 00 00 00 00 00 00 1D 80 07 BE 80 0F DE 78 0F
	92A0 C0 FC 0F 9C 7C 0F 7B BC 06 F7 DC 18 F7 D8 3D FB
	92B0 A4 3D 9C 6E 38 6F EE 17 AF 0E 0F DE F4 0F DD F8
	92C0 2F DD F8 2F D1 F8 07 AD F8 30 5E F0 36 DF 00 03
	92D0 0E 00 00 00 00 00 00 00 FF FF FF FF E2 7F F8 5C
	92E0 3F F7 BE 07 EF DE 7B EF C0 FD EF 94 7D EF 2B BD
	92F0 E6 57 DD C0 A7 DB 81 53 81 80 88 20 80 65 40 C7
	9300 AA 00 EF D4 F1 CF C9 FB AF D5 FB AF C1 FB C7 A1
	9310 FB B0 40 F7 B0 C0 0F C8 20 FF FC F1 FF FF FF FF

         ........................
         ........................
         ...........@@@.@@.......
         .....@@@@.@@@@@.@.......
         ....@@@@@@.@@@@..@@@@...
         ....@@@@@@......@@@@@@..
         ....@@@@@..@@@...@@@@@..
         ....@@@@.@@@@.@@@.@@@@..
         .....@@.@@@@.@@@@@.@@@..
         ...@@...@@@@.@@@@@.@@...
         ..@@@@.@@@@@@.@@@.@..@..
         ..@@@@.@@..@@@...@@.@@@.
         ..@@@....@@.@@@@@@@.@@@.
         ...@.@@@@.@.@@@@....@@@.
         ....@@@@@@.@@@@.@@@@.@..
         ....@@@@@@.@@@.@@@@@@...
         ..@.@@@@@@.@@@.@@@@@@...
         ..@.@@@@@@.@...@@@@@@...
         .....@@@@.@.@@.@@@@@@...
         ..@@.....@.@@@@.@@@@....
         ..@@.@@.@@.@@@@@........
         ......@@....@@@.........
         ........................
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@...@..@@@@@@@
         @@@@@....@.@@@....@@@@@@
         @@@@.@@@@.@@@@@......@@@
         @@@.@@@@@@.@@@@..@@@@.@@
         @@@.@@@@@@......@@@@@@.@
         @@@.@@@@@..@.@...@@@@@.@
         @@@.@@@@..@.@.@@@.@@@@.@
         @@@..@@..@.@.@@@@@.@@@.@
         @@......@.@..@@@@@.@@.@@
         @......@.@.@..@@@......@
         @.......@...@.....@.....
         @........@@..@.@.@......
         @@...@@@@.@.@.@.........
         @@@.@@@@@@.@.@..@@@@...@
         @@..@@@@@@..@..@@@@@@.@@
         @.@.@@@@@@.@.@.@@@@@@.@@
         @.@.@@@@@@.....@@@@@@.@@
         @@...@@@@.@....@@@@@@.@@
         @.@@.....@......@@@@.@@@
         @.@@....@@..........@@@@
         @@..@.....@.....@@@@@@@@
         @@@@@@..@@@@...@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

						; SPR_VAPE2:      EQU $25
	9320 00 00 00 00 00 00 00 00 00 00 1C 80 03 BE 00 07
	9330 DE 70 07 C0 F8 07 BB 78 03 77 B8 00 F7 B0 18 FB
	9340 08 3C 50 3C 3C 2F BC 1B 9F D8 07 DF 00 07 DE E0
	9350 27 CD F0 03 81 F0 00 0C E0 13 5E 00 03 0C 00 00
	9360 00 00 00 00 00 00 00 00 FF FF FF FF FF FF FF E3
	9370 7F FC 5C 3F FB BE 0F F7 DE 77 F7 C0 FB F7 AB 7B
	9380 FB 57 BB E4 A7 B7 C2 53 43 81 00 01 80 25 01 C3
	9390 8A 83 E7 D5 07 D7 CA EF A7 C5 F7 DB B1 F7 EC 20
	93A0 EF D0 40 1F E8 21 FF FC F3 FF FF FF FF FF FF FF

         ........................
         ........................
         ........................
         ...........@@@..@.......
         ......@@@.@@@@@.........
         .....@@@@@.@@@@..@@@....
         .....@@@@@......@@@@@...
         .....@@@@.@@@.@@.@@@@...
         ......@@.@@@.@@@@.@@@...
         ........@@@@.@@@@.@@....
         ...@@...@@@@@.@@....@...
         ..@@@@...@.@......@@@@..
         ..@@@@....@.@@@@@.@@@@..
         ...@@.@@@..@@@@@@@.@@...
         .....@@@@@.@@@@@........
         .....@@@@@.@@@@.@@@.....
         ..@..@@@@@..@@.@@@@@....
         ......@@@......@@@@@....
         ............@@..@@@.....
         ...@..@@.@.@@@@.........
         ......@@....@@..........
         ........................
         ........................
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@...@@.@@@@@@@
         @@@@@@...@.@@@....@@@@@@
         @@@@@.@@@.@@@@@.....@@@@
         @@@@.@@@@@.@@@@..@@@.@@@
         @@@@.@@@@@......@@@@@.@@
         @@@@.@@@@.@.@.@@.@@@@.@@
         @@@@@.@@.@.@.@@@@.@@@.@@
         @@@..@..@.@..@@@@.@@.@@@
         @@....@..@.@..@@.@....@@
         @......@...............@
         @.........@..@.@.......@
         @@....@@@...@.@.@.....@@
         @@@..@@@@@.@.@.@.....@@@
         @@.@.@@@@@..@.@.@@@.@@@@
         @.@..@@@@@...@.@@@@@.@@@
         @@.@@.@@@.@@...@@@@@.@@@
         @@@.@@....@.....@@@.@@@@
         @@.@.....@.........@@@@@
         @@@.@.....@....@@@@@@@@@
         @@@@@@..@@@@..@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

						; SPR_VAPE3:      EQU $26
	93B0 00 00 00 00 00 00 00 00 00 00 08 00 00 1C 00 01
	93C0 08 00 03 80 20 01 00 70 00 33 20 00 7B 00 00 78
	93D0 00 18 30 18 18 03 18 00 07 80 01 07 80 03 83 00
	93E0 01 00 C0 00 00 C0 00 0C 00 01 0C 00 00 00 00 00
	93F0 00 00 00 00 00 00 00 00 FF FF FF FF FF FF FF F7
	9400 FF FF EB FF FE DD FF FD 6B DF FB B7 AF FD 4C 77
	9410 FE A3 2F FF 53 5F E7 28 E7 C3 94 C3 C3 C9 43 E6
	9420 F2 A7 FD 75 3F FB BA 3F FD 7C DF FE F2 DF FE E1
	9430 3F FC 61 FF FE F3 FF FF FF FF FF FF FF FF FF FF

         ........................
         ........................
         ........................
         ............@...........
         ...........@@@..........
         .......@....@...........
         ......@@@.........@.....
         .......@.........@@@....
         ..........@@..@@..@.....
         .........@@@@.@@........
         .........@@@@...........
         ...@@.....@@.......@@...
         ...@@.........@@...@@...
         .............@@@@.......
         .......@.....@@@@.......
         ......@@@.....@@........
         .......@........@@......
         ................@@......
         ............@@..........
         .......@....@@..........
         ........................
         ........................
         ........................
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@.@@@@@@@@@@@
         @@@@@@@@@@@.@.@@@@@@@@@@
         @@@@@@@.@@.@@@.@@@@@@@@@
         @@@@@@.@.@@.@.@@@@.@@@@@
         @@@@@.@@@.@@.@@@@.@.@@@@
         @@@@@@.@.@..@@...@@@.@@@
         @@@@@@@.@.@...@@..@.@@@@
         @@@@@@@@.@.@..@@.@.@@@@@
         @@@..@@@..@.@...@@@..@@@
         @@....@@@..@.@..@@....@@
         @@....@@@@..@..@.@....@@
         @@@..@@.@@@@..@.@.@..@@@
         @@@@@@.@.@@@.@.@..@@@@@@
         @@@@@.@@@.@@@.@...@@@@@@
         @@@@@@.@.@@@@@..@@.@@@@@
         @@@@@@@.@@@@..@.@@.@@@@@
         @@@@@@@.@@@....@..@@@@@@
         @@@@@@...@@....@@@@@@@@@
         @@@@@@@.@@@@..@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

							; SPR_PURSE:      EQU $27
	9440 00 00 00 00 00 00 00 13 00 00 38 E0 00 3B F0 01
	9450 D7 10 07 3C E0 0C F3 F0 0B CF F4 0B BE 74 0B 7D
	9460 B6 2B 3D AE 2B 5E 6E 6F 67 9D 6B 38 71 66 BF C2
	9470 80 DF 0E 88 5C 3C 7E 20 F8 3F A3 E0 3F DF 80 1F
	9480 BC 00 07 40 00 00 00 00 FF FF FF FF EC FF FF D3
	9490 1F FF B8 EF FE 3B F7 F9 D7 17 F7 3C 0F EC F0 03
	94A0 EB C0 01 EB 80 01 CB 01 80 8B 01 80 8B 00 00 0F
	94B0 00 00 0B 00 00 06 00 00 00 00 00 00 00 01 00 00
	94C0 03 80 00 07 80 00 1F C0 00 7F E0 03 FF F8 BF FF

         ........................
         ........................
         ...........@..@@........
         ..........@@@...@@@.....
         ..........@@@.@@@@@@....
         .......@@@.@.@@@...@....
         .....@@@..@@@@..@@@.....
         ....@@..@@@@..@@@@@@....
         ....@.@@@@..@@@@@@@@.@..
         ....@.@@@.@@@@@..@@@.@..
         ....@.@@.@@@@@.@@.@@.@@.
         ..@.@.@@..@@@@.@@.@.@@@.
         ..@.@.@@.@.@@@@..@@.@@@.
         .@@.@@@@.@@..@@@@..@@@.@
         .@@.@.@@..@@@....@@@...@
         .@@..@@.@.@@@@@@@@....@.
         @.......@@.@@@@@....@@@.
         @...@....@.@@@....@@@@..
         .@@@@@@...@.....@@@@@...
         ..@@@@@@@.@...@@@@@.....
         ..@@@@@@@@.@@@@@@.......
         ...@@@@@@.@@@@..........
         .....@@@.@..............
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@.@@..@@@@@@@@
         @@@@@@@@@@.@..@@...@@@@@
         @@@@@@@@@.@@@...@@@.@@@@
         @@@@@@@...@@@.@@@@@@.@@@
         @@@@@..@@@.@.@@@...@.@@@
         @@@@.@@@..@@@@......@@@@
         @@@.@@..@@@@..........@@
         @@@.@.@@@@.............@
         @@@.@.@@@..............@
         @@..@.@@.......@@.......
         @...@.@@.......@@.......
         @...@.@@................
         ....@@@@................
         ....@.@@................
         .....@@.................
         ........................
         .......................@
         ......................@@
         @....................@@@
         @..................@@@@@
         @@...............@@@@@@@
         @@@...........@@@@@@@@@@
         @@@@@...@.@@@@@@@@@@@@@@

							; SPR_HOOTER:     EQU $28
	94D0 00 00 00 03 C0 00 07 F0 00 16 78 00 20 B8 00 20
	94E0 3C 00 10 DD 00 2D 99 80 20 E7 00 11 30 80 2C CF
	94F0 00 21 1E F8 11 DD 8C 11 DF 3E 0F EA 5E 01 F6 DA
	9500 01 FA 3E 01 FB 76 01 FD 8C 00 FE F8 01 3C 00 00
	9510 C3 00 00 3C 00 00 00 00 FC 3F FF FB CF FF F7 F7
	9520 FF F6 7B FF E0 BB FF E0 3C FF F0 1C 7F EC 18 3F
	9530 E0 00 7F F1 00 BF EC CF 07 E0 1E FB F0 1D 8D F0
	9540 1F 3E FE 0A 1E FC 06 1A FC 02 3E FC 03 76 FC 01
	9550 8D FE 00 FB FD 00 07 FE C3 7F FF 3C FF FF C3 FF

         ........................
         ......@@@@..............
         .....@@@@@@@............
         ...@.@@..@@@@...........
         ..@.....@.@@@...........
         ..@.......@@@@..........
         ...@....@@.@@@.@........
         ..@.@@.@@..@@..@@.......
         ..@.....@@@..@@@........
         ...@...@..@@....@.......
         ..@.@@..@@..@@@@........
         ..@....@...@@@@.@@@@@...
         ...@...@@@.@@@.@@...@@..
         ...@...@@@.@@@@@..@@@@@.
         ....@@@@@@@.@.@..@.@@@@.
         .......@@@@@.@@.@@.@@.@.
         .......@@@@@@.@...@@@@@.
         .......@@@@@@.@@.@@@.@@.
         .......@@@@@@@.@@...@@..
         ........@@@@@@@.@@@@@...
         .......@..@@@@..........
         ........@@....@@........
         ..........@@@@..........
         ........................

         @@@@@@....@@@@@@@@@@@@@@
         @@@@@.@@@@..@@@@@@@@@@@@
         @@@@.@@@@@@@.@@@@@@@@@@@
         @@@@.@@..@@@@.@@@@@@@@@@
         @@@.....@.@@@.@@@@@@@@@@
         @@@.......@@@@..@@@@@@@@
         @@@@.......@@@...@@@@@@@
         @@@.@@.....@@.....@@@@@@
         @@@..............@@@@@@@
         @@@@...@........@.@@@@@@
         @@@.@@..@@..@@@@.....@@@
         @@@........@@@@.@@@@@.@@
         @@@@.......@@@.@@...@@.@
         @@@@.......@@@@@..@@@@@.
         @@@@@@@.....@.@....@@@@.
         @@@@@@.......@@....@@.@.
         @@@@@@........@...@@@@@.
         @@@@@@........@@.@@@.@@.
         @@@@@@.........@@...@@.@
         @@@@@@@.........@@@@@.@@
         @@@@@@.@.............@@@
         @@@@@@@.@@....@@.@@@@@@@
         @@@@@@@@..@@@@..@@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_DONUTS:     EQU $29
	9560 00 00 00 00 00 00 00 00 00 00 00 00 00 03 80 01
	9570 E6 60 03 B0 30 01 2F 30 1E DD 80 3A 19 78 31 EE
	9580 EC 2E 30 CC 59 AF 7A 72 DD A6 38 D9 9C 4E DE 72
	9590 73 89 CE 1C E7 38 07 3C E0 01 C3 80 00 7E 00 00
	95A0 18 00 00 00 00 00 00 00 FF FF FF FF FF FF FF FF
	95B0 FF FF FC 7F FE 18 1F FD E0 0F FB B0 87 E1 2F 07
	95C0 DE DD 87 BA 19 7B B1 EE ED A0 30 CD 00 2F 78 02
	95D0 1D A0 80 19 81 00 1E 00 00 08 00 80 00 01 E0 00
	95E0 07 F8 00 1F FE 00 7F FF 81 FF FF E7 FF FF FF FF

         ........................
         ........................
         ........................
         ........................
         ..............@@@.......
         .......@@@@..@@..@@.....
         ......@@@.@@......@@....
         .......@..@.@@@@..@@....
         ...@@@@.@@.@@@.@@.......
         ..@@@.@....@@..@.@@@@...
         ..@@...@@@@.@@@.@@@.@@..
         ..@.@@@...@@....@@..@@..
         .@.@@..@@.@.@@@@.@@@@.@.
         .@@@..@.@@.@@@.@@.@..@@.
         ..@@@...@@.@@..@@..@@@..
         .@..@@@.@@.@@@@..@@@..@.
         .@@@..@@@...@..@@@..@@@.
         ...@@@..@@@..@@@..@@@...
         .....@@@..@@@@..@@@.....
         .......@@@....@@@.......
         .........@@@@@@.........
         ...........@@...........
         ........................
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@...@@@@@@@
         @@@@@@@....@@......@@@@@
         @@@@@@.@@@@.........@@@@
         @@@@@.@@@.@@....@....@@@
         @@@....@..@.@@@@.....@@@
         @@.@@@@.@@.@@@.@@....@@@
         @.@@@.@....@@..@.@@@@.@@
         @.@@...@@@@.@@@.@@@.@@.@
         @.@.......@@....@@..@@.@
         ..........@.@@@@.@@@@...
         ......@....@@@.@@.@.....
         @..........@@..@@......@
         ...........@@@@.........
         ............@...........
         @......................@
         @@@..................@@@
         @@@@@..............@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@@@@@......@@@@@@@@@
         @@@@@@@@@@@..@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

							; SPR_BUNNY:      EQU $2A
	95F0 00 00 00 00 3C 00 00 F8 00 01 F0 F0 01 CF 38 03
	9600 BF D8 02 3F 00 01 F8 FE 07 F7 FC 0F EF F0 1B FF
	9610 C8 19 78 38 17 3D F0 21 FF 7C 28 FE 76 31 9F 0E
	9620 5B DF BE 6B BB BC 30 71 9C 00 0F 80 00 77 00 00
	9630 7E 00 00 38 00 00 00 00 FF C3 FF FF 3D FF FE FB
	9640 0F FD F0 F7 FD CF 3B FB BF DB FA 3F 01 F9 F8 FE
	9650 F7 F7 FD EF EF F3 DB FF CB D9 78 3B D7 3D F3 A1
	9660 FF 7D A0 FE 76 B1 9F 0E 5B DF BE 6B BB BD B4 71
	9670 9D CF 8F A3 FF 77 7F FF 7E FF FF B9 FF FF C7 FF

         ........................
         ..........@@@@..........
         ........@@@@@...........
         .......@@@@@....@@@@....
         .......@@@..@@@@..@@@...
         ......@@@.@@@@@@@@.@@...
         ......@...@@@@@@........
         .......@@@@@@...@@@@@@@.
         .....@@@@@@@.@@@@@@@@@..
         ....@@@@@@@.@@@@@@@@....
         ...@@.@@@@@@@@@@@@..@...
         ...@@..@.@@@@.....@@@...
         ...@.@@@..@@@@.@@@@@....
         ..@....@@@@@@@@@.@@@@@..
         ..@.@...@@@@@@@..@@@.@@.
         ..@@...@@..@@@@@....@@@.
         .@.@@.@@@@.@@@@@@.@@@@@.
         .@@.@.@@@.@@@.@@@.@@@@..
         ..@@.....@@@...@@..@@@..
         ............@@@@@.......
         .........@@@.@@@........
         .........@@@@@@.........
         ..........@@@...........
         ........................

         @@@@@@@@@@....@@@@@@@@@@
         @@@@@@@@..@@@@.@@@@@@@@@
         @@@@@@@.@@@@@.@@....@@@@
         @@@@@@.@@@@@....@@@@.@@@
         @@@@@@.@@@..@@@@..@@@.@@
         @@@@@.@@@.@@@@@@@@.@@.@@
         @@@@@.@...@@@@@@.......@
         @@@@@..@@@@@@...@@@@@@@.
         @@@@.@@@@@@@.@@@@@@@@@.@
         @@@.@@@@@@@.@@@@@@@@..@@
         @@.@@.@@@@@@@@@@@@..@.@@
         @@.@@..@.@@@@.....@@@.@@
         @@.@.@@@..@@@@.@@@@@..@@
         @.@....@@@@@@@@@.@@@@@.@
         @.@.....@@@@@@@..@@@.@@.
         @.@@...@@..@@@@@....@@@.
         .@.@@.@@@@.@@@@@@.@@@@@.
         .@@.@.@@@.@@@.@@@.@@@@.@
         @.@@.@...@@@...@@..@@@.@
         @@..@@@@@...@@@@@.@...@@
         @@@@@@@@.@@@.@@@.@@@@@@@
         @@@@@@@@.@@@@@@.@@@@@@@@
         @@@@@@@@@.@@@..@@@@@@@@@
         @@@@@@@@@@...@@@@@@@@@@@

							; SPR_SPRING:     EQU $2B
	9680 00 00 00 00 3C 00 01 FF 80 07 FF E0 0F FF F0 1F
	9690 FF F8 0F FF F0 17 FF E8 09 FF 90 06 3C 68 19 C3
	96A0 8C 30 3C 6C 30 40 1C 19 CE 38 0E 01 E4 13 CF 06
	96B0 30 78 66 30 00 0C 18 00 38 0E 01 E4 03 CF 0C 00
	96C0 78 00 00 00 00 00 00 00 FF C3 FF FE 3C 7F F9 DB
	96D0 9F F6 A5 6F ED 5A B7 DA A5 5B ED 5A B7 C6 A5 63
	96E0 E1 DB 87 E0 3C 0B D8 00 0D B6 00 6D B6 41 9D D9
	96F0 CE 3B EE 31 E5 D3 CF 16 B4 78 66 B7 87 8D D9 FE
	9700 3B EE 31 E5 F3 CF 0D FC 78 F3 FF 87 FF FF FF FF

         ........................
         ..........@@@@..........
         .......@@@@@@@@@@.......
         .....@@@@@@@@@@@@@@.....
         ....@@@@@@@@@@@@@@@@....
         ...@@@@@@@@@@@@@@@@@@...
         ....@@@@@@@@@@@@@@@@....
         ...@.@@@@@@@@@@@@@@.@...
         ....@..@@@@@@@@@@..@....
         .....@@...@@@@...@@.@...
         ...@@..@@@....@@@...@@..
         ..@@......@@@@...@@.@@..
         ..@@.....@.........@@@..
         ...@@..@@@..@@@...@@@...
         ....@@@........@@@@..@..
         ...@..@@@@..@@@@.....@@.
         ..@@.....@@@@....@@..@@.
         ..@@................@@..
         ...@@.............@@@...
         ....@@@........@@@@..@..
         ......@@@@..@@@@....@@..
         .........@@@@...........
         ........................
         ........................

         @@@@@@@@@@....@@@@@@@@@@
         @@@@@@@...@@@@...@@@@@@@
         @@@@@..@@@.@@.@@@..@@@@@
         @@@@.@@.@.@..@.@.@@.@@@@
         @@@.@@.@.@.@@.@.@.@@.@@@
         @@.@@.@.@.@..@.@.@.@@.@@
         @@@.@@.@.@.@@.@.@.@@.@@@
         @@...@@.@.@..@.@.@@...@@
         @@@....@@@.@@.@@@....@@@
         @@@.......@@@@......@.@@
         @@.@@...............@@.@
         @.@@.@@..........@@.@@.@
         @.@@.@@..@.....@@..@@@.@
         @@.@@..@@@..@@@...@@@.@@
         @@@.@@@...@@...@@@@..@.@
         @@.@..@@@@..@@@@...@.@@.
         @.@@.@...@@@@....@@..@@.
         @.@@.@@@@....@@@@...@@.@
         @@.@@..@@@@@@@@...@@@.@@
         @@@.@@@...@@...@@@@..@.@
         @@@@..@@@@..@@@@....@@.@
         @@@@@@...@@@@...@@@@..@@
         @@@@@@@@@....@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

							; SPR_SPRUNG:     EQU $2C
	9710 00 00 00 00 00 00 00 00 00 00 3C 00 01 FF 80 07
	9720 FF E0 0F FF F0 1F FF F8 0F FF F0 17 FF E8 09 FF
	9730 90 16 3C 6C 31 C3 8C 32 3C 1C 18 00 38 0E 01 E2
	9740 33 CF 06 30 78 0C 18 00 38 0E 01 E4 03 CF 0C 00
	9750 78 00 00 00 00 00 00 00 FF FF FF FF FF FF FF C3
	9760 FF FE 3C 7F F9 DB 9F F6 A5 6F ED 5A B7 DA A5 5B
	9770 ED 5A B7 C6 A5 63 E1 DB 83 D0 3C 0D B0 00 0D B2
	9780 00 5D D9 C2 39 CE 31 E2 B3 CF 16 B4 78 CD D9 86
	9790 3B EE 31 E5 F3 CF 0D FC 78 F3 FF 87 FF FF FF FF

         ........................
         ........................
         ........................
         ..........@@@@..........
         .......@@@@@@@@@@.......
         .....@@@@@@@@@@@@@@.....
         ....@@@@@@@@@@@@@@@@....
         ...@@@@@@@@@@@@@@@@@@...
         ....@@@@@@@@@@@@@@@@....
         ...@.@@@@@@@@@@@@@@.@...
         ....@..@@@@@@@@@@..@....
         ...@.@@...@@@@...@@.@@..
         ..@@...@@@....@@@...@@..
         ..@@..@...@@@@.....@@@..
         ...@@.............@@@...
         ....@@@........@@@@...@.
         ..@@..@@@@..@@@@.....@@.
         ..@@.....@@@@.......@@..
         ...@@.............@@@...
         ....@@@........@@@@..@..
         ......@@@@..@@@@....@@..
         .........@@@@...........
         ........................
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@
         @@@@@@@...@@@@...@@@@@@@
         @@@@@..@@@.@@.@@@..@@@@@
         @@@@.@@.@.@..@.@.@@.@@@@
         @@@.@@.@.@.@@.@.@.@@.@@@
         @@.@@.@.@.@..@.@.@.@@.@@
         @@@.@@.@.@.@@.@.@.@@.@@@
         @@...@@.@.@..@.@.@@...@@
         @@@....@@@.@@.@@@.....@@
         @@.@......@@@@......@@.@
         @.@@................@@.@
         @.@@..@..........@.@@@.@
         @@.@@..@@@....@...@@@..@
         @@..@@@...@@...@@@@...@.
         @.@@..@@@@..@@@@...@.@@.
         @.@@.@...@@@@...@@..@@.@
         @@.@@..@@....@@...@@@.@@
         @@@.@@@...@@...@@@@..@.@
         @@@@..@@@@..@@@@....@@.@
         @@@@@@...@@@@...@@@@..@@
         @@@@@@@@@....@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

							; SPR_FISH1:      EQU $2D
	97A0 00 00 00 00 38 6C 00 F8 96 00 DD 8C 71 6D 80 19
	97B0 AD A0 6D 03 58 34 F8 D8 7B E0 64 77 DF 2E 77 FF
	97C0 B6 2F 18 B0 2E 36 B6 36 2F 98 36 3E 3E 3B 29 BA
	97D0 31 B3 30 20 DC 64 21 67 CC 07 98 B8 03 67 00 00
	97E0 E0 00 00 60 00 00 00 00 FF C7 93 FF 03 61 FE 02
	97F0 84 8E 01 A1 74 01 93 98 01 A7 0C 03 5B 84 F8 DB
	9800 03 E0 65 07 DF 2E 07 FF B6 8F 18 B1 8E 36 B6 86
	9810 2F 99 86 3E 3E 83 29 BA 85 B3 31 8E DC 65 88 67
	9820 CD D0 18 BB F8 07 47 FC 08 FF FF 0F FF FF 9F FF

         ........................
         ..........@@@....@@.@@..
         ........@@@@@...@..@.@@.
         ........@@.@@@.@@...@@..
         .@@@...@.@@.@@.@@.......
         ...@@..@@.@.@@.@@.@.....
         .@@.@@.@......@@.@.@@...
         ..@@.@..@@@@@...@@.@@...
         .@@@@.@@@@@......@@..@..
         .@@@.@@@@@.@@@@@..@.@@@.
         .@@@.@@@@@@@@@@@@.@@.@@.
         ..@.@@@@...@@...@.@@....
         ..@.@@@...@@.@@.@.@@.@@.
         ..@@.@@...@.@@@@@..@@...
         ..@@.@@...@@@@@...@@@@@.
         ..@@@.@@..@.@..@@.@@@.@.
         ..@@...@@.@@..@@..@@....
         ..@.....@@.@@@...@@..@..
         ..@....@.@@..@@@@@..@@..
         .....@@@@..@@...@.@@@...
         ......@@.@@..@@@........
         ........@@@.............
         .........@@.............
         ........................

         @@@@@@@@@@...@@@@..@..@@
         @@@@@@@@......@@.@@....@
         @@@@@@@.......@.@....@..
         @...@@@........@@.@....@
         .@@@.@.........@@..@..@@
         @..@@..........@@.@..@@@
         ....@@........@@.@.@@.@@
         @....@..@@@@@...@@.@@.@@
         ......@@@@@......@@..@.@
         .....@@@@@.@@@@@..@.@@@.
         .....@@@@@@@@@@@@.@@.@@.
         @...@@@@...@@...@.@@...@
         @...@@@...@@.@@.@.@@.@@.
         @....@@...@.@@@@@..@@..@
         @....@@...@@@@@...@@@@@.
         @.....@@..@.@..@@.@@@.@.
         @....@.@@.@@..@@..@@...@
         @...@@@.@@.@@@...@@..@.@
         @...@....@@..@@@@@..@@.@
         @@.@.......@@...@.@@@.@@
         @@@@@........@@@.@...@@@
         @@@@@@......@...@@@@@@@@
         @@@@@@@@....@@@@@@@@@@@@
         @@@@@@@@@..@@@@@@@@@@@@@

							; SPR_FISH2:      EQU $2E
	9830 00 00 00 00 38 68 00 F8 94 18 DD 9C 31 6D 88 19
	9840 AD A0 2D 03 58 34 F8 D8 3B E0 64 37 DF 2E 17 FF
	9850 B6 2F 18 B0 2E 36 B6 36 2F 98 36 3E 3E 3B 29 BA
	9860 21 B3 30 18 DC 64 03 67 D8 03 18 B0 02 E7 00 01
	9870 C0 00 00 80 00 00 00 00 FF C7 97 FF 03 63 E6 02
	9880 81 DA 01 89 B4 01 83 D8 01 A7 8C 03 5B 84 F8 DB
	9890 83 E0 65 87 DF 2E C7 FF B6 8F 18 B1 8E 36 B6 86
	98A0 2F 99 86 3E 3E 83 29 BA 85 B3 31 C0 DC 65 E0 67
	98B0 DB F8 18 B7 F8 07 4F FC 18 FF FE 3F FF FF 7F FF

         ........................
         ..........@@@....@@.@...
         ........@@@@@...@..@.@..
         ...@@...@@.@@@.@@..@@@..
         ..@@...@.@@.@@.@@...@...
         ...@@..@@.@.@@.@@.@.....
         ..@.@@.@......@@.@.@@...
         ..@@.@..@@@@@...@@.@@...
         ..@@@.@@@@@......@@..@..
         ..@@.@@@@@.@@@@@..@.@@@.
         ...@.@@@@@@@@@@@@.@@.@@.
         ..@.@@@@...@@...@.@@....
         ..@.@@@...@@.@@.@.@@.@@.
         ..@@.@@...@.@@@@@..@@...
         ..@@.@@...@@@@@...@@@@@.
         ..@@@.@@..@.@..@@.@@@.@.
         ..@....@@.@@..@@..@@....
         ...@@...@@.@@@...@@..@..
         ......@@.@@..@@@@@.@@...
         ......@@...@@...@.@@....
         ......@.@@@..@@@........
         .......@@@..............
         ........@...............
         ........................

         @@@@@@@@@@...@@@@..@.@@@
         @@@@@@@@......@@.@@...@@
         @@@..@@.......@.@......@
         @@.@@.@........@@...@..@
         @.@@.@.........@@.....@@
         @@.@@..........@@.@..@@@
         @...@@........@@.@.@@.@@
         @....@..@@@@@...@@.@@.@@
         @.....@@@@@......@@..@.@
         @....@@@@@.@@@@@..@.@@@.
         @@...@@@@@@@@@@@@.@@.@@.
         @...@@@@...@@...@.@@...@
         @...@@@...@@.@@.@.@@.@@.
         @....@@...@.@@@@@..@@..@
         @....@@...@@@@@...@@@@@.
         @.....@@..@.@..@@.@@@.@.
         @....@.@@.@@..@@..@@...@
         @@......@@.@@@...@@..@.@
         @@@......@@..@@@@@.@@.@@
         @@@@@......@@...@.@@.@@@
         @@@@@........@@@.@..@@@@
         @@@@@@.....@@...@@@@@@@@
         @@@@@@@...@@@@@@@@@@@@@@
         @@@@@@@@.@@@@@@@@@@@@@@@

							; SPR_CROWN:      EQU $2F
	98C0 00 00 00 02 70 00 05 FC 00 07 FE 00 09 BE 10 3E
	98D0 7E 7C 63 BD C6 40 5A 02 47 66 E2 4F 99 F2 6F AD
	98E0 F6 2F BD F4 2F AD F4 2F DB F4 4F DB F2 77 DB EE
	98F0 73 DB CE 6C 99 36 2F 5A F4 0F 66 F0 03 7E C0 00
	9900 7E 00 00 3C 00 00 00 00 FD 8F FF F8 03 FF F0 01
	9910 FF F0 00 EF C8 00 93 BE 00 7D 63 81 C6 58 42 1A
	9920 51 66 8A 44 18 22 61 0C 86 A4 1C 25 A1 0C 85 A4
	9930 4A 25 01 08 82 30 4A 06 30 08 06 24 08 36 87 0A
	9940 71 C7 26 73 F3 3E 0F FC 3E 3F FF 9D FF FF C3 FF

         ........................
         ......@..@@@............
         .....@.@@@@@@@..........
         .....@@@@@@@@@@.........
         ....@..@@.@@@@@....@....
         ..@@@@@..@@@@@@..@@@@@..
         .@@...@@@.@@@@.@@@...@@.
         .@.......@.@@.@.......@.
         .@...@@@.@@..@@.@@@...@.
         .@..@@@@@..@@..@@@@@..@.
         .@@.@@@@@.@.@@.@@@@@.@@.
         ..@.@@@@@.@@@@.@@@@@.@..
         ..@.@@@@@.@.@@.@@@@@.@..
         ..@.@@@@@@.@@.@@@@@@.@..
         .@..@@@@@@.@@.@@@@@@..@.
         .@@@.@@@@@.@@.@@@@@.@@@.
         .@@@..@@@@.@@.@@@@..@@@.
         .@@.@@..@..@@..@..@@.@@.
         ..@.@@@@.@.@@.@.@@@@.@..
         ....@@@@.@@..@@.@@@@....
         ......@@.@@@@@@.@@......
         .........@@@@@@.........
         ..........@@@@..........
         ........................

         @@@@@@.@@...@@@@@@@@@@@@
         @@@@@.........@@@@@@@@@@
         @@@@...........@@@@@@@@@
         @@@@............@@@.@@@@
         @@..@...........@..@..@@
         @.@@@@@..........@@@@@.@
         .@@...@@@......@@@...@@.
         .@.@@....@....@....@@.@.
         .@.@...@.@@..@@.@...@.@.
         .@...@.....@@.....@...@.
         .@@....@....@@..@....@@.
         @.@..@.....@@@....@..@.@
         @.@....@....@@..@....@.@
         @.@..@...@..@.@...@..@.@
         .......@....@...@.....@.
         ..@@.....@..@.@......@@.
         ..@@........@........@@.
         ..@..@......@.....@@.@@.
         @....@@@....@.@..@@@...@
         @@...@@@..@..@@..@@@..@@
         @@@@..@@..@@@@@.....@@@@
         @@@@@@....@@@@@...@@@@@@
         @@@@@@@@@..@@@.@@@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_SWITCH:     EQU $30
	9950 00 00 00 07 00 00 0B 80 00 0F 80 00 07 3E 00 00
	9960 DF 80 06 EF E0 0F 70 F0 1F 00 F8 1F FF F8 2F FF
	9970 F4 2F FF F4 13 FF C8 4C 7E 32 73 81 CE 7C 7E 3E
	9980 7F 00 FE 7F C3 FE 3F E7 FC 0F E7 F0 03 E7 C0 00
	9990 E7 00 00 24 00 00 00 00 F8 FF FF F7 7F FF EB BF
	99A0 FF EF 81 FF F7 00 7F F8 C0 1F F0 E0 0F E0 70 07
	99B0 C0 00 03 C0 00 03 A0 00 05 A0 00 05 90 00 09 0C
	99C0 00 30 03 81 C0 00 7E 00 00 00 00 00 00 00 80 00
	99D0 01 C0 00 03 F0 00 0F FC 00 3F FF 00 FF FF C3 FF

         ........................
         .....@@@................
         ....@.@@@...............
         ....@@@@@...............
         .....@@@..@@@@@.........
         ........@@.@@@@@@.......
         .....@@.@@@.@@@@@@@.....
         ....@@@@.@@@....@@@@....
         ...@@@@@........@@@@@...
         ...@@@@@@@@@@@@@@@@@@...
         ..@.@@@@@@@@@@@@@@@@.@..
         ..@.@@@@@@@@@@@@@@@@.@..
         ...@..@@@@@@@@@@@@..@...
         .@..@@...@@@@@@...@@..@.
         .@@@..@@@......@@@..@@@.
         .@@@@@...@@@@@@...@@@@@.
         .@@@@@@@........@@@@@@@.
         .@@@@@@@@@....@@@@@@@@@.
         ..@@@@@@@@@..@@@@@@@@@..
         ....@@@@@@@..@@@@@@@....
         ......@@@@@..@@@@@......
         ........@@@..@@@........
         ..........@..@..........
         ........................

         @@@@@...@@@@@@@@@@@@@@@@
         @@@@.@@@.@@@@@@@@@@@@@@@
         @@@.@.@@@.@@@@@@@@@@@@@@
         @@@.@@@@@......@@@@@@@@@
         @@@@.@@@.........@@@@@@@
         @@@@@...@@.........@@@@@
         @@@@....@@@.........@@@@
         @@@......@@@.........@@@
         @@....................@@
         @@....................@@
         @.@..................@.@
         @.@..................@.@
         @..@................@..@
         ....@@............@@....
         ......@@@......@@@......
         .........@@@@@@.........
         ........................
         ........................
         @......................@
         @@....................@@
         @@@@................@@@@
         @@@@@@............@@@@@@
         @@@@@@@@........@@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_GRATING:    EQU $31
	99E0 00 00 00 00 00 20 00 00 F0 00 03 C8 00 0F 38 00
	99F0 3C C8 00 F3 28 03 CC 28 0F 34 28 14 C4 28 1B 14
	9A00 28 1A 14 28 1A 14 28 1A 14 C8 1A 15 30 1A 14 C0
	9A10 1A 37 00 1A CC 00 1A 30 00 1A C0 00 0B 00 00 00
	9A20 00 00 00 00 00 00 00 00 FF FF DF FF FF 0F FF FC
	9A30 07 FF F0 03 FF C0 03 FF 00 03 FC 00 23 F0 00 A3
	9A40 E0 01 A3 C0 01 A3 D0 11 A3 C8 D1 A3 D0 D1 23 C8
	9A50 D0 C3 D0 D1 07 C8 D0 0F D0 30 3F C8 C0 FF D0 03
	9A60 FF C8 0F FF E0 3F FF F0 FF FF FF FF FF FF FF FF

         ........................
         ..................@.....
         ................@@@@....
         ..............@@@@..@...
         ............@@@@..@@@...
         ..........@@@@..@@..@...
         ........@@@@..@@..@.@...
         ......@@@@..@@....@.@...
         ....@@@@..@@.@....@.@...
         ...@.@..@@...@....@.@...
         ...@@.@@...@.@....@.@...
         ...@@.@....@.@....@.@...
         ...@@.@....@.@....@.@...
         ...@@.@....@.@..@@..@...
         ...@@.@....@.@.@..@@....
         ...@@.@....@.@..@@......
         ...@@.@...@@.@@@........
         ...@@.@.@@..@@..........
         ...@@.@...@@............
         ...@@.@.@@..............
         ....@.@@................
         ........................
         ........................
         ........................

         @@@@@@@@@@@@@@@@@@.@@@@@
         @@@@@@@@@@@@@@@@....@@@@
         @@@@@@@@@@@@@@.......@@@
         @@@@@@@@@@@@..........@@
         @@@@@@@@@@............@@
         @@@@@@@@..............@@
         @@@@@@............@...@@
         @@@@............@.@...@@
         @@@............@@.@...@@
         @@.............@@.@...@@
         @@.@.......@...@@.@...@@
         @@..@...@@.@...@@.@...@@
         @@.@....@@.@...@..@...@@
         @@..@...@@.@....@@....@@
         @@.@....@@.@...@.....@@@
         @@..@...@@.@........@@@@
         @@.@......@@......@@@@@@
         @@..@...@@......@@@@@@@@
         @@.@..........@@@@@@@@@@
         @@..@.......@@@@@@@@@@@@
         @@@.......@@@@@@@@@@@@@@
         @@@@....@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

							; SPR_MONOCAT1:   EQU $32
	9A70 00 00 00 01 20 00 07 C8 00 0C 72 00 13 9C 00 17
	9A80 E3 E0 2F EF FC 6F DF F8 5F BF C4 47 7C 2E 3B 02
	9A90 36 3F 75 96 7E F5 14 7E F4 10 7E FA 24 1D 7D 9C
	9AA0 65 80 78 79 9F F4 7E 47 CC 6A F0 38 3C 7C 00 00
	9AB0 6A 00 00 3C 00 00 00 00 FE DF FF F9 07 FF F7 C1
	9AC0 FF EC 70 FF D0 1C 1F D0 00 03 A0 00 01 60 00 01
	9AD0 40 00 05 40 00 0E 80 00 06 80 71 86 00 F1 05 00
	9AE0 F0 01 00 F8 01 80 7C 01 60 00 03 78 00 05 7E 40
	9AF0 0D 6A F0 3B BD 7D C7 C3 6A FF FF BD FF FF C3 FF

         ........................
         .......@..@.............
         .....@@@@@..@...........
         ....@@...@@@..@.........
         ...@..@@@..@@@..........
         ...@.@@@@@@...@@@@@.....
         ..@.@@@@@@@.@@@@@@@@@@..
         .@@.@@@@@@.@@@@@@@@@@...
         .@.@@@@@@.@@@@@@@@...@..
         .@...@@@.@@@@@....@.@@@.
         ..@@@.@@......@...@@.@@.
         ..@@@@@@.@@@.@.@@..@.@@.
         .@@@@@@.@@@@.@.@...@.@..
         .@@@@@@.@@@@.@.....@....
         .@@@@@@.@@@@@.@...@..@..
         ...@@@.@.@@@@@.@@..@@@..
         .@@..@.@@........@@@@...
         .@@@@..@@..@@@@@@@@@.@..
         .@@@@@@..@...@@@@@..@@..
         .@@.@.@.@@@@......@@@...
         ..@@@@...@@@@@..........
         .........@@.@.@.........
         ..........@@@@..........
         ........................

         @@@@@@@.@@.@@@@@@@@@@@@@
         @@@@@..@.....@@@@@@@@@@@
         @@@@.@@@@@.....@@@@@@@@@
         @@@.@@...@@@....@@@@@@@@
         @@.@.......@@@.....@@@@@
         @@.@..................@@
         @.@....................@
         .@@....................@
         .@...................@.@
         .@..................@@@.
         @....................@@.
         @........@@@...@@....@@.
         ........@@@@...@.....@.@
         ........@@@@...........@
         ........@@@@@..........@
         @........@@@@@.........@
         .@@...................@@
         .@@@@................@.@
         .@@@@@@..@..........@@.@
         .@@.@.@.@@@@......@@@.@@
         @.@@@@.@.@@@@@.@@@...@@@
         @@....@@.@@.@.@.@@@@@@@@
         @@@@@@@@@.@@@@.@@@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_MONOCAT2:   EQU $33
	9B00 00 00 00 01 20 00 07 C8 00 0C 72 00 13 9C 00 17
	9B10 E3 E0 2F EF FC 6F DF F8 5F BF C4 47 7C 2E 3B 02
	9B20 36 3F 75 96 7E F5 14 7E F4 10 7E FA 24 0D 7D 9C
	9B30 71 80 7A 3D 9F F6 3E 67 CA 35 78 1C 1E FC 00 00
	9B40 D4 00 00 78 00 00 00 00 FE DF FF F9 07 FF F7 C1
	9B50 FF EC 70 FF D0 1C 1F D0 00 03 A0 00 01 60 00 01
	9B60 40 00 05 40 00 0E 80 00 06 80 71 86 00 F1 05 00
	9B70 F0 01 00 F8 01 80 7C 01 70 00 02 BC 00 06 BE 60
	9B80 0A B5 78 1D DE FD E3 E0 D5 FF FF 7B FF FF 87 FF

         ........................
         .......@..@.............
         .....@@@@@..@...........
         ....@@...@@@..@.........
         ...@..@@@..@@@..........
         ...@.@@@@@@...@@@@@.....
         ..@.@@@@@@@.@@@@@@@@@@..
         .@@.@@@@@@.@@@@@@@@@@...
         .@.@@@@@@.@@@@@@@@...@..
         .@...@@@.@@@@@....@.@@@.
         ..@@@.@@......@...@@.@@.
         ..@@@@@@.@@@.@.@@..@.@@.
         .@@@@@@.@@@@.@.@...@.@..
         .@@@@@@.@@@@.@.....@....
         .@@@@@@.@@@@@.@...@..@..
         ....@@.@.@@@@@.@@..@@@..
         .@@@...@@........@@@@.@.
         ..@@@@.@@..@@@@@@@@@.@@.
         ..@@@@@..@@..@@@@@..@.@.
         ..@@.@.@.@@@@......@@@..
         ...@@@@.@@@@@@..........
         ........@@.@.@..........
         .........@@@@...........
         ........................

         @@@@@@@.@@.@@@@@@@@@@@@@
         @@@@@..@.....@@@@@@@@@@@
         @@@@.@@@@@.....@@@@@@@@@
         @@@.@@...@@@....@@@@@@@@
         @@.@.......@@@.....@@@@@
         @@.@..................@@
         @.@....................@
         .@@....................@
         .@...................@.@
         .@..................@@@.
         @....................@@.
         @........@@@...@@....@@.
         ........@@@@...@.....@.@
         ........@@@@...........@
         ........@@@@@..........@
         @........@@@@@.........@
         .@@@..................@.
         @.@@@@...............@@.
         @.@@@@@..@@.........@.@.
         @.@@.@.@.@@@@......@@@.@
         @@.@@@@.@@@@@@.@@@@...@@
         @@@.....@@.@.@.@@@@@@@@@
         @@@@@@@@.@@@@.@@@@@@@@@@
         @@@@@@@@@....@@@@@@@@@@@

							; SPR_MONOCATB1:  EQU $34
	9B90 00 00 00 00 00 00 00 3E 00 00 07 80 07 79 A0 1C
	9BA0 FE D0 3B FE D8 37 FF 68 4F FF 6C 6F FF B4 2F FF
	9BB0 B6 43 FF B6 2F E3 B4 1F DF 34 3D FF B2 3D FF B4
	9BC0 31 BF B2 0D BF 4E 1C 81 3E 0E 7E 1C 00 F4 00 00
	9BD0 FC 00 00 78 00 00 00 00 FF FF FF FF C1 FF FF BE
	9BE0 7F F8 07 9F E0 01 8F C0 00 C7 80 00 C3 80 00 63
	9BF0 40 00 61 60 00 31 A0 00 30 00 00 30 80 00 31 C0
	9C00 00 31 80 00 30 80 00 31 80 00 32 CC 00 4E DC 00
	9C10 3E EE 7E DD F0 F5 E3 FE FD FF FF 7B FF FF 87 FF

         ........................
         ........................
         ..........@@@@@.........
         .............@@@@.......
         .....@@@.@@@@..@@.@.....
         ...@@@..@@@@@@@.@@.@....
         ..@@@.@@@@@@@@@.@@.@@...
         ..@@.@@@@@@@@@@@.@@.@...
         .@..@@@@@@@@@@@@.@@.@@..
         .@@.@@@@@@@@@@@@@.@@.@..
         ..@.@@@@@@@@@@@@@.@@.@@.
         .@....@@@@@@@@@@@.@@.@@.
         ..@.@@@@@@@...@@@.@@.@..
         ...@@@@@@@.@@@@@..@@.@..
         ..@@@@.@@@@@@@@@@.@@..@.
         ..@@@@.@@@@@@@@@@.@@.@..
         ..@@...@@.@@@@@@@.@@..@.
         ....@@.@@.@@@@@@.@..@@@.
         ...@@@..@......@..@@@@@.
         ....@@@..@@@@@@....@@@..
         ........@@@@.@..........
         ........@@@@@@..........
         .........@@@@...........
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@.....@@@@@@@@@
         @@@@@@@@@.@@@@@..@@@@@@@
         @@@@@........@@@@..@@@@@
         @@@............@@...@@@@
         @@..............@@...@@@
         @...............@@....@@
         @................@@...@@
         .@...............@@....@
         .@@...............@@...@
         @.@...............@@....
         ..................@@....
         @.................@@...@
         @@................@@...@
         @.................@@....
         @.................@@...@
         @.................@@..@.
         @@..@@...........@..@@@.
         @@.@@@............@@@@@.
         @@@.@@@..@@@@@@.@@.@@@.@
         @@@@....@@@@.@.@@@@...@@
         @@@@@@@.@@@@@@.@@@@@@@@@
         @@@@@@@@.@@@@.@@@@@@@@@@
         @@@@@@@@@....@@@@@@@@@@@

							; SPR_MONOCATB2:  EQU $35
	9C20 00 00 00 00 00 00 00 3E 00 00 07 80 07 79 A0 1C
	9C30 FE D0 3B FE D8 37 FF 68 4F FF 6C 6F FF B4 2F FF
	9C40 B6 43 FF B6 2F E3 B4 1F DF 34 3D FF B2 3D FF B4
	9C50 0D BF B2 31 BF 4C 3C 81 3C 1C 3E 78 00 7A 00 00
	9C60 7E 00 00 3C 00 00 00 00 FF FF FF FF C1 FF FF BE
	9C70 7F F8 07 9F E0 01 8F C0 00 C7 80 00 C3 80 00 63
	9C80 40 00 61 60 00 31 A0 00 30 00 00 30 80 00 31 C0
	9C90 00 31 80 00 30 80 00 31 C0 00 32 B0 00 4D BC 00
	9CA0 3D DD 3E 7B E3 7A 87 FF 7E FF FF BD FF FF C3 FF

         ........................
         ........................
         ..........@@@@@.........
         .............@@@@.......
         .....@@@.@@@@..@@.@.....
         ...@@@..@@@@@@@.@@.@....
         ..@@@.@@@@@@@@@.@@.@@...
         ..@@.@@@@@@@@@@@.@@.@...
         .@..@@@@@@@@@@@@.@@.@@..
         .@@.@@@@@@@@@@@@@.@@.@..
         ..@.@@@@@@@@@@@@@.@@.@@.
         .@....@@@@@@@@@@@.@@.@@.
         ..@.@@@@@@@...@@@.@@.@..
         ...@@@@@@@.@@@@@..@@.@..
         ..@@@@.@@@@@@@@@@.@@..@.
         ..@@@@.@@@@@@@@@@.@@.@..
         ....@@.@@.@@@@@@@.@@..@.
         ..@@...@@.@@@@@@.@..@@..
         ..@@@@..@......@..@@@@..
         ...@@@....@@@@@..@@@@...
         .........@@@@.@.........
         .........@@@@@@.........
         ..........@@@@..........
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@.....@@@@@@@@@
         @@@@@@@@@.@@@@@..@@@@@@@
         @@@@@........@@@@..@@@@@
         @@@............@@...@@@@
         @@..............@@...@@@
         @...............@@....@@
         @................@@...@@
         .@...............@@....@
         .@@...............@@...@
         @.@...............@@....
         ..................@@....
         @.................@@...@
         @@................@@...@
         @.................@@....
         @.................@@...@
         @@................@@..@.
         @.@@.............@..@@.@
         @.@@@@............@@@@.@
         @@.@@@.@..@@@@@..@@@@.@@
         @@@...@@.@@@@.@.@....@@@
         @@@@@@@@.@@@@@@.@@@@@@@@
         @@@@@@@@@.@@@@.@@@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_ROBOMOUSE:  EQU $36
	9CB0 00 00 00 00 3C 00 01 E7 00 03 F9 C0 06 7E E0 05
	9CC0 BF 50 35 B9 A8 76 74 98 7B F9 D8 24 FF E8 5E 1F
	9CD0 F0 5E C0 08 5E FF F8 5C 7F B4 5B 1F 8A 2F CE 7A
	9CE0 4F 01 F6 73 6F 90 34 F7 60 03 76 E0 03 71 C0 01
	9CF0 B7 00 00 4C 00 00 00 00 FF C3 FF FE 00 FF FC 00
	9D00 3F F8 00 1F F0 00 0F C1 80 07 B1 80 23 70 04 03
	9D10 78 00 03 A4 00 03 1E 00 07 1E C0 0B 1E FF FB 1C
	9D20 7F B1 1B 1F 88 8F CE 78 4F 01 F0 73 0F 90 B4 07
	9D30 6F CB 06 EF FB 01 DF FD 87 3F FE 4C FF FF B3 FF

         ........................
         ..........@@@@..........
         .......@@@@..@@@........
         ......@@@@@@@..@@@......
         .....@@..@@@@@@.@@@.....
         .....@.@@.@@@@@@.@.@....
         ..@@.@.@@.@@@..@@.@.@...
         .@@@.@@..@@@.@..@..@@...
         .@@@@.@@@@@@@..@@@.@@...
         ..@..@..@@@@@@@@@@@.@...
         .@.@@@@....@@@@@@@@@....
         .@.@@@@.@@..........@...
         .@.@@@@.@@@@@@@@@@@@@...
         .@.@@@...@@@@@@@@.@@.@..
         .@.@@.@@...@@@@@@...@.@.
         ..@.@@@@@@..@@@..@@@@.@.
         .@..@@@@.......@@@@@.@@.
         .@@@..@@.@@.@@@@@..@....
         ..@@.@..@@@@.@@@.@@.....
         ......@@.@@@.@@.@@@.....
         ......@@.@@@...@@@......
         .......@@.@@.@@@........
         .........@..@@..........
         ........................

         @@@@@@@@@@....@@@@@@@@@@
         @@@@@@@.........@@@@@@@@
         @@@@@@............@@@@@@
         @@@@@..............@@@@@
         @@@@................@@@@
         @@.....@@............@@@
         @.@@...@@.........@...@@
         .@@@.........@........@@
         .@@@@.................@@
         @.@..@................@@
         ...@@@@..............@@@
         ...@@@@.@@..........@.@@
         ...@@@@.@@@@@@@@@@@@@.@@
         ...@@@...@@@@@@@@.@@...@
         ...@@.@@...@@@@@@...@...
         @...@@@@@@..@@@..@@@@...
         .@..@@@@.......@@@@@....
         .@@@..@@....@@@@@..@....
         @.@@.@.......@@@.@@.@@@@
         @@..@.@@.....@@.@@@.@@@@
         @@@@@.@@.......@@@.@@@@@
         @@@@@@.@@....@@@..@@@@@@
         @@@@@@@..@..@@..@@@@@@@@
         @@@@@@@@@.@@..@@@@@@@@@@

							; SPR_ROBOMOUSEB: EQU $37
	9D40 00 00 00 00 3C 00 00 C7 80 03 F9 C0 05 FE E0 09
	9D50 9F 60 1F 6F 60 0F 6F 60 07 9F DC 01 FE 3E 06 39
	9D60 DE 0D 83 EC 0B CB E2 0B C9 CE 03 CA 2E 2F AB EE
	9D70 2F AB EC 37 6B E2 38 E9 DE 1B EA 2C 01 EB E0 00
	9D80 75 C0 00 00 00 00 00 00 FF C3 FF FF 00 7F FC 00
	9D90 3F F8 00 1F F4 00 0F E0 00 0F C0 60 0F E0 60 03
	9DA0 F0 00 1D F8 00 3E F6 01 DE ED 83 ED EB C3 E0 EB
	9DB0 C1 C0 D3 C0 00 8F A0 00 8F A0 01 87 60 02 80 E0
	9DC0 1E C3 E2 2D E5 E3 E3 FE 71 DF FF 8A 3F FF FF FF

         ........................
         ..........@@@@..........
         ........@@...@@@@.......
         ......@@@@@@@..@@@......
         .....@.@@@@@@@@.@@@.....
         ....@..@@..@@@@@.@@.....
         ...@@@@@.@@.@@@@.@@.....
         ....@@@@.@@.@@@@.@@.....
         .....@@@@..@@@@@@@.@@@..
         .......@@@@@@@@...@@@@@.
         .....@@...@@@..@@@.@@@@.
         ....@@.@@.....@@@@@.@@..
         ....@.@@@@..@.@@@@@...@.
         ....@.@@@@..@..@@@..@@@.
         ......@@@@..@.@...@.@@@.
         ..@.@@@@@.@.@.@@@@@.@@@.
         ..@.@@@@@.@.@.@@@@@.@@..
         ..@@.@@@.@@.@.@@@@@...@.
         ..@@@...@@@.@..@@@.@@@@.
         ...@@.@@@@@.@.@...@.@@..
         .......@@@@.@.@@@@@.....
         .........@@@.@.@@@......
         ........................
         ........................

         @@@@@@@@@@....@@@@@@@@@@
         @@@@@@@@.........@@@@@@@
         @@@@@@............@@@@@@
         @@@@@..............@@@@@
         @@@@.@..............@@@@
         @@@.................@@@@
         @@.......@@.........@@@@
         @@@......@@...........@@
         @@@@...............@@@.@
         @@@@@.............@@@@@.
         @@@@.@@........@@@.@@@@.
         @@@.@@.@@.....@@@@@.@@.@
         @@@.@.@@@@....@@@@@.....
         @@@.@.@@@@.....@@@......
         @@.@..@@@@..............
         @...@@@@@.@.............
         @...@@@@@.@............@
         @....@@@.@@...........@.
         @.......@@@........@@@@.
         @@....@@@@@...@...@.@@.@
         @@@..@.@@@@...@@@@@...@@
         @@@@@@@..@@@...@@@.@@@@@
         @@@@@@@@@...@.@...@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

							; SPR_BEE1:       EQU $38
	9DD0 00 00 00 00 00 00 00 00 00 00 0C 00 00 0E 00 00
	9DE0 0C 00 38 08 00 6E 00 00 3F DB FC 00 00 76 0D 91
	9DF0 9C 10 32 00 20 54 04 46 74 62 4D 28 B2 49 18 92
	9E00 46 3C 62 20 24 04 38 C3 1C 0F 3C F0 03 FF C0 00
	9E10 E7 00 00 3C 00 00 00 00 FF FF FF FF FF FF FF F1
	9E20 FF FF EC FF FF EE FF C3 ED FF B8 EB FF 6E 00 03
	9E30 BF C3 FD C0 00 76 E0 10 1D C0 30 03 80 50 01 06
	9E40 70 60 0D 20 B0 09 00 90 06 00 60 80 00 01 80 00
	9E50 01 C0 00 03 F0 00 0F FC 00 3F FF 00 FF FF C3 FF

         ........................
         ........................
         ........................
         ............@@..........
         ............@@@.........
         ............@@..........
         ..@@@.......@...........
         .@@.@@@.................
         ..@@@@@@@@.@@.@@@@@@@@..
         .................@@@.@@.
         ....@@.@@..@...@@..@@@..
         ...@......@@..@.........
         ..@......@.@.@.......@..
         .@...@@..@@@.@...@@...@.
         .@..@@.@..@.@...@.@@..@.
         .@..@..@...@@...@..@..@.
         .@...@@...@@@@...@@...@.
         ..@.......@..@.......@..
         ..@@@...@@....@@...@@@..
         ....@@@@..@@@@..@@@@....
         ......@@@@@@@@@@@@......
         ........@@@..@@@........
         ..........@@@@..........
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@...@@@@@@@@@
         @@@@@@@@@@@.@@..@@@@@@@@
         @@@@@@@@@@@.@@@.@@@@@@@@
         @@....@@@@@.@@.@@@@@@@@@
         @.@@@...@@@.@.@@@@@@@@@@
         .@@.@@@...............@@
         @.@@@@@@@@....@@@@@@@@.@
         @@...............@@@.@@.
         @@@........@.......@@@.@
         @@........@@..........@@
         @........@.@...........@
         .....@@..@@@.....@@.....
         ....@@.@..@.....@.@@....
         ....@..@........@..@....
         .....@@..........@@.....
         @......................@
         @......................@
         @@....................@@
         @@@@................@@@@
         @@@@@@............@@@@@@
         @@@@@@@@........@@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_BEE2:       EQU $39
	9E60 00 00 00 00 00 00 00 00 00 00 00 00 1C 01 C0 17
	9E70 03 40 0F 87 80 00 E6 00 00 18 00 02 26 00 0C E3
	9E80 C0 13 C0 F8 25 A4 6C 47 24 3A 40 18 82 49 18 92
	9E90 46 3C 62 20 24 04 38 C3 1C 0F 3C F0 03 FF C0 00
	9EA0 E7 00 00 3C 00 00 00 00 FF FF FF FF FF FF FF FF
	9EB0 FF E3 FE 3F DC FD DF D7 7B 5F EF 97 BF F0 E6 7F
	9EC0 FC 00 7F F0 26 3F E0 E3 C7 C3 C0 FB 85 80 6D 07
	9ED0 00 38 00 00 80 09 00 90 06 00 60 80 00 01 80 00
	9EE0 01 C0 00 03 F0 00 0F FC 00 3F FF 00 FF FF C3 FF

         ........................
         ........................
         ........................
         ........................
         ...@@@.........@@@......
         ...@.@@@......@@.@......
         ....@@@@@....@@@@.......
         ........@@@..@@.........
         ...........@@...........
         ......@...@..@@.........
         ....@@..@@@...@@@@......
         ...@..@@@@......@@@@@...
         ..@..@.@@.@..@...@@.@@..
         .@...@@@..@..@....@@@.@.
         .@.........@@...@.....@.
         .@..@..@...@@...@..@..@.
         .@...@@...@@@@...@@...@.
         ..@.......@..@.......@..
         ..@@@...@@....@@...@@@..
         ....@@@@..@@@@..@@@@....
         ......@@@@@@@@@@@@......
         ........@@@..@@@........
         ..........@@@@..........
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@...@@@@@@@@@...@@@@@@
         @@.@@@..@@@@@@.@@@.@@@@@
         @@.@.@@@.@@@@.@@.@.@@@@@
         @@@.@@@@@..@.@@@@.@@@@@@
         @@@@....@@@..@@..@@@@@@@
         @@@@@@...........@@@@@@@
         @@@@......@..@@...@@@@@@
         @@@.....@@@...@@@@...@@@
         @@....@@@@......@@@@@.@@
         @....@.@@........@@.@@.@
         .....@@@..........@@@...
         ................@.......
         ....@..@........@..@....
         .....@@..........@@.....
         @......................@
         @......................@
         @@....................@@
         @@@@................@@@@
         @@@@@@............@@@@@@
         @@@@@@@@........@@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_BEACON:     EQU $3A
	9EF0 00 00 00 00 7E 00 01 E7 80 03 99 C0 07 C3 E0 07
	9F00 FF E0 07 FF E0 0B FF D0 0D FF 90 0C 3C 50 0C C0
	9F10 D0 12 CC A8 13 4D 28 39 33 1C 2E 30 74 5B C3 DA
	9F20 66 FF 66 79 BD 9E 3E 66 7C 0F 99 F0 03 E7 C0 00
	9F30 FF 00 00 3C 00 00 00 00 FF 81 FF FE 00 7F FC 00
	9F40 3F F8 18 1F F0 00 0F F0 00 0F F0 00 0F E8 00 17
	9F50 EC 00 17 EC 00 57 EC C0 D7 C2 CC A3 C3 4D 23 81
	9F60 33 01 80 30 01 40 00 02 60 00 06 78 00 1E BE 00
	9F70 7D CF 81 F3 F3 E7 CF FC FF 3F FF 3C FF FF C3 FF

         ........................
         .........@@@@@@.........
         .......@@@@..@@@@.......
         ......@@@..@@..@@@......
         .....@@@@@....@@@@@.....
         .....@@@@@@@@@@@@@@.....
         .....@@@@@@@@@@@@@@.....
         ....@.@@@@@@@@@@@@.@....
         ....@@.@@@@@@@@@@..@....
         ....@@....@@@@...@.@....
         ....@@..@@......@@.@....
         ...@..@.@@..@@..@.@.@...
         ...@..@@.@..@@.@..@.@...
         ..@@@..@..@@..@@...@@@..
         ..@.@@@...@@.....@@@.@..
         .@.@@.@@@@....@@@@.@@.@.
         .@@..@@.@@@@@@@@.@@..@@.
         .@@@@..@@.@@@@.@@..@@@@.
         ..@@@@@..@@..@@..@@@@@..
         ....@@@@@..@@..@@@@@....
         ......@@@@@..@@@@@......
         ........@@@@@@@@........
         ..........@@@@..........
         ........................

         @@@@@@@@@......@@@@@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@@............@@@@@@
         @@@@@......@@......@@@@@
         @@@@................@@@@
         @@@@................@@@@
         @@@@................@@@@
         @@@.@..............@.@@@
         @@@.@@.............@.@@@
         @@@.@@...........@.@.@@@
         @@@.@@..@@......@@.@.@@@
         @@....@.@@..@@..@.@...@@
         @@....@@.@..@@.@..@...@@
         @......@..@@..@@.......@
         @.........@@...........@
         .@....................@.
         .@@..................@@.
         .@@@@..............@@@@.
         @.@@@@@..........@@@@@.@
         @@..@@@@@......@@@@@..@@
         @@@@..@@@@@..@@@@@..@@@@
         @@@@@@..@@@@@@@@..@@@@@@
         @@@@@@@@..@@@@..@@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_FACE:       EQU $3B
	9F80 00 00 00 00 1E 60 00 E1 F0 03 07 F8 04 1F E4 08
	9F90 7F 94 11 FE 54 22 F8 EA 23 22 AA 43 D7 6A 41 D5
	9FA0 1A 41 D3 64 54 E8 9E 48 EF 7E 48 74 FE 48 3B C2
	9FB0 24 37 92 26 37 4E 11 B6 3C 0C 36 F0 03 37 C0 00
	9FC0 D7 00 00 2C 00 00 00 00 FF FF 9F FF E0 6F FF 01
	9FD0 F7 FC 07 FB F8 1F E5 F0 7F 85 E1 FE 05 C2 F8 42
	9FE0 C3 20 A2 83 C2 42 81 C5 02 81 C2 05 80 E0 1E 80
	9FF0 E0 7E 80 70 FE 80 3B C2 C0 37 82 C0 37 0E E0 36
	A000 3D F0 36 F3 FC 37 CF FF 17 3F FF EC FF FF F3 FF

         ........................
         ...........@@@@..@@.....
         ........@@@....@@@@@....
         ......@@.....@@@@@@@@...
         .....@.....@@@@@@@@..@..
         ....@....@@@@@@@@..@.@..
         ...@...@@@@@@@@..@.@.@..
         ..@...@.@@@@@...@@@.@.@.
         ..@...@@..@...@.@.@.@.@.
         .@....@@@@.@.@@@.@@.@.@.
         .@.....@@@.@.@.@...@@.@.
         .@.....@@@.@..@@.@@..@..
         .@.@.@..@@@.@...@..@@@@.
         .@..@...@@@.@@@@.@@@@@@.
         .@..@....@@@.@..@@@@@@@.
         .@..@.....@@@.@@@@....@.
         ..@..@....@@.@@@@..@..@.
         ..@..@@...@@.@@@.@..@@@.
         ...@...@@.@@.@@...@@@@..
         ....@@....@@.@@.@@@@....
         ......@@..@@.@@@@@......
         ........@@.@.@@@........
         ..........@.@@..........
         ........................

         @@@@@@@@@@@@@@@@@..@@@@@
         @@@@@@@@@@@......@@.@@@@
         @@@@@@@@.......@@@@@.@@@
         @@@@@@.......@@@@@@@@.@@
         @@@@@......@@@@@@@@..@.@
         @@@@.....@@@@@@@@....@.@
         @@@....@@@@@@@@......@.@
         @@....@.@@@@@....@....@.
         @@....@@..@.....@.@...@.
         @.....@@@@....@..@....@.
         @......@@@...@.@......@.
         @......@@@....@......@.@
         @.......@@@........@@@@.
         @.......@@@......@@@@@@.
         @........@@@....@@@@@@@.
         @.........@@@.@@@@....@.
         @@........@@.@@@@.....@.
         @@........@@.@@@....@@@.
         @@@.......@@.@@...@@@@.@
         @@@@......@@.@@.@@@@..@@
         @@@@@@....@@.@@@@@..@@@@
         @@@@@@@@...@.@@@..@@@@@@
         @@@@@@@@@@@.@@..@@@@@@@@
         @@@@@@@@@@@@..@@@@@@@@@@

							; SPR_FACEB:      EQU $3C
	A010 00 00 00 00 07 00 00 3F C0 01 FE 30 07 F1 C0 1F
	A020 8E 10 1E 70 08 21 80 04 3A 00 04 3A 00 02 74 00
	A030 02 74 00 02 68 00 02 42 00 02 42 00 02 46 00 02
	A040 5C 00 04 50 00 24 10 03 C8 0C 01 30 03 00 C0 00
	A050 E7 00 00 18 00 00 00 00 FF F8 FF FF C7 3F FE 3F
	A060 CF F9 FE 37 E7 F1 CF DF 8E 0F DE 70 07 A1 80 03
	A070 BA 00 03 BA 00 01 74 00 01 74 00 01 68 00 01 40
	A080 00 01 40 00 01 40 00 01 40 00 03 40 00 03 80 00
	A090 07 F0 00 0F FC 00 3F FF 00 FF FF E7 FF FF FF FF

         ........................
         .............@@@........
         ..........@@@@@@@@......
         .......@@@@@@@@...@@....
         .....@@@@@@@...@@@......
         ...@@@@@@...@@@....@....
         ...@@@@..@@@........@...
         ..@....@@............@..
         ..@@@.@..............@..
         ..@@@.@...............@.
         .@@@.@................@.
         .@@@.@................@.
         .@@.@.................@.
         .@....@...............@.
         .@....@...............@.
         .@...@@...............@.
         .@.@@@...............@..
         .@.@..............@..@..
         ...@..........@@@@..@...
         ....@@.........@..@@....
         ......@@........@@......
         ........@@@..@@@........
         ...........@@...........
         ........................

         @@@@@@@@@@@@@...@@@@@@@@
         @@@@@@@@@@...@@@..@@@@@@
         @@@@@@@...@@@@@@@@..@@@@
         @@@@@..@@@@@@@@...@@.@@@
         @@@..@@@@@@@...@@@..@@@@
         @@.@@@@@@...@@@.....@@@@
         @@.@@@@..@@@.........@@@
         @.@....@@.............@@
         @.@@@.@...............@@
         @.@@@.@................@
         .@@@.@.................@
         .@@@.@.................@
         .@@.@..................@
         .@.....................@
         .@.....................@
         .@.....................@
         .@....................@@
         .@....................@@
         @....................@@@
         @@@@................@@@@
         @@@@@@............@@@@@@
         @@@@@@@@........@@@@@@@@
         @@@@@@@@@@@..@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

							; SPR_TAP:        EQU $3D
	A0A0 00 00 00 00 3C 00 01 C3 80 06 3C 60 0D C3 B0 1A
	A0B0 24 58 0C 5A 30 16 24 68 09 C3 90 06 3C 60 09 C3
	A0C0 90 14 3C 28 19 00 98 36 24 6C 23 C3 C4 6B 66 D6
	A0D0 36 24 6C 5E A5 7A 27 66 E4 19 E7 98 06 24 60 01
	A0E0 DB 80 00 3C 00 00 00 00 FF C3 FF FE 3C 7F F9 C3
	A0F0 9F F6 00 6F EC 00 37 D8 00 1B EC 18 37 C6 00 63
	A100 E1 C3 87 F0 3C 0F E8 00 17 C4 00 23 C1 00 83 80
	A110 24 01 80 00 01 08 00 10 80 00 01 40 81 02 A0 00
	A120 05 D8 00 1B E6 00 67 F9 DB 9F FE 3C 7F FF C3 FF

         ........................
         ..........@@@@..........
         .......@@@....@@@.......
         .....@@...@@@@...@@.....
         ....@@.@@@....@@@.@@....
         ...@@.@...@..@...@.@@...
         ....@@...@.@@.@...@@....
         ...@.@@...@..@...@@.@...
         ....@..@@@....@@@..@....
         .....@@...@@@@...@@.....
         ....@..@@@....@@@..@....
         ...@.@....@@@@....@.@...
         ...@@..@........@..@@...
         ..@@.@@...@..@...@@.@@..
         ..@...@@@@....@@@@...@..
         .@@.@.@@.@@..@@.@@.@.@@.
         ..@@.@@...@..@...@@.@@..
         .@.@@@@.@.@..@.@.@@@@.@.
         ..@..@@@.@@..@@.@@@..@..
         ...@@..@@@@..@@@@..@@...
         .....@@...@..@...@@.....
         .......@@@.@@.@@@.......
         ..........@@@@..........
         ........................

         @@@@@@@@@@....@@@@@@@@@@
         @@@@@@@...@@@@...@@@@@@@
         @@@@@..@@@....@@@..@@@@@
         @@@@.@@..........@@.@@@@
         @@@.@@............@@.@@@
         @@.@@..............@@.@@
         @@@.@@.....@@.....@@.@@@
         @@...@@..........@@...@@
         @@@....@@@....@@@....@@@
         @@@@......@@@@......@@@@
         @@@.@..............@.@@@
         @@...@............@...@@
         @@.....@........@.....@@
         @.........@..@.........@
         @......................@
         ....@..............@....
         @......................@
         .@......@......@......@.
         @.@..................@.@
         @@.@@..............@@.@@
         @@@..@@..........@@..@@@
         @@@@@..@@@.@@.@@@..@@@@@
         @@@@@@@...@@@@...@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_CHIMP:      EQU $3E
	A130 00 3C 00 00 C3 00 01 00 00 02 00 C0 02 03 20 04
	A140 1C A0 04 33 00 04 49 E0 18 77 80 14 34 A0 0E 02
	A150 F0 04 0F E0 02 0F 90 02 00 70 01 07 E0 0B 03 D0
	A160 1A 00 18 0C 00 30 16 00 68 09 C3 90 06 3C 60 01
	A170 C3 80 00 3C 00 00 00 00 FF C3 FF FF 00 FF FE 00
	A180 3F FC 00 DF FC 03 2F F8 1C 2F F8 33 1F E0 41 EF
	A190 C0 77 8F C4 34 AF EE 02 F7 F4 0F EF F8 0F 97 FC
	A1A0 00 77 F0 07 EF E8 03 D7 D8 00 1B EC 00 37 C6 00
	A1B0 63 E1 C3 87 F0 3C 0F F8 00 1F FE 00 7F FF C3 FF

         ..........@@@@..........
         ........@@....@@........
         .......@................
         ......@.........@@......
         ......@.......@@..@.....
         .....@.....@@@..@.@.....
         .....@....@@..@@........
         .....@...@..@..@@@@.....
         ...@@....@@@.@@@@.......
         ...@.@....@@.@..@.@.....
         ....@@@.......@.@@@@....
         .....@......@@@@@@@.....
         ......@.....@@@@@..@....
         ......@..........@@@....
         .......@.....@@@@@@.....
         ....@.@@......@@@@.@....
         ...@@.@............@@...
         ....@@............@@....
         ...@.@@..........@@.@...
         ....@..@@@....@@@..@....
         .....@@...@@@@...@@.....
         .......@@@....@@@.......
         ..........@@@@..........
         ........................

         @@@@@@@@@@....@@@@@@@@@@
         @@@@@@@@........@@@@@@@@
         @@@@@@@...........@@@@@@
         @@@@@@..........@@.@@@@@
         @@@@@@........@@..@.@@@@
         @@@@@......@@@....@.@@@@
         @@@@@.....@@..@@...@@@@@
         @@@......@.....@@@@.@@@@
         @@.......@@@.@@@@...@@@@
         @@...@....@@.@..@.@.@@@@
         @@@.@@@.......@.@@@@.@@@
         @@@@.@......@@@@@@@.@@@@
         @@@@@.......@@@@@..@.@@@
         @@@@@@...........@@@.@@@
         @@@@.........@@@@@@.@@@@
         @@@.@.........@@@@.@.@@@
         @@.@@..............@@.@@
         @@@.@@............@@.@@@
         @@...@@..........@@...@@
         @@@....@@@....@@@....@@@
         @@@@......@@@@......@@@@
         @@@@@..............@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_CHIMPB:     EQU $3F
	A1C0 00 3C 00 00 C3 00 01 00 80 02 00 40 00 00 20 04
	A1D0 00 20 0C 00 10 00 00 18 0C 00 18 18 40 10 18 A0
	A1E0 10 08 E0 20 10 40 20 08 00 40 00 00 40 08 00 B0
	A1F0 18 00 58 0C 00 30 16 00 68 09 C3 90 06 3C 60 01
	A200 C3 80 00 3C 00 00 00 00 FF C3 FF FF 00 FF FE 00
	A210 7F FC 00 3F F8 00 1F F4 00 0F EC 00 07 F0 00 03
	A220 EC 00 03 D8 00 07 D8 80 0F E8 C0 1F D0 00 1F E8
	A230 00 3F F0 00 0F E8 00 37 D8 00 1B EC 00 37 C6 00
	A240 63 E1 C3 87 F0 3C 0F F8 00 1F FE 00 7F FF C3 FF

         ..........@@@@..........
         ........@@....@@........
         .......@........@.......
         ......@..........@......
         ..................@.....
         .....@............@.....
         ....@@.............@....
         ...................@@...
         ....@@.............@@...
         ...@@....@.........@....
         ...@@...@.@........@....
         ....@...@@@.......@.....
         ...@.....@........@.....
         ....@............@......
         .................@......
         ....@...........@.@@....
         ...@@............@.@@...
         ....@@............@@....
         ...@.@@..........@@.@...
         ....@..@@@....@@@..@....
         .....@@...@@@@...@@.....
         .......@@@....@@@.......
         ..........@@@@..........
         ........................

         @@@@@@@@@@....@@@@@@@@@@
         @@@@@@@@........@@@@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@@............@@@@@@
         @@@@@..............@@@@@
         @@@@.@..............@@@@
         @@@.@@...............@@@
         @@@@..................@@
         @@@.@@................@@
         @@.@@................@@@
         @@.@@...@...........@@@@
         @@@.@...@@.........@@@@@
         @@.@...............@@@@@
         @@@.@.............@@@@@@
         @@@@................@@@@
         @@@.@.............@@.@@@
         @@.@@..............@@.@@
         @@@.@@............@@.@@@
         @@...@@..........@@...@@
         @@@....@@@....@@@....@@@
         @@@@......@@@@......@@@@
         @@@@@..............@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_CHARLES:    EQU $40
	A250 00 00 00 00 7E 30 01 81 48 02 03 B8 04 7F 98 34
	A260 FE 58 49 8D D0 75 74 50 65 C5 80 35 B4 40 1F C6
	A270 C0 0B BF 40 07 F7 80 03 EF 80 03 F0 40 0B FD D0
	A280 1B EE D8 0D CF B0 16 76 68 09 81 90 06 3C 60 01
	A290 C3 80 00 3C 00 00 00 00 FF FF CF FF 80 B7 FE 01
	A2A0 4B FC 03 BB C8 7F 9B B0 FE 5B 49 8D D7 75 74 57
	A2B0 65 C4 0F B5 84 5F DF C6 DF EB BF 5F F7 F7 BF FB
	A2C0 EF BF F3 F0 4F EB FD D7 DB EE DB ED CF B7 C6 76
	A2D0 63 E1 81 87 F0 3C 0F F8 00 1F FE 00 7F FF C3 FF

         ........................
         .........@@@@@@...@@....
         .......@@......@.@..@...
         ......@.......@@@.@@@...
         .....@...@@@@@@@@..@@...
         ..@@.@..@@@@@@@..@.@@...
         .@..@..@@...@@.@@@.@....
         .@@@.@.@.@@@.@...@.@....
         .@@..@.@@@...@.@@.......
         ..@@.@.@@.@@.@...@......
         ...@@@@@@@...@@.@@......
         ....@.@@@.@@@@@@.@......
         .....@@@@@@@.@@@@.......
         ......@@@@@.@@@@@.......
         ......@@@@@@.....@......
         ....@.@@@@@@@@.@@@.@....
         ...@@.@@@@@.@@@.@@.@@...
         ....@@.@@@..@@@@@.@@....
         ...@.@@..@@@.@@..@@.@...
         ....@..@@......@@..@....
         .....@@...@@@@...@@.....
         .......@@@....@@@.......
         ..........@@@@..........
         ........................

         @@@@@@@@@@@@@@@@@@..@@@@
         @@@@@@@@@.......@.@@.@@@
         @@@@@@@........@.@..@.@@
         @@@@@@........@@@.@@@.@@
         @@..@....@@@@@@@@..@@.@@
         @.@@....@@@@@@@..@.@@.@@
         .@..@..@@...@@.@@@.@.@@@
         .@@@.@.@.@@@.@...@.@.@@@
         .@@..@.@@@...@......@@@@
         @.@@.@.@@....@...@.@@@@@
         @@.@@@@@@@...@@.@@.@@@@@
         @@@.@.@@@.@@@@@@.@.@@@@@
         @@@@.@@@@@@@.@@@@.@@@@@@
         @@@@@.@@@@@.@@@@@.@@@@@@
         @@@@..@@@@@@.....@..@@@@
         @@@.@.@@@@@@@@.@@@.@.@@@
         @@.@@.@@@@@.@@@.@@.@@.@@
         @@@.@@.@@@..@@@@@.@@.@@@
         @@...@@..@@@.@@..@@...@@
         @@@....@@......@@....@@@
         @@@@......@@@@......@@@@
         @@@@@..............@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_CHARLESB:   EQU $41
	A2E0 00 00 00 00 7E 00 01 81 B0 02 00 78 02 00 38 04
	A2F0 40 B8 18 61 B0 3C 3F 20 3C 08 20 3E 00 20 1E 00
	A300 20 0E 86 40 07 CF C0 03 FF C0 03 FF C0 0B FF D0
	A310 1B FE D8 0D F9 B0 16 7E 68 09 81 90 06 3C 60 01
	A320 C3 80 00 3C 00 00 00 00 FF FF FF FF 81 CF FE 00
	A330 37 FC 00 3B FC 00 1B E0 00 1B D8 00 17 BC 00 0F
	A340 BC 00 1F BE 00 1F DE 00 1F EE 86 5F F7 CF DF FB
	A350 FF DF F3 FF CF EB FF D7 DB FE DB ED F9 B7 C6 7E
	A360 63 E1 81 87 F0 3C 0F F8 00 1F FE 00 7F FF C3 FF

         ........................
         .........@@@@@@.........
         .......@@......@@.@@....
         ......@..........@@@@...
         ......@...........@@@...
         .....@...@......@.@@@...
         ...@@....@@....@@.@@....
         ..@@@@....@@@@@@..@.....
         ..@@@@......@.....@.....
         ..@@@@@...........@.....
         ...@@@@...........@.....
         ....@@@.@....@@..@......
         .....@@@@@..@@@@@@......
         ......@@@@@@@@@@@@......
         ......@@@@@@@@@@@@......
         ....@.@@@@@@@@@@@@.@....
         ...@@.@@@@@@@@@.@@.@@...
         ....@@.@@@@@@..@@.@@....
         ...@.@@..@@@@@@..@@.@...
         ....@..@@......@@..@....
         .....@@...@@@@...@@.....
         .......@@@....@@@.......
         ..........@@@@..........
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@......@@@..@@@@
         @@@@@@@...........@@.@@@
         @@@@@@............@@@.@@
         @@@@@@.............@@.@@
         @@@................@@.@@
         @@.@@..............@.@@@
         @.@@@@..............@@@@
         @.@@@@.............@@@@@
         @.@@@@@............@@@@@
         @@.@@@@............@@@@@
         @@@.@@@.@....@@..@.@@@@@
         @@@@.@@@@@..@@@@@@.@@@@@
         @@@@@.@@@@@@@@@@@@.@@@@@
         @@@@..@@@@@@@@@@@@..@@@@
         @@@.@.@@@@@@@@@@@@.@.@@@
         @@.@@.@@@@@@@@@.@@.@@.@@
         @@@.@@.@@@@@@..@@.@@.@@@
         @@...@@..@@@@@@..@@...@@
         @@@....@@......@@....@@@
         @@@@......@@@@......@@@@
         @@@@@..............@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_TRUNK:      EQU $42
	A370 00 00 00 00 0E 60 00 7F B0 01 FC C8 03 CB 58 1B
	A380 B2 68 3D A4 70 63 C7 B0 5B EF D0 3F FF EC 1B FB
	A390 DA 0B F3 F2 01 F0 FC 00 E6 38 01 39 80 0B CF 50
	A3A0 1B F0 D8 0D FF B0 16 3C 68 09 C3 90 06 3C 60 01
	A3B0 C3 80 00 3C 00 00 00 00 FF F1 9F FF 80 0F FE 00
	A3C0 07 FC 00 0B E0 03 1B C0 32 0B 80 20 07 00 00 07
	A3D0 18 00 03 BC 00 01 D8 00 00 E8 00 00 F4 00 01 FC
	A3E0 06 03 F0 00 07 E8 00 17 D8 00 1B EC 00 37 C6 00
	A3F0 63 E1 C3 87 F0 3C 0F F8 00 1F FE 00 7F FF C3 FF

         ........................
         ............@@@..@@.....
         .........@@@@@@@@.@@....
         .......@@@@@@@..@@..@...
         ......@@@@..@.@@.@.@@...
         ...@@.@@@.@@..@..@@.@...
         ..@@@@.@@.@..@...@@@....
         .@@...@@@@...@@@@.@@....
         .@.@@.@@@@@.@@@@@@.@....
         ..@@@@@@@@@@@@@@@@@.@@..
         ...@@.@@@@@@@.@@@@.@@.@.
         ....@.@@@@@@..@@@@@@..@.
         .......@@@@@....@@@@@@..
         ........@@@..@@...@@@...
         .......@..@@@..@@.......
         ....@.@@@@..@@@@.@.@....
         ...@@.@@@@@@....@@.@@...
         ....@@.@@@@@@@@@@.@@....
         ...@.@@...@@@@...@@.@...
         ....@..@@@....@@@..@....
         .....@@...@@@@...@@.....
         .......@@@....@@@.......
         ..........@@@@..........
         ........................

         @@@@@@@@@@@@...@@..@@@@@
         @@@@@@@@@...........@@@@
         @@@@@@@..............@@@
         @@@@@@..............@.@@
         @@@...........@@...@@.@@
         @@........@@..@.....@.@@
         @.........@..........@@@
         .....................@@@
         ...@@.................@@
         @.@@@@.................@
         @@.@@...................
         @@@.@...................
         @@@@.@.................@
         @@@@@@.......@@.......@@
         @@@@.................@@@
         @@@.@..............@.@@@
         @@.@@..............@@.@@
         @@@.@@............@@.@@@
         @@...@@..........@@...@@
         @@@....@@@....@@@....@@@
         @@@@......@@@@......@@@@
         @@@@@..............@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_TRUNKB:     EQU $43
	A400 00 00 00 18 06 70 3C 3F B0 3E FB D8 3D FF E8 1D
	A410 FF E8 1A FF F0 07 FF F0 07 FF F0 0F FF F0 0F BF
	A420 E0 06 7F E0 01 FF 40 01 FE 80 01 BE 40 0C 7D D0
	A430 1B BF D8 0D FF B0 16 3C 68 09 C3 90 06 3C 60 01
	A440 C3 80 00 3C 00 00 00 00 E7 F9 8F C3 C0 07 81 00
	A450 07 80 00 03 80 00 03 C0 00 03 C0 00 07 E0 00 07
	A460 F0 00 07 E0 00 07 E0 00 0F F0 00 0F F8 00 1F FC
	A470 00 1F F0 00 0F EC 00 17 D8 00 1B CC 00 33 C6 00
	A480 63 E1 C3 87 F0 3C 0F F8 00 1F FE 00 7F FF C3 FF

         ........................
         ...@@........@@..@@@....
         ..@@@@....@@@@@@@.@@....
         ..@@@@@.@@@@@.@@@@.@@...
         ..@@@@.@@@@@@@@@@@@.@...
         ...@@@.@@@@@@@@@@@@.@...
         ...@@.@.@@@@@@@@@@@@....
         .....@@@@@@@@@@@@@@@....
         .....@@@@@@@@@@@@@@@....
         ....@@@@@@@@@@@@@@@@....
         ....@@@@@.@@@@@@@@@.....
         .....@@..@@@@@@@@@@.....
         .......@@@@@@@@@.@......
         .......@@@@@@@@.@.......
         .......@@.@@@@@..@......
         ....@@...@@@@@.@@@.@....
         ...@@.@@@.@@@@@@@@.@@...
         ....@@.@@@@@@@@@@.@@....
         ...@.@@...@@@@...@@.@...
         ....@..@@@....@@@..@....
         .....@@...@@@@...@@.....
         .......@@@....@@@.......
         ..........@@@@..........
         ........................

         @@@..@@@@@@@@..@@...@@@@
         @@....@@@@...........@@@
         @......@.............@@@
         @.....................@@
         @.....................@@
         @@....................@@
         @@...................@@@
         @@@..................@@@
         @@@@.................@@@
         @@@..................@@@
         @@@.................@@@@
         @@@@................@@@@
         @@@@@..............@@@@@
         @@@@@@.............@@@@@
         @@@@................@@@@
         @@@.@@.............@.@@@
         @@.@@..............@@.@@
         @@..@@............@@..@@
         @@...@@..........@@...@@
         @@@....@@@....@@@....@@@
         @@@@......@@@@......@@@@
         @@@@@..............@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@

							; SPR_HELIPLAT1:  EQU $44
	A490 00 00 00 00 3C 00 00 E7 00 03 81 C0 0E 3C 70 38
	A4A0 E7 1C 63 81 C6 38 E7 1C 4E 3C 72 73 81 CE 5C E7
	A4B0 3A 47 3C E2 36 C3 6C 4E 24 70 73 A5 CC 7C E7 1E
	A4C0 0F 24 E2 00 01 FE 00 70 1E 00 60 00 00 20 00 00
	A4D0 60 00 00 60 00 00 00 00 FF C3 FF FF 3C FF FC E7
	A4E0 3F F3 81 CF CE 00 73 B8 00 1D 60 00 06 B8 00 1D
	A4F0 0E 00 70 03 81 C0 00 E7 00 00 3C 00 80 00 01 40
	A500 00 03 70 00 0D 7C 00 1E 8F 00 E2 F0 01 FE FF 76
	A510 1E FF 6F E1 FF AF FF FF 6F FF FF 6F FF FF 9F FF

         ........................
         ..........@@@@..........
         ........@@@..@@@........
         ......@@@......@@@......
         ....@@@...@@@@...@@@....
         ..@@@...@@@..@@@...@@@..
         .@@...@@@......@@@...@@.
         ..@@@...@@@..@@@...@@@..
         .@..@@@...@@@@...@@@..@.
         .@@@..@@@......@@@..@@@.
         .@.@@@..@@@..@@@..@@@.@.
         .@...@@@..@@@@..@@@...@.
         ..@@.@@.@@....@@.@@.@@..
         .@..@@@...@..@...@@@....
         .@@@..@@@.@..@.@@@..@@..
         .@@@@@..@@@..@@@...@@@@.
         ....@@@@..@..@..@@@...@.
         ...............@@@@@@@@.
         .........@@@.......@@@@.
         .........@@.............
         ..........@.............
         .........@@.............
         .........@@.............
         ........................

         @@@@@@@@@@....@@@@@@@@@@
         @@@@@@@@..@@@@..@@@@@@@@
         @@@@@@..@@@..@@@..@@@@@@
         @@@@..@@@......@@@..@@@@
         @@..@@@..........@@@..@@
         @.@@@..............@@@.@
         .@@..................@@.
         @.@@@..............@@@.@
         ....@@@..........@@@....
         ......@@@......@@@......
         ........@@@..@@@........
         ..........@@@@..........
         @......................@
         .@....................@@
         .@@@................@@.@
         .@@@@@.............@@@@.
         @...@@@@........@@@...@.
         @@@@...........@@@@@@@@.
         @@@@@@@@.@@@.@@....@@@@.
         @@@@@@@@.@@.@@@@@@@....@
         @@@@@@@@@.@.@@@@@@@@@@@@
         @@@@@@@@.@@.@@@@@@@@@@@@
         @@@@@@@@.@@.@@@@@@@@@@@@
         @@@@@@@@@..@@@@@@@@@@@@@

							; SPR_HELIPLAT2:  EQU $45
	A520 00 00 00 00 3C 00 00 E7 00 03 81 C0 0E 3C 70 38
	A530 E7 1C 63 81 C6 38 E7 1C 4E 3C 72 73 81 CE 5C E7
	A540 3A 47 3C E2 36 C3 6C 0E 24 70 13 A5 C0 0C E7 00
	A550 00 25 E0 01 C2 70 03 B7 98 07 61 E0 06 C0 78 01
	A560 80 18 07 00 00 00 00 00 FF C3 FF FF 3C FF FC E7
	A570 3F F3 81 CF CE 00 73 B8 00 1D 60 00 06 B8 00 1D
	A580 0E 00 70 03 81 C0 00 E7 00 00 3C 00 80 00 01 C0
	A590 00 03 D0 00 0F EC 00 1F F2 01 EF FD C2 77 FB B7
	A5A0 9B F7 69 E7 F6 DE 7B F9 BF 9B F7 7F E7 F8 FF FF

         ........................
         ..........@@@@..........
         ........@@@..@@@........
         ......@@@......@@@......
         ....@@@...@@@@...@@@....
         ..@@@...@@@..@@@...@@@..
         .@@...@@@......@@@...@@.
         ..@@@...@@@..@@@...@@@..
         .@..@@@...@@@@...@@@..@.
         .@@@..@@@......@@@..@@@.
         .@.@@@..@@@..@@@..@@@.@.
         .@...@@@..@@@@..@@@...@.
         ..@@.@@.@@....@@.@@.@@..
         ....@@@...@..@...@@@....
         ...@..@@@.@..@.@@@......
         ....@@..@@@..@@@........
         ..........@..@.@@@@.....
         .......@@@....@..@@@....
         ......@@@.@@.@@@@..@@...
         .....@@@.@@....@@@@.....
         .....@@.@@.......@@@@...
         .......@@..........@@...
         .....@@@................
         ........................

         @@@@@@@@@@....@@@@@@@@@@
         @@@@@@@@..@@@@..@@@@@@@@
         @@@@@@..@@@..@@@..@@@@@@
         @@@@..@@@......@@@..@@@@
         @@..@@@..........@@@..@@
         @.@@@..............@@@.@
         .@@..................@@.
         @.@@@..............@@@.@
         ....@@@..........@@@....
         ......@@@......@@@......
         ........@@@..@@@........
         ..........@@@@..........
         @......................@
         @@....................@@
         @@.@................@@@@
         @@@.@@.............@@@@@
         @@@@..@........@@@@.@@@@
         @@@@@@.@@@....@..@@@.@@@
         @@@@@.@@@.@@.@@@@..@@.@@
         @@@@.@@@.@@.@..@@@@..@@@
         @@@@.@@.@@.@@@@..@@@@.@@
         @@@@@..@@.@@@@@@@..@@.@@
         @@@@.@@@.@@@@@@@@@@..@@@
         @@@@@...@@@@@@@@@@@@@@@@

							; SPR_BONGO:      EQU $46
	A5B0 00 00 00 00 00 00 00 7E 00 03 FF C0 0F FF F0 1F
	A5C0 FF F8 3F FF FC 3F FF FC 5F FF FA 7F FF FE 37 FF
	A5D0 EC 7E FF 7E 47 DB E2 21 FF 84 2C E7 34 57 6A EA
	A5E0 17 B5 E8 4B 42 D2 2A 99 54 15 3C A8 06 7E 60 01
	A5F0 81 80 00 7E 00 00 00 00 FF FF FF FF 81 FF FC 7E
	A600 3F F3 FF CF EF FF F7 DF FF FB BF FF FD BF FF FD
	A610 5F FF FA 7F FF FE B7 FF ED 7E FF 7E 47 DB E2 A1
	A620 FF 85 A0 E7 05 10 6A 08 90 34 09 48 42 12 A8 81
	A630 15 D5 00 AB E6 00 67 F9 81 9F FE 7E 7F FF 81 FF

         ........................
         ........................
         .........@@@@@@.........
         ......@@@@@@@@@@@@......
         ....@@@@@@@@@@@@@@@@....
         ...@@@@@@@@@@@@@@@@@@...
         ..@@@@@@@@@@@@@@@@@@@@..
         ..@@@@@@@@@@@@@@@@@@@@..
         .@.@@@@@@@@@@@@@@@@@@.@.
         .@@@@@@@@@@@@@@@@@@@@@@.
         ..@@.@@@@@@@@@@@@@@.@@..
         .@@@@@@.@@@@@@@@.@@@@@@.
         .@...@@@@@.@@.@@@@@...@.
         ..@....@@@@@@@@@@....@..
         ..@.@@..@@@..@@@..@@.@..
         .@.@.@@@.@@.@.@.@@@.@.@.
         ...@.@@@@.@@.@.@@@@.@...
         .@..@.@@.@....@.@@.@..@.
         ..@.@.@.@..@@..@.@.@.@..
         ...@.@.@..@@@@..@.@.@...
         .....@@..@@@@@@..@@.....
         .......@@......@@.......
         .........@@@@@@.........
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@......@@@@@@@@@
         @@@@@@...@@@@@@...@@@@@@
         @@@@..@@@@@@@@@@@@..@@@@
         @@@.@@@@@@@@@@@@@@@@.@@@
         @@.@@@@@@@@@@@@@@@@@@.@@
         @.@@@@@@@@@@@@@@@@@@@@.@
         @.@@@@@@@@@@@@@@@@@@@@.@
         .@.@@@@@@@@@@@@@@@@@@.@.
         .@@@@@@@@@@@@@@@@@@@@@@.
         @.@@.@@@@@@@@@@@@@@.@@.@
         .@@@@@@.@@@@@@@@.@@@@@@.
         .@...@@@@@.@@.@@@@@...@.
         @.@....@@@@@@@@@@....@.@
         @.@.....@@@..@@@.....@.@
         ...@.....@@.@.@.....@...
         @..@......@@.@......@..@
         .@..@....@....@....@..@.
         @.@.@...@......@...@.@.@
         @@.@.@.@........@.@.@.@@
         @@@..@@..........@@..@@@
         @@@@@..@@......@@..@@@@@
         @@@@@@@..@@@@@@..@@@@@@@
         @@@@@@@@@......@@@@@@@@@

							; SPR_DRUM:       EQU $47
	A640 00 00 00 00 7E 00 03 FF C0 0F FF F0 1F FF F8 3F
	A650 FF FC 3F FF FC 3F FF FC 5F FF FA 4F FF F2 33 FF
	A660 CC 54 7E 2A 8D 81 B1 81 BD 81 98 3C 11 AA 80 A9
	A670 51 55 52 5A AA A2 28 55 04 12 00 48 0C 54 30 03
	A680 81 C0 00 7E 00 00 00 00 FF 81 FF FC 7E 3F F3 FF
	A690 CF EF FF F7 DF FF FB BF FF FD BF FF FD BF FF FD
	A6A0 5F FF FA 4F FF F2 B3 FF CD D4 7E 2B AD 81 B5 A1
	A6B0 BD 8D 98 3C 05 88 00 01 D0 00 03 D8 00 03 E8 00
	A6C0 07 F2 00 0F FC 00 3F FF 81 FF FF FF FF FF FF FF

         ........................
         .........@@@@@@.........
         ......@@@@@@@@@@@@......
         ....@@@@@@@@@@@@@@@@....
         ...@@@@@@@@@@@@@@@@@@...
         ..@@@@@@@@@@@@@@@@@@@@..
         ..@@@@@@@@@@@@@@@@@@@@..
         ..@@@@@@@@@@@@@@@@@@@@..
         .@.@@@@@@@@@@@@@@@@@@.@.
         .@..@@@@@@@@@@@@@@@@..@.
         ..@@..@@@@@@@@@@@@..@@..
         .@.@.@...@@@@@@...@.@.@.
         @...@@.@@......@@.@@...@
         @......@@.@@@@.@@......@
         @..@@.....@@@@.....@...@
         @.@.@.@.@.......@.@.@..@
         .@.@...@.@.@.@.@.@.@..@.
         .@.@@.@.@.@.@.@.@.@...@.
         ..@.@....@.@.@.@.....@..
         ...@..@..........@..@...
         ....@@...@.@.@....@@....
         ......@@@......@@@......
         .........@@@@@@.........
         ........................

         @@@@@@@@@......@@@@@@@@@
         @@@@@@...@@@@@@...@@@@@@
         @@@@..@@@@@@@@@@@@..@@@@
         @@@.@@@@@@@@@@@@@@@@.@@@
         @@.@@@@@@@@@@@@@@@@@@.@@
         @.@@@@@@@@@@@@@@@@@@@@.@
         @.@@@@@@@@@@@@@@@@@@@@.@
         @.@@@@@@@@@@@@@@@@@@@@.@
         .@.@@@@@@@@@@@@@@@@@@.@.
         .@..@@@@@@@@@@@@@@@@..@.
         @.@@..@@@@@@@@@@@@..@@.@
         @@.@.@...@@@@@@...@.@.@@
         @.@.@@.@@......@@.@@.@.@
         @.@....@@.@@@@.@@...@@.@
         @..@@.....@@@@.......@.@
         @...@..................@
         @@.@..................@@
         @@.@@.................@@
         @@@.@................@@@
         @@@@..@.............@@@@
         @@@@@@............@@@@@@
         @@@@@@@@@......@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

							; SPR_WELL:       EQU $48
	A6D0 00 00 00 00 7E 00 03 BD C0 0F 81 F0 14 7E 28 3B
	A6E0 7E DC 3B 00 DC 14 00 28 2F 81 F4 23 7E C4 2C 7E
	A6F0 34 0F 00 F0 2F 7E F4 33 7E CC 38 7E 1C 1B 00 D8
	A700 2B E7 D4 23 E7 C4 2C E7 34 0F 00 F0 0F 7E F0 03
	A710 7E C0 00 7E 00 00 00 00 FF 81 FF FC 7E 3F F3 BD
	A720 CF EF 81 F7 D4 00 2B B8 00 1D B8 00 1D 94 00 29
	A730 8F 81 F1 83 7E C1 80 7E 01 C0 00 03 80 00 01 80
	A740 00 01 80 00 01 C0 00 03 80 00 01 80 00 01 80 00
	A750 01 C0 00 03 E0 00 07 F0 00 0F FC 00 3F FF 81 FF

         ........................
         .........@@@@@@.........
         ......@@@.@@@@.@@@......
         ....@@@@@......@@@@@....
         ...@.@...@@@@@@...@.@...
         ..@@@.@@.@@@@@@.@@.@@@..
         ..@@@.@@........@@.@@@..
         ...@.@............@.@...
         ..@.@@@@@......@@@@@.@..
         ..@...@@.@@@@@@.@@...@..
         ..@.@@...@@@@@@...@@.@..
         ....@@@@........@@@@....
         ..@.@@@@.@@@@@@.@@@@.@..
         ..@@..@@.@@@@@@.@@..@@..
         ..@@@....@@@@@@....@@@..
         ...@@.@@........@@.@@...
         ..@.@.@@@@@..@@@@@.@.@..
         ..@...@@@@@..@@@@@...@..
         ..@.@@..@@@..@@@..@@.@..
         ....@@@@........@@@@....
         ....@@@@.@@@@@@.@@@@....
         ......@@.@@@@@@.@@......
         .........@@@@@@.........
         ........................

         @@@@@@@@@......@@@@@@@@@
         @@@@@@...@@@@@@...@@@@@@
         @@@@..@@@.@@@@.@@@..@@@@
         @@@.@@@@@......@@@@@.@@@
         @@.@.@............@.@.@@
         @.@@@..............@@@.@
         @.@@@..............@@@.@
         @..@.@............@.@..@
         @...@@@@@......@@@@@...@
         @.....@@.@@@@@@.@@.....@
         @........@@@@@@........@
         @@....................@@
         @......................@
         @......................@
         @......................@
         @@....................@@
         @......................@
         @......................@
         @......................@
         @@....................@@
         @@@..................@@@
         @@@@................@@@@
         @@@@@@............@@@@@@
         @@@@@@@@@......@@@@@@@@@

							; SPR_STICK:      EQU $49
	A760 00 7E 00 03 81 C0 0C 00 30 10 00 08 20 00 04 20
	A770 00 04 40 00 02 50 00 0A 40 00 02 40 00 02 22 00
	A780 44 21 81 84 10 7E 08 0C 00 30 03 81 C0 04 7E 20
	A790 1A 00 58 3A 00 5C 1D 81 B8 06 7E 60 01 81 80 00
	A7A0 7E 00 00 18 00 00 00 00 FF 81 FF FC 00 3F F0 00
	A7B0 0F E0 00 07 C0 00 03 C0 00 03 80 00 01 80 00 01
	A7C0 80 00 01 80 00 01 C0 00 03 C0 00 03 E0 00 07 F0
	A7D0 00 0F F8 00 1F E4 00 27 D8 00 1B B8 00 1D DC 00
	A7E0 3B E6 00 67 F9 81 9F FE 7E 7F FF 99 FF FF E7 FF

         .........@@@@@@.........
         ......@@@......@@@......
         ....@@............@@....
         ...@................@...
         ..@..................@..
         ..@..................@..
         .@....................@.
         .@.@................@.@.
         .@....................@.
         .@....................@.
         ..@...@..........@...@..
         ..@....@@......@@....@..
         ...@.....@@@@@@.....@...
         ....@@............@@....
         ......@@@......@@@......
         .....@...@@@@@@...@.....
         ...@@.@..........@.@@...
         ..@@@.@..........@.@@@..
         ...@@@.@@......@@.@@@...
         .....@@..@@@@@@..@@.....
         .......@@......@@.......
         .........@@@@@@.........
         ...........@@...........
         ........................

         @@@@@@@@@......@@@@@@@@@
         @@@@@@............@@@@@@
         @@@@................@@@@
         @@@..................@@@
         @@....................@@
         @@....................@@
         @......................@
         @......................@
         @......................@
         @......................@
         @@....................@@
         @@....................@@
         @@@..................@@@
         @@@@................@@@@
         @@@@@..............@@@@@
         @@@..@............@..@@@
         @@.@@..............@@.@@
         @.@@@..............@@@.@
         @@.@@@............@@@.@@
         @@@..@@..........@@..@@@
         @@@@@..@@......@@..@@@@@
         @@@@@@@..@@@@@@..@@@@@@@
         @@@@@@@@@..@@..@@@@@@@@@
         @@@@@@@@@@@..@@@@@@@@@@@

							; SPR_TRUNKS:     EQU $4A
	A7F0 00 00 00 00 3C 00 00 C3 00 01 00 80 0F 00 F0 30
	A800 DB 0C 40 24 02 40 DB 02 71 00 8E 3E 00 7C 3D 00
	A810 BC 4D 81 B2 71 E7 8E 5C FF 3A 37 3C EC 4D C3 B2
	A820 73 7E CE 7C DB 3E 3D 3C BC 05 C3 A0 01 FF 80 00
	A830 FF 00 00 18 00 00 00 00 FF FF FF FF C3 FF FF 00
	A840 FF FE 00 7F F0 00 0F C0 18 03 00 24 00 00 18 00
	A850 00 00 00 80 00 01 80 00 01 40 00 02 70 00 0E 5C
	A860 00 3A B7 00 ED 0D C3 B0 03 7E C0 00 DB 00 80 3C
	A870 01 C0 00 03 F8 00 1F FE 00 7F FF 00 FF FF E7 FF

         ........................
         ..........@@@@..........
         ........@@....@@........
         .......@........@.......
         ....@@@@........@@@@....
         ..@@....@@.@@.@@....@@..
         .@........@..@........@.
         .@......@@.@@.@@......@.
         .@@@...@........@...@@@.
         ..@@@@@..........@@@@@..
         ..@@@@.@........@.@@@@..
         .@..@@.@@......@@.@@..@.
         .@@@...@@@@..@@@@...@@@.
         .@.@@@..@@@@@@@@..@@@.@.
         ..@@.@@@..@@@@..@@@.@@..
         .@..@@.@@@....@@@.@@..@.
         .@@@..@@.@@@@@@.@@..@@@.
         .@@@@@..@@.@@.@@..@@@@@.
         ..@@@@.@..@@@@..@.@@@@..
         .....@.@@@....@@@.@.....
         .......@@@@@@@@@@.......
         ........@@@@@@@@........
         ...........@@...........
         ........................

         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@....@@@@@@@@@@
         @@@@@@@@........@@@@@@@@
         @@@@@@@..........@@@@@@@
         @@@@................@@@@
         @@.........@@.........@@
         ..........@..@..........
         ...........@@...........
         ........................
         @......................@
         @......................@
         .@....................@.
         .@@@................@@@.
         .@.@@@............@@@.@.
         @.@@.@@@........@@@.@@.@
         ....@@.@@@....@@@.@@....
         ......@@.@@@@@@.@@......
         ........@@.@@.@@........
         @.........@@@@.........@
         @@....................@@
         @@@@@..............@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@@@@........@@@@@@@@
         @@@@@@@@@@@..@@@@@@@@@@@

							; SPR_DECK:       EQU $4B
	A880 00 00 00 00 18 00 00 66 00 01 89 80 06 54 60 18
	A890 AA 98 35 55 4C 32 AA AC 39 55 1C 5E 2A 7A 67 91
	A8A0 E6 79 E7 9E 1E 7E 78 67 99 E6 79 E7 9E 1E 7E 78
	A8B0 27 99 E4 39 E7 9C 1E 7E 78 07 99 E0 01 E7 80 00
	A8C0 7E 00 00 18 00 00 00 00 FF E7 FF FF 81 FF FE 00
	A8D0 7F F8 08 1F E0 54 07 C0 AA 83 85 55 41 82 AA A1
	A8E0 81 55 01 40 2A 02 60 10 06 78 00 1E 9E 00 79 67
	A8F0 81 E6 79 E7 9E 9E 7E 79 87 99 E1 81 E7 81 C0 7E
	A900 03 E0 18 07 F8 00 1F FE 00 7F FF 81 FF FF E7 FF

         ........................
         ...........@@...........
         .........@@..@@.........
         .......@@...@..@@.......
         .....@@..@.@.@...@@.....
         ...@@...@.@.@.@.@..@@...
         ..@@.@.@.@.@.@.@.@..@@..
         ..@@..@.@.@.@.@.@.@.@@..
         ..@@@..@.@.@.@.@...@@@..
         .@.@@@@...@.@.@..@@@@.@.
         .@@..@@@@..@...@@@@..@@.
         .@@@@..@@@@..@@@@..@@@@.
         ...@@@@..@@@@@@..@@@@...
         .@@..@@@@..@@..@@@@..@@.
         .@@@@..@@@@..@@@@..@@@@.
         ...@@@@..@@@@@@..@@@@...
         ..@..@@@@..@@..@@@@..@..
         ..@@@..@@@@..@@@@..@@@..
         ...@@@@..@@@@@@..@@@@...
         .....@@@@..@@..@@@@.....
         .......@@@@..@@@@.......
         .........@@@@@@.........
         ...........@@...........
         ........................

         @@@@@@@@@@@..@@@@@@@@@@@
         @@@@@@@@@......@@@@@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@.......@......@@@@@
         @@@......@.@.@.......@@@
         @@......@.@.@.@.@.....@@
         @....@.@.@.@.@.@.@.....@
         @.....@.@.@.@.@.@.@....@
         @......@.@.@.@.@.......@
         .@........@.@.@.......@.
         .@@........@.........@@.
         .@@@@..............@@@@.
         @..@@@@..........@@@@..@
         .@@..@@@@......@@@@..@@.
         .@@@@..@@@@..@@@@..@@@@.
         @..@@@@..@@@@@@..@@@@..@
         @....@@@@..@@..@@@@....@
         @......@@@@..@@@@......@
         @@.......@@@@@@.......@@
         @@@........@@........@@@
         @@@@@..............@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@@@@@......@@@@@@@@@
         @@@@@@@@@@@..@@@@@@@@@@@

							; SPR_BALL:       EQU $4C
	A910 00 00 00 00 7E 00 01 FF 80 07 FF E0 0F FF F0 1D
	A920 FF F8 1B FF F8 33 FF FC 37 FF FC 77 FF FE 7F FF
	A930 FE 77 FF FE 7F FF FE 7F FF FE 7F FF FE 3F FF FC
	A940 3F FF FC 1F FF F8 1F FF F8 0F FF F0 07 FF E0 01
	A950 FF 80 00 7E 00 00 00 00 FF 81 FF FE 00 7F F8 00
	A960 1F F0 00 0F E0 00 07 C0 00 03 C0 00 03 80 00 01
	A970 80 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00
	A980 00 00 00 00 00 80 00 01 80 00 01 C0 00 03 C0 00
	A990 03 E0 00 07 F0 00 0F F8 00 1F FE 00 7F FF 81 FF

         ........................
         .........@@@@@@.........
         .......@@@@@@@@@@.......
         .....@@@@@@@@@@@@@@.....
         ....@@@@@@@@@@@@@@@@....
         ...@@@.@@@@@@@@@@@@@@...
         ...@@.@@@@@@@@@@@@@@@...
         ..@@..@@@@@@@@@@@@@@@@..
         ..@@.@@@@@@@@@@@@@@@@@..
         .@@@.@@@@@@@@@@@@@@@@@@.
         .@@@@@@@@@@@@@@@@@@@@@@.
         .@@@.@@@@@@@@@@@@@@@@@@.
         .@@@@@@@@@@@@@@@@@@@@@@.
         .@@@@@@@@@@@@@@@@@@@@@@.
         .@@@@@@@@@@@@@@@@@@@@@@.
         ..@@@@@@@@@@@@@@@@@@@@..
         ..@@@@@@@@@@@@@@@@@@@@..
         ...@@@@@@@@@@@@@@@@@@...
         ...@@@@@@@@@@@@@@@@@@...
         ....@@@@@@@@@@@@@@@@....
         .....@@@@@@@@@@@@@@.....
         .......@@@@@@@@@@.......
         .........@@@@@@.........
         ........................

         @@@@@@@@@......@@@@@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@..............@@@@@
         @@@@................@@@@
         @@@..................@@@
         @@....................@@
         @@....................@@
         @......................@
         @......................@
         ........................
         ........................
         ........................
         ........................
         ........................
         ........................
         @......................@
         @......................@
         @@....................@@
         @@....................@@
         @@@..................@@@
         @@@@................@@@@
         @@@@@..............@@@@@
         @@@@@@@..........@@@@@@@
         @@@@@@@@@......@@@@@@@@@

					; SPR_HEAD_FLYING:       EQU $4D
	A9A0 00 00 00 00 1F 00 00 7F C0 00 FF E0 01 FF 20 01
	A9B0 F9 F0 03 F7 F0 03 FF BC 03 FD A2 25 FD C1 1D FF
	A9C0 C1 0B FF 81 17 9F 41 37 3F 02 67 BF 02 1B 9B CE
	A9D0 0D 6C 3C 0A F6 60 10 B7 80 00 60 00 00 00 00 00
	A9E0 00 00 00 00 00 00 00 00
	A9E8 FF E0 FF FF 9F 3F FF 7F
	A9F0 DF FE FF EF FD FF 2F FD F9 F7 FB F7 F7 FB FF BF
	AA00 DB FD A3 81 FD C1 C1 FF C1 E3 FF 81 C7 9F 41 87
	AA10 3F 03 07 BF 02 83 9B CC E1 0C 31 E0 06 63 C4 07
	AA20 9F EF 08 7F FF 9F FF FF FF FF FF FF FF FF FF FF

         ........................
         ...........@@@@@........
         .........@@@@@@@@@......
         ........@@@@@@@@@@@.....
         .......@@@@@@@@@..@.....
         .......@@@@@@..@@@@@....
         ......@@@@@@.@@@@@@@....
         ......@@@@@@@@@@@.@@@@..
         ......@@@@@@@@.@@.@...@.
         ..@..@.@@@@@@@.@@@.....@
         ...@@@.@@@@@@@@@@@.....@
         ....@.@@@@@@@@@@@......@
         ...@.@@@@..@@@@@.@.....@
         ..@@.@@@..@@@@@@......@.
         .@@..@@@@.@@@@@@......@.
         ...@@.@@@..@@.@@@@..@@@.
         ....@@.@.@@.@@....@@@@..
         ....@.@.@@@@.@@..@@.....
         ...@....@.@@.@@@@.......
         .........@@.............
         ........................
         ........................
         ........................
         ........................

         @@@@@@@@@@@.....@@@@@@@@
         @@@@@@@@@..@@@@@..@@@@@@
         @@@@@@@@.@@@@@@@@@.@@@@@
         @@@@@@@.@@@@@@@@@@@.@@@@
         @@@@@@.@@@@@@@@@..@.@@@@
         @@@@@@.@@@@@@..@@@@@.@@@
         @@@@@.@@@@@@.@@@@@@@.@@@
         @@@@@.@@@@@@@@@@@.@@@@@@
         @@.@@.@@@@@@@@.@@.@...@@
         @......@@@@@@@.@@@.....@
         @@.....@@@@@@@@@@@.....@
         @@@...@@@@@@@@@@@......@
         @@...@@@@..@@@@@.@.....@
         @....@@@..@@@@@@......@@
         .....@@@@.@@@@@@......@.
         @.....@@@..@@.@@@@..@@..
         @@@....@....@@....@@...@
         @@@..........@@..@@...@@
         @@...@.......@@@@..@@@@@
         @@@.@@@@....@....@@@@@@@
         @@@@@@@@@..@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@

img_4x28.bin:			; SPR_DOORSTEP:       EQU $54
	AA30 00 00 00 00 00 03 C0 00 00 0E 70 00 00 38 1C 00
	AA40 00 E7 C7 00 03 9F F7 80 0E 7F FC 00 38 FF FB 80
	AA50 38 FF C1 00 4E 7F BB 80 73 9C 11 00 4C FB BB 80
	AA60 53 01 10 00 4C BB B8 00 32 91 00 00 0C BB 80 00
	AA70 03 90 00 00 00 B8 00 00 00 00 00 00 00 00 00 00
	AA80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	AA90 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

		 ................................
         ..............@@@@..............
         ............@@@..@@@............
         ..........@@@......@@@..........
         ........@@@..@@@@@...@@@........
         ......@@@..@@@@@@@@@.@@@@.......
         ....@@@..@@@@@@@@@@@@@..........
         ..@@@...@@@@@@@@@@@@@.@@@.......
         ..@@@...@@@@@@@@@@.....@........
         .@..@@@..@@@@@@@@.@@@.@@@.......
         .@@@..@@@..@@@.....@...@........
         .@..@@..@@@@@.@@@.@@@.@@@.......
         .@.@..@@.......@...@............
         .@..@@..@.@@@.@@@.@@@...........
         ..@@..@.@..@...@................
         ....@@..@.@@@.@@@...............
         ......@@@..@....................
         ........@.@@@...................
         ................................
         ................................
         ................................
         ................................
         ................................
         ................................
         ................................
         ................................
         ................................
         ................................

	AAA0 FF FC 3F FF FF F0 0F FF FF C0 03 FF FF 00 00 FF
	AAB0 FC 00 00 3F F0 00 00 3F C0 00 00 3F 80 00 03 BF
	AAC0 00 00 01 3F 00 00 3B BF 00 00 11 3F 00 03 BB BF
	AAD0 10 01 10 7F 0C 3B BB FF 02 11 07 FF C0 3B BF FF
	AAE0 F0 10 7F FF FC 3B FF FF FF 07 FF FF FF FF FF FF
	AAF0 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
	AB00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF

         @@@@@@@@@@@@@@....@@@@@@@@@@@@@@
         @@@@@@@@@@@@........@@@@@@@@@@@@
         @@@@@@@@@@............@@@@@@@@@@
         @@@@@@@@................@@@@@@@@
         @@@@@@....................@@@@@@
         @@@@......................@@@@@@
         @@........................@@@@@@
         @.....................@@@.@@@@@@
         .......................@..@@@@@@
         ..................@@@.@@@.@@@@@@
         ...................@...@..@@@@@@
         ..............@@@.@@@.@@@.@@@@@@
         ...@...........@...@.....@@@@@@@
         ....@@....@@@.@@@.@@@.@@@@@@@@@@
         ......@....@...@.....@@@@@@@@@@@
         @@........@@@.@@@.@@@@@@@@@@@@@@
         @@@@.......@.....@@@@@@@@@@@@@@@
         @@@@@@....@@@.@@@@@@@@@@@@@@@@@@
         @@@@@@@@.....@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

							; SPR_SANDWICH:   EQU $55
	AB10 00 00 00 00 00 07 80 00 00 1F C0 00 00 7F B8 00
	AB20 01 FD FF 00 07 FF FF C0 1F DF FF F0 3F FF FF FC
	AB30 4F 7F FF F2 73 FF FF CE 7C FF FF 3E 3B 3F FC FC
	AB40 0B CF F3 F0 31 F3 CF CC 0E FC 3F 30 11 3F FC C8
	AB50 2E 4F F3 34 47 92 CC E2 77 EC 33 EE 77 F3 CF EE
	AB60 37 81 81 EC 0B 4C 32 D0 02 F3 CF 40 00 FC 3F 00
	AB70 00 3F FC 00 00 0F F0 00 00 02 C0 00 00 00 00 00
	AB80 FF F8 7F FF FF E7 BF FF FF 9F C7 FF FE 7F B8 FF
	AB90 F9 FD FF 3F E7 FF FF CF DF DF FF F3 BF FF FF FD
	ABA0 0F 7F FF F0 03 FF FF C0 00 FF FF 00 80 3F FC 01
	ABB0 C0 0F F0 03 B0 03 C0 0D CE 00 00 33 D1 00 00 CB
	ABC0 A4 40 03 25 02 90 0C 40 05 4C 32 A0 02 A3 C5 40
	ABD0 85 01 80 A1 C2 0C 30 43 F0 03 C0 0F FC 00 00 3F
	ABE0 FF 00 00 FF FF C0 03 FF FF F0 0F FF FF FD 3F FF

         ................................
         .............@@@@...............
         ...........@@@@@@@..............
         .........@@@@@@@@.@@@...........
         .......@@@@@@@.@@@@@@@@@........
         .....@@@@@@@@@@@@@@@@@@@@@......
         ...@@@@@@@.@@@@@@@@@@@@@@@@@....
         ..@@@@@@@@@@@@@@@@@@@@@@@@@@@@..
         .@..@@@@.@@@@@@@@@@@@@@@@@@@..@.
         .@@@..@@@@@@@@@@@@@@@@@@@@..@@@.
         .@@@@@..@@@@@@@@@@@@@@@@..@@@@@.
         ..@@@.@@..@@@@@@@@@@@@..@@@@@@..
         ....@.@@@@..@@@@@@@@..@@@@@@....
         ..@@...@@@@@..@@@@..@@@@@@..@@..
         ....@@@.@@@@@@....@@@@@@..@@....
         ...@...@..@@@@@@@@@@@@..@@..@...
         ..@.@@@..@..@@@@@@@@..@@..@@.@..
         .@...@@@@..@..@.@@..@@..@@@...@.
         .@@@.@@@@@@.@@....@@..@@@@@.@@@.
         .@@@.@@@@@@@..@@@@..@@@@@@@.@@@.
         ..@@.@@@@......@@......@@@@.@@..
         ....@.@@.@..@@....@@..@.@@.@....
         ......@.@@@@..@@@@..@@@@.@......
         ........@@@@@@....@@@@@@........
         ..........@@@@@@@@@@@@..........
         ............@@@@@@@@............
         ..............@.@@..............
         ................................

         @@@@@@@@@@@@@....@@@@@@@@@@@@@@@
         @@@@@@@@@@@..@@@@.@@@@@@@@@@@@@@
         @@@@@@@@@..@@@@@@@...@@@@@@@@@@@
         @@@@@@@..@@@@@@@@.@@@...@@@@@@@@
         @@@@@..@@@@@@@.@@@@@@@@@..@@@@@@
         @@@..@@@@@@@@@@@@@@@@@@@@@..@@@@
         @@.@@@@@@@.@@@@@@@@@@@@@@@@@..@@
         @.@@@@@@@@@@@@@@@@@@@@@@@@@@@@.@
         ....@@@@.@@@@@@@@@@@@@@@@@@@....
         ......@@@@@@@@@@@@@@@@@@@@......
         ........@@@@@@@@@@@@@@@@........
         @.........@@@@@@@@@@@@.........@
         @@..........@@@@@@@@..........@@
         @.@@..........@@@@..........@@.@
         @@..@@@...................@@..@@
         @@.@...@................@@..@.@@
         @.@..@...@............@@..@..@.@
         ......@.@..@........@@...@......
         .....@.@.@..@@....@@..@.@.@.....
         ......@.@.@...@@@@...@.@.@......
         @....@.@.......@@.......@.@....@
         @@....@.....@@....@@.....@....@@
         @@@@..........@@@@..........@@@@
         @@@@@@....................@@@@@@
         @@@@@@@@................@@@@@@@@
         @@@@@@@@@@............@@@@@@@@@@
         @@@@@@@@@@@@........@@@@@@@@@@@@
         @@@@@@@@@@@@@@.@..@@@@@@@@@@@@@@

						; SPR_ROLLERS:    EQU $56
	ABF0 00 00 00 00 00 01 80 00 00 06 C0 00 00 19 E0 00
	AC00 00 67 CC 00 01 9F 36 00 06 7C CF 00 19 F3 3E 70
	AC10 3D CC F9 98 26 33 E6 7C 1A CF 99 FC 35 EE 67 FC
	AC20 35 31 9F FA 32 D6 7F E2 35 AF 7F 8A 31 A9 BE 3A
	AC30 35 96 B8 FA 31 AD A3 FA 35 8D 4F FA 31 AC BF F8
	AC40 19 8D BF F8 01 AC BF F0 01 8D BF C0 00 CC BF 00
	AC50 00 0D BC 00 00 0C B0 00 00 06 40 00 00 00 00 00
	AC60 FF FE 7F FF FF F9 BF FF FF E6 DF FF FF 99 E3 FF
	AC70 FE 67 CD FF F9 9F 36 FF E6 7C CF 0F D9 F3 3E 77
	AC80 BD CC F9 9B A6 33 E6 7D C2 CF 99 FD 85 EE 67 FD
	AC90 85 31 9F F8 80 16 7F E0 80 2F 7F 80 80 29 BE 00
	ACA0 80 00 B8 00 80 01 A0 00 80 01 40 00 80 00 00 01
	ACB0 C0 00 00 03 E4 00 00 07 FC 00 00 0F FE 00 00 3F
	ACC0 FF 20 00 FF FF E0 03 FF FF F0 0F FF FF F9 BF FF

         ................................
         ...............@@...............
         .............@@.@@..............
         ...........@@..@@@@.............
         .........@@..@@@@@..@@..........
         .......@@..@@@@@..@@.@@.........
         .....@@..@@@@@..@@..@@@@........
         ...@@..@@@@@..@@..@@@@@..@@@....
         ..@@@@.@@@..@@..@@@@@..@@..@@...
         ..@..@@...@@..@@@@@..@@..@@@@@..
         ...@@.@.@@..@@@@@..@@..@@@@@@@..
         ..@@.@.@@@@.@@@..@@..@@@@@@@@@..
         ..@@.@.@..@@...@@..@@@@@@@@@@.@.
         ..@@..@.@@.@.@@..@@@@@@@@@@...@.
         ..@@.@.@@.@.@@@@.@@@@@@@@...@.@.
         ..@@...@@.@.@..@@.@@@@@...@@@.@.
         ..@@.@.@@..@.@@.@.@@@...@@@@@.@.
         ..@@...@@.@.@@.@@.@...@@@@@@@.@.
         ..@@.@.@@...@@.@.@..@@@@@@@@@.@.
         ..@@...@@.@.@@..@.@@@@@@@@@@@...
         ...@@..@@...@@.@@.@@@@@@@@@@@...
         .......@@.@.@@..@.@@@@@@@@@@....
         .......@@...@@.@@.@@@@@@@@......
         ........@@..@@..@.@@@@@@........
         ............@@.@@.@@@@..........
         ............@@..@.@@............
         .............@@..@..............
         ................................

         @@@@@@@@@@@@@@@..@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@..@@.@@@@@@@@@@@@@@
         @@@@@@@@@@@..@@.@@.@@@@@@@@@@@@@
         @@@@@@@@@..@@..@@@@...@@@@@@@@@@
         @@@@@@@..@@..@@@@@..@@.@@@@@@@@@
         @@@@@..@@..@@@@@..@@.@@.@@@@@@@@
         @@@..@@..@@@@@..@@..@@@@....@@@@
         @@.@@..@@@@@..@@..@@@@@..@@@.@@@
         @.@@@@.@@@..@@..@@@@@..@@..@@.@@
         @.@..@@...@@..@@@@@..@@..@@@@@.@
         @@....@.@@..@@@@@..@@..@@@@@@@.@
         @....@.@@@@.@@@..@@..@@@@@@@@@.@
         @....@.@..@@...@@..@@@@@@@@@@...
         @..........@.@@..@@@@@@@@@@.....
         @.........@.@@@@.@@@@@@@@.......
         @.........@.@..@@.@@@@@.........
         @...............@.@@@...........
         @..............@@.@.............
         @..............@.@..............
         @..............................@
         @@............................@@
         @@@..@.......................@@@
         @@@@@@......................@@@@
         @@@@@@@...................@@@@@@
         @@@@@@@@..@.............@@@@@@@@
         @@@@@@@@@@@...........@@@@@@@@@@
         @@@@@@@@@@@@........@@@@@@@@@@@@
         @@@@@@@@@@@@@..@@.@@@@@@@@@@@@@@

							; SPR_TELEPORT:   EQU $57
	ACD0 00 00 00 00 00 00 00 00 00 03 C0 00 00 1C 38 00
	ACE0 00 62 46 00 01 9E 29 80 03 7E 54 C0 06 FC 2A 60
	ACF0 0C 01 80 30 15 54 3F A8 26 AA 7F 64 33 54 7E CC
	AD00 5D 8A 79 BA 5E 60 46 7A 6F 9C 39 F6 6F E3 C7 F6
	AD10 77 F8 1F EE 77 FD BF EE 78 01 80 1E 7A A9 95 5E
	AD20 39 55 AA 9C 0E A9 95 70 03 55 AA C0 00 E9 97 00
	AD30 00 35 AC 00 00 0D B0 00 00 03 C0 00 00 00 00 00
	AD40 FF FF FF FF FF FC 3F FF FF E0 07 FF FF 80 01 FF
	AD50 FE 00 40 7F FC 00 28 3F F8 00 54 1F F0 00 2A 0F
	AD60 E0 01 80 07 C1 54 00 03 A0 AA 00 05 B0 54 00 0D
	AD70 5C 0A 00 3A 5E 00 00 7A 6F 80 01 F6 6F E0 07 F6
	AD80 77 F8 1F EE 77 FC 3F EE 78 00 00 1E 7A A8 15 5E
	AD90 B9 54 2A 9D CE A8 15 73 F3 54 2A CF FC E8 17 3F
	ADA0 FF 34 2C FF FF CC 33 FF FF F0 0F FF FF FC 3F FF

         ................................
         ................................
         ..............@@@@..............
         ...........@@@....@@@...........
         .........@@...@..@...@@.........
         .......@@..@@@@...@.@..@@.......
         ......@@.@@@@@@..@.@.@..@@......
         .....@@.@@@@@@....@.@.@..@@.....
         ....@@.........@@.........@@....
         ...@.@.@.@.@.@....@@@@@@@.@.@...
         ..@..@@.@.@.@.@..@@@@@@@.@@..@..
         ..@@..@@.@.@.@...@@@@@@.@@..@@..
         .@.@@@.@@...@.@..@@@@..@@.@@@.@.
         .@.@@@@..@@......@...@@..@@@@.@.
         .@@.@@@@@..@@@....@@@..@@@@@.@@.
         .@@.@@@@@@@...@@@@...@@@@@@@.@@.
         .@@@.@@@@@@@@......@@@@@@@@.@@@.
         .@@@.@@@@@@@@@.@@.@@@@@@@@@.@@@.
         .@@@@..........@@..........@@@@.
         .@@@@.@.@.@.@..@@..@.@.@.@.@@@@.
         ..@@@..@.@.@.@.@@.@.@.@.@..@@@..
         ....@@@.@.@.@..@@..@.@.@.@@@....
         ......@@.@.@.@.@@.@.@.@.@@......
         ........@@@.@..@@..@.@@@........
         ..........@@.@.@@.@.@@..........
         ............@@.@@.@@............
         ..............@@@@..............
         ................................

         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@@@....@@@@@@@@@@@@@@
         @@@@@@@@@@@..........@@@@@@@@@@@
         @@@@@@@@@..............@@@@@@@@@
         @@@@@@@..........@.......@@@@@@@
         @@@@@@............@.@.....@@@@@@
         @@@@@............@.@.@.....@@@@@
         @@@@..............@.@.@.....@@@@
         @@@............@@............@@@
         @@.....@.@.@.@................@@
         @.@.....@.@.@.@..............@.@
         @.@@.....@.@.@..............@@.@
         .@.@@@......@.@...........@@@.@.
         .@.@@@@..................@@@@.@.
         .@@.@@@@@..............@@@@@.@@.
         .@@.@@@@@@@..........@@@@@@@.@@.
         .@@@.@@@@@@@@......@@@@@@@@.@@@.
         .@@@.@@@@@@@@@....@@@@@@@@@.@@@.
         .@@@@......................@@@@.
         .@@@@.@.@.@.@......@.@.@.@.@@@@.
         @.@@@..@.@.@.@....@.@.@.@..@@@.@
         @@..@@@.@.@.@......@.@.@.@@@..@@
         @@@@..@@.@.@.@....@.@.@.@@..@@@@
         @@@@@@..@@@.@......@.@@@..@@@@@@
         @@@@@@@@..@@.@....@.@@..@@@@@@@@
         @@@@@@@@@@..@@....@@..@@@@@@@@@@
         @@@@@@@@@@@@........@@@@@@@@@@@@
         @@@@@@@@@@@@@@....@@@@@@@@@@@@@@

							; SPR_LAVAPIT:   EQU $58
	ADB0 00 00 00 00 00 03 C0 00 00 1C 38 00 00 61 C6 00
	ADC0 01 8A B9 80 03 2A AE C0 06 55 56 60 0B 2A AE D0
	ADD0 12 8A B9 D8 36 E1 47 6C 2C DC 3D 74 1D 97 E5 B8
	ADE0 5B 76 B6 DA 67 64 B3 66 32 ED 9B 8C 5C D9 DD 3A
	ADF0 27 1B 68 E4 69 E3 C7 96 5C 3C 3C 32 5B 47 E2 DA
	AE00 33 68 16 CC 0E 6D 76 70 02 CD BB 40 00 D9 BB 00
	AE10 00 33 9C 00 00 0E D0 00 00 02 C0 00 00 00 00 00
	AE20 FF FC 3F FF FF E3 C7 FF FF 9C 39 FF FE 60 06 7F
	AE30 FD 80 01 BF FB 00 00 DF F6 00 00 6F EB 00 00 D7
	AE40 D2 80 01 DB B6 E0 07 6D AC DC 3D 75 9D 97 E5 B9
	AE50 1B 76 B6 D8 07 64 B3 60 82 ED 9B 81 40 D9 DD 02
	AE60 A0 1B 68 05 68 03 C0 16 5C 00 00 32 5B 40 02 DA
	AE70 B3 68 16 CD CE 6D 76 73 F2 CD BB 4F FC D9 BB 3F
	AE80 FF 33 9C FF FF CE D3 FF FF F2 CF FF FF FD 3F FF

         ................................
         ..............@@@@..............
         ...........@@@....@@@...........
         .........@@....@@@...@@.........
         .......@@...@.@.@.@@@..@@.......
         ......@@..@.@.@.@.@.@@@.@@......
         .....@@..@.@.@.@.@.@.@@..@@.....
         ....@.@@..@.@.@.@.@.@@@.@@.@....
         ...@..@.@...@.@.@.@@@..@@@.@@...
         ..@@.@@.@@@....@.@...@@@.@@.@@..
         ..@.@@..@@.@@@....@@@@.@.@@@.@..
         ...@@@.@@..@.@@@@@@..@.@@.@@@...
         .@.@@.@@.@@@.@@.@.@@.@@.@@.@@.@.
         .@@..@@@.@@..@..@.@@..@@.@@..@@.
         ..@@..@.@@@.@@.@@..@@.@@@...@@..
         .@.@@@..@@.@@..@@@.@@@.@..@@@.@.
         ..@..@@@...@@.@@.@@.@...@@@..@..
         .@@.@..@@@@...@@@@...@@@@..@.@@.
         .@.@@@....@@@@....@@@@....@@..@.
         .@.@@.@@.@...@@@@@@...@.@@.@@.@.
         ..@@..@@.@@.@......@.@@.@@..@@..
         ....@@@..@@.@@.@.@@@.@@..@@@....
         ......@.@@..@@.@@.@@@.@@.@......
         ........@@.@@..@@.@@@.@@........
         ..........@@..@@@..@@@..........
         ............@@@.@@.@............
         ..............@.@@..............
         ................................

         @@@@@@@@@@@@@@....@@@@@@@@@@@@@@
         @@@@@@@@@@@...@@@@...@@@@@@@@@@@
         @@@@@@@@@..@@@....@@@..@@@@@@@@@
         @@@@@@@..@@..........@@..@@@@@@@
         @@@@@@.@@..............@@.@@@@@@
         @@@@@.@@................@@.@@@@@
         @@@@.@@..................@@.@@@@
         @@@.@.@@................@@.@.@@@
         @@.@..@.@..............@@@.@@.@@
         @.@@.@@.@@@..........@@@.@@.@@.@
         @.@.@@..@@.@@@....@@@@.@.@@@.@.@
         @..@@@.@@..@.@@@@@@..@.@@.@@@..@
         ...@@.@@.@@@.@@.@.@@.@@.@@.@@...
         .....@@@.@@..@..@.@@..@@.@@.....
         @.....@.@@@.@@.@@..@@.@@@......@
         .@......@@.@@..@@@.@@@.@......@.
         @.@........@@.@@.@@.@........@.@
         .@@.@.........@@@@.........@.@@.
         .@.@@@....................@@..@.
         .@.@@.@@.@............@.@@.@@.@.
         @.@@..@@.@@.@......@.@@.@@..@@.@
         @@..@@@..@@.@@.@.@@@.@@..@@@..@@
         @@@@..@.@@..@@.@@.@@@.@@.@..@@@@
         @@@@@@..@@.@@..@@.@@@.@@..@@@@@@
         @@@@@@@@..@@..@@@..@@@..@@@@@@@@
         @@@@@@@@@@..@@@.@@.@..@@@@@@@@@@
         @@@@@@@@@@@@..@.@@..@@@@@@@@@@@@
         @@@@@@@@@@@@@@.@..@@@@@@@@@@@@@@

							; SPR_PAD:        EQU $59
	AE90 00 00 00 00 00 03 C0 00 00 0E 70 00 00 39 9C 00
	AEA0 00 E6 67 00 03 99 99 C0 0E 67 E6 70 39 8C 31 9C
	AEB0 39 60 06 9C 0E 58 1A 70 33 96 69 CC 1C E5 A7 38
	AEC0 23 39 9C C4 41 CE 73 82 7A 33 CC 5E 34 1C 38 2C
	AED0 47 A3 C5 E2 7B 41 82 DE 34 7A 5E 2C 47 B4 2D E2
	AEE0 33 47 E2 CC 0C 7B DE 30 03 34 2C C0 00 C7 E3 00
	AEF0 00 33 CC 00 00 0C 30 00 00 03 C0 00 00 00 00 00
	AF00 FF FC 3F FF FF F3 CF FF FF CE 73 FF FF 38 1C FF
	AF10 FC E0 07 3F F3 80 01 CF CE 00 00 73 B8 00 00 1D
	AF20 B8 00 00 1D CE 00 00 73 83 80 01 C1 C0 E0 07 03
	AF30 80 38 1C 01 00 0E 70 00 00 03 C0 00 80 00 00 01
	AF40 40 00 00 02 78 00 00 1E B4 00 00 2D 07 80 01 E0
	AF50 83 40 02 C1 C0 78 1E 03 F0 34 2C 0F FC 07 E0 3F
	AF60 FF 03 C0 FF FF C0 03 FF FF F0 0F FF FF FC 3F FF

         ................................
         ..............@@@@..............
         ............@@@..@@@............
         ..........@@@..@@..@@@..........
         ........@@@..@@..@@..@@@........
         ......@@@..@@..@@..@@..@@@......
         ....@@@..@@..@@@@@@..@@..@@@....
         ..@@@..@@...@@....@@...@@..@@@..
         ..@@@..@.@@..........@@.@..@@@..
         ....@@@..@.@@......@@.@..@@@....
         ..@@..@@@..@.@@..@@.@..@@@..@@..
         ...@@@..@@@..@.@@.@..@@@..@@@...
         ..@...@@..@@@..@@..@@@..@@...@..
         .@.....@@@..@@@..@@@..@@@.....@.
         .@@@@.@...@@..@@@@..@@...@.@@@@.
         ..@@.@.....@@@....@@@.....@.@@..
         .@...@@@@.@...@@@@...@.@@@@...@.
         .@@@@.@@.@.....@@.....@.@@.@@@@.
         ..@@.@...@@@@.@..@.@@@@...@.@@..
         .@...@@@@.@@.@....@.@@.@@@@...@.
         ..@@..@@.@...@@@@@@...@.@@..@@..
         ....@@...@@@@.@@@@.@@@@...@@....
         ......@@..@@.@....@.@@..@@......
         ........@@...@@@@@@...@@........
         ..........@@..@@@@..@@..........
         ............@@....@@............
         ..............@@@@..............
         ................................

         @@@@@@@@@@@@@@....@@@@@@@@@@@@@@
         @@@@@@@@@@@@..@@@@..@@@@@@@@@@@@
         @@@@@@@@@@..@@@..@@@..@@@@@@@@@@
         @@@@@@@@..@@@......@@@..@@@@@@@@
         @@@@@@..@@@..........@@@..@@@@@@
         @@@@..@@@..............@@@..@@@@
         @@..@@@..................@@@..@@
         @.@@@......................@@@.@
         @.@@@......................@@@.@
         @@..@@@..................@@@..@@
         @.....@@@..............@@@.....@
         @@......@@@..........@@@......@@
         @.........@@@......@@@.........@
         ............@@@..@@@............
         ..............@@@@..............
         @..............................@
         .@............................@.
         .@@@@......................@@@@.
         @.@@.@....................@.@@.@
         .....@@@@..............@@@@.....
         @.....@@.@............@.@@.....@
         @@.......@@@@......@@@@.......@@
         @@@@......@@.@....@.@@......@@@@
         @@@@@@.......@@@@@@.......@@@@@@
         @@@@@@@@......@@@@......@@@@@@@@
         @@@@@@@@@@............@@@@@@@@@@
         @@@@@@@@@@@@........@@@@@@@@@@@@
         @@@@@@@@@@@@@@....@@@@@@@@@@@@@@

							; SPR_ANVIL:      EQU $5A
	AF70 00 00 00 00 00 03 C0 00 00 0C 30 00 00 33 CC 00
	AF80 00 CC 33 00 03 33 CC C0 0C CC 33 30 33 33 CC CC
	AF90 33 33 CC CC 1C CC 33 38 07 33 CC E0 03 CC 33 80
	AFA0 03 F3 CE 40 0B FC 39 B0 37 F7 E7 CC 5F F0 01 9A
	AFB0 67 F0 00 66 59 F8 01 9A 56 78 06 6A 55 9E 19 AA
	AFC0 35 67 E6 AC 0D 59 9A B0 03 56 6A C0 00 D5 AB 00
	AFD0 00 35 AC 00 00 0D B0 00 00 03 C0 00 00 00 00 00
	AFE0 FF FC 3F FF FF F3 CF FF FF CC 33 FF FF 30 0C FF
	AFF0 FC C0 03 3F F3 03 C0 CF CC 0C 30 33 B0 30 0C 0D
	B000 B0 30 0C 0D DC 0C 30 3B E7 03 C0 E7 FB C0 03 9F
	B010 F3 F0 0E 4F CB FC 39 B3 B7 F7 E7 CD 1F F0 19 98
	B020 07 F7 FE 60 01 FB F9 80 00 79 E6 00 00 1E 18 00
	B030 80 07 E0 01 C0 01 80 03 F0 00 00 0F FC 00 00 3F
	B040 FF 00 00 FF FF C0 03 FF FF F0 0F FF FF FC 3F FF

         ................................
         ..............@@@@..............
         ............@@....@@............
         ..........@@..@@@@..@@..........
         ........@@..@@....@@..@@........
         ......@@..@@..@@@@..@@..@@......
         ....@@..@@..@@....@@..@@..@@....
         ..@@..@@..@@..@@@@..@@..@@..@@..
         ..@@..@@..@@..@@@@..@@..@@..@@..
         ...@@@..@@..@@....@@..@@..@@@...
         .....@@@..@@..@@@@..@@..@@@.....
         ......@@@@..@@....@@..@@@.......
         ......@@@@@@..@@@@..@@@..@......
         ....@.@@@@@@@@....@@@..@@.@@....
         ..@@.@@@@@@@.@@@@@@..@@@@@..@@..
         .@.@@@@@@@@@...........@@..@@.@.
         .@@..@@@@@@@.............@@..@@.
         .@.@@..@@@@@@..........@@..@@.@.
         .@.@.@@..@@@@........@@..@@.@.@.
         .@.@.@.@@..@@@@....@@..@@.@.@.@.
         ..@@.@.@.@@..@@@@@@..@@.@.@.@@..
         ....@@.@.@.@@..@@..@@.@.@.@@....
         ......@@.@.@.@@..@@.@.@.@@......
         ........@@.@.@.@@.@.@.@@........
         ..........@@.@.@@.@.@@..........
         ............@@.@@.@@............
         ..............@@@@..............
         ................................

         @@@@@@@@@@@@@@....@@@@@@@@@@@@@@
         @@@@@@@@@@@@..@@@@..@@@@@@@@@@@@
         @@@@@@@@@@..@@....@@..@@@@@@@@@@
         @@@@@@@@..@@........@@..@@@@@@@@
         @@@@@@..@@............@@..@@@@@@
         @@@@..@@......@@@@......@@..@@@@
         @@..@@......@@....@@......@@..@@
         @.@@......@@........@@......@@.@
         @.@@......@@........@@......@@.@
         @@.@@@......@@....@@......@@@.@@
         @@@..@@@......@@@@......@@@..@@@
         @@@@@.@@@@............@@@..@@@@@
         @@@@..@@@@@@........@@@..@..@@@@
         @@..@.@@@@@@@@....@@@..@@.@@..@@
         @.@@.@@@@@@@.@@@@@@..@@@@@..@@.@
         ...@@@@@@@@@.......@@..@@..@@...
         .....@@@@@@@.@@@@@@@@@@..@@.....
         .......@@@@@@.@@@@@@@..@@.......
         .........@@@@..@@@@..@@.........
         ...........@@@@....@@...........
         @............@@@@@@............@
         @@.............@@.............@@
         @@@@........................@@@@
         @@@@@@....................@@@@@@
         @@@@@@@@................@@@@@@@@
         @@@@@@@@@@............@@@@@@@@@@
         @@@@@@@@@@@@........@@@@@@@@@@@@
         @@@@@@@@@@@@@@....@@@@@@@@@@@@@@

							; SPR_SPIKES:     EQU $5B
	B050 00 00 00 00 00 00 00 00 00 08 10 00 00 08 10 00
	B060 00 8C 31 00 00 9C 39 00 08 DD BB 10 09 DE 7B 90
	B070 09 DE 7B 90 15 EE 77 A8 15 AE 75 A8 0D 4E 72 B0
	B080 2E 48 12 74 6E C4 23 76 32 E4 27 4C 0C EC 37 30
	B090 13 2E 74 C8 1C CE 73 38 5D 32 4C BA 6D CC 33 B6
	B0A0 31 D3 CB 8C 0E DC 3B 70 03 1E 78 C0 00 EC 37 00
	B0B0 00 32 4C 00 00 0F F0 00 00 03 C0 00 00 00 00 00
	B0C0 FF FF FF FF FF F7 EF FF FF EB D7 FF FF 6B D6 FF
	B0D0 FE AD B5 7F F6 9C 39 6F EA DC 3B 57 E9 DE 7B 97
	B0E0 E9 DE 7B 97 D5 EE 77 AB D5 AE 75 AB CD 4E 72 B3
	B0F0 8E 48 12 71 0E C4 23 70 82 E4 27 41 C0 EC 37 03
	B100 D0 2E 74 0B 9C 0E 70 39 1D 02 40 B8 0D C0 03 B0
	B110 81 D0 0B 81 C0 DC 3B 03 F0 1E 78 0F FC 0C 30 3F
	B120 FF 00 00 FF FF C0 03 FF FF F0 0F FF FF FC 3F FF

         ................................
         ................................
         ............@......@............
         ............@......@............
         ........@...@@....@@...@........
         ........@..@@@....@@@..@........
         ....@...@@.@@@.@@.@@@.@@...@....
         ....@..@@@.@@@@..@@@@.@@@..@....
         ....@..@@@.@@@@..@@@@.@@@..@....
         ...@.@.@@@@.@@@..@@@.@@@@.@.@...
         ...@.@.@@.@.@@@..@@@.@.@@.@.@...
         ....@@.@.@..@@@..@@@..@.@.@@....
         ..@.@@@..@..@......@..@..@@@.@..
         .@@.@@@.@@...@....@...@@.@@@.@@.
         ..@@..@.@@@..@....@..@@@.@..@@..
         ....@@..@@@.@@....@@.@@@..@@....
         ...@..@@..@.@@@..@@@.@..@@..@...
         ...@@@..@@..@@@..@@@..@@..@@@...
         .@.@@@.@..@@..@..@..@@..@.@@@.@.
         .@@.@@.@@@..@@....@@..@@@.@@.@@.
         ..@@...@@@.@..@@@@..@.@@@...@@..
         ....@@@.@@.@@@....@@@.@@.@@@....
         ......@@...@@@@..@@@@...@@......
         ........@@@.@@....@@.@@@........
         ..........@@..@..@..@@..........
         ............@@@@@@@@............
         ..............@@@@..............
         ................................

         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         @@@@@@@@@@@@.@@@@@@.@@@@@@@@@@@@
         @@@@@@@@@@@.@.@@@@.@.@@@@@@@@@@@
         @@@@@@@@.@@.@.@@@@.@.@@.@@@@@@@@
         @@@@@@@.@.@.@@.@@.@@.@.@.@@@@@@@
         @@@@.@@.@..@@@....@@@..@.@@.@@@@
         @@@.@.@.@@.@@@....@@@.@@.@.@.@@@
         @@@.@..@@@.@@@@..@@@@.@@@..@.@@@
         @@@.@..@@@.@@@@..@@@@.@@@..@.@@@
         @@.@.@.@@@@.@@@..@@@.@@@@.@.@.@@
         @@.@.@.@@.@.@@@..@@@.@.@@.@.@.@@
         @@..@@.@.@..@@@..@@@..@.@.@@..@@
         @...@@@..@..@......@..@..@@@...@
         ....@@@.@@...@....@...@@.@@@....
         @.....@.@@@..@....@..@@@.@.....@
         @@......@@@.@@....@@.@@@......@@
         @@.@......@.@@@..@@@.@......@.@@
         @..@@@......@@@..@@@......@@@..@
         ...@@@.@......@..@......@.@@@...
         ....@@.@@@............@@@.@@....
         @......@@@.@........@.@@@......@
         @@......@@.@@@....@@@.@@......@@
         @@@@.......@@@@..@@@@.......@@@@
         @@@@@@......@@....@@......@@@@@@
         @@@@@@@@................@@@@@@@@
         @@@@@@@@@@............@@@@@@@@@@
         @@@@@@@@@@@@........@@@@@@@@@@@@
         @@@@@@@@@@@@@@....@@@@@@@@@@@@@@

							; SPR_HUSHPUPPY:  EQU $5C
	B130 00 00 00 00 00 01 C0 00 00 07 F0 00 00 0F F8 00
	B140 00 1F F7 00 00 7C 3F C0 01 F0 0F E0 1C 20 07 F4
	B150 3F C0 07 F6 63 F8 0F 78 6F FE 3E F8 1E 7F 7E F8
	B160 1B 7F 1E FC 35 E7 EF 7C 31 F7 F7 3E 3B DE 7A 4E
	B170 3F AF 79 F6 51 8F B3 FE 52 DF 8B FE 58 FF BD FC
	B180 2B F6 5D F8 03 F1 FD 70 00 E7 FD 40 00 0F F8 00
	B190 00 0B F0 00 00 0A E0 00 00 02 80 00 00 00 00 00
	B1A0 FF FE 3F FF FF F8 0F FF FF F0 07 FF FF E0 00 FF
	B1B0 FF 80 00 3F FE 00 00 0F E0 00 00 03 C0 00 00 05
	B1C0 80 00 00 06 00 00 00 01 00 00 00 03 80 00 00 03
	B1D0 C0 00 00 01 84 00 00 01 80 00 00 00 80 00 00 40
	B1E0 80 20 01 F0 40 00 03 F8 42 00 03 FC 40 00 01 FD
	B1F0 A0 00 41 FB D0 01 F1 77 FC 07 F1 4F FF 0F FA BF
	B200 FF EB F7 FF FF EA EF FF FF F2 9F FF FF FD 7F FF

         ................................
         ...............@@@..............
         .............@@@@@@@............
         ............@@@@@@@@@...........
         ...........@@@@@@@@@.@@@........
         .........@@@@@....@@@@@@@@......
         .......@@@@@........@@@@@@@.....
         ...@@@....@..........@@@@@@@.@..
         ..@@@@@@@@...........@@@@@@@.@@.
         .@@...@@@@@@@.......@@@@.@@@@...
         .@@.@@@@@@@@@@@...@@@@@.@@@@@...
         ...@@@@..@@@@@@@.@@@@@@.@@@@@...
         ...@@.@@.@@@@@@@...@@@@.@@@@@@..
         ..@@.@.@@@@..@@@@@@.@@@@.@@@@@..
         ..@@...@@@@@.@@@@@@@.@@@..@@@@@.
         ..@@@.@@@@.@@@@..@@@@.@..@..@@@.
         ..@@@@@@@.@.@@@@.@@@@..@@@@@.@@.
         .@.@...@@...@@@@@.@@..@@@@@@@@@.
         .@.@..@.@@.@@@@@@...@.@@@@@@@@@.
         .@.@@...@@@@@@@@@.@@@@.@@@@@@@..
         ..@.@.@@@@@@.@@..@.@@@.@@@@@@...
         ......@@@@@@...@@@@@@@.@.@@@....
         ........@@@..@@@@@@@@@.@.@......
         ............@@@@@@@@@...........
         ............@.@@@@@@............
         ............@.@.@@@.............
         ..............@.@...............
         ................................

         @@@@@@@@@@@@@@@...@@@@@@@@@@@@@@
         @@@@@@@@@@@@@.......@@@@@@@@@@@@
         @@@@@@@@@@@@.........@@@@@@@@@@@
         @@@@@@@@@@@.............@@@@@@@@
         @@@@@@@@@.................@@@@@@
         @@@@@@@.....................@@@@
         @@@...........................@@
         @@...........................@.@
         @............................@@.
         ...............................@
         ..............................@@
         @.............................@@
         @@.............................@
         @....@.........................@
         @...............................
         @........................@......
         @.........@............@@@@@....
         .@....................@@@@@@@...
         .@....@...............@@@@@@@@..
         .@.....................@@@@@@@.@
         @.@..............@.....@@@@@@.@@
         @@.@...........@@@@@...@.@@@.@@@
         @@@@@@.......@@@@@@@...@.@..@@@@
         @@@@@@@@....@@@@@@@@@.@.@.@@@@@@
         @@@@@@@@@@@.@.@@@@@@.@@@@@@@@@@@
         @@@@@@@@@@@.@.@.@@@.@@@@@@@@@@@@
         @@@@@@@@@@@@..@.@..@@@@@@@@@@@@@
         @@@@@@@@@@@@@@.@.@@@@@@@@@@@@@@@

							; SPR_BOOK:       EQU $5D
	B210 00 00 00 00 00 03 C0 00 00 0E 70 00 00 39 9C 00
	B220 00 E6 67 00 03 99 99 C0 0E 67 E6 70 1D 9F F9 BC
	B230 1E 67 E6 7E 27 99 99 F8 39 E6 67 E0 76 79 9F 86
	B240 75 9E 7E 18 6D E7 F8 66 6B D9 E1 98 6B D6 86 66
	B250 6B B7 19 98 6B AE 66 66 2B AC 99 98 2B AC 66 66
	B260 0B AD 99 9C 05 AC 66 70 01 AD 99 C0 00 AC 67 00
	B270 00 16 9C 00 00 07 70 00 00 01 C0 00 00 00 00 00
	B280 FF FC 3F FF FF F0 0F FF FF C0 03 FF FF 01 80 FF
	B290 FC 06 60 3F F0 18 18 0F E0 60 06 03 C1 80 01 81
	B2A0 C0 60 06 00 80 18 18 01 80 06 60 01 06 01 80 06
	B2B0 04 00 00 19 0C 00 00 66 08 18 01 99 08 10 06 66
	B2C0 08 30 19 99 08 20 66 66 88 20 99 99 88 20 66 60
	B2D0 C8 21 99 81 F4 20 66 03 F8 21 98 0F FE 20 60 3F
	B2E0 FF 10 80 FF FF E0 03 FF FF F8 0F FF FF FE 3F FF

         ................................
         ..............@@@@..............
         ............@@@..@@@............
         ..........@@@..@@..@@@..........
         ........@@@..@@..@@..@@@........
         ......@@@..@@..@@..@@..@@@......
         ....@@@..@@..@@@@@@..@@..@@@....
         ...@@@.@@..@@@@@@@@@@..@@.@@@@..
         ...@@@@..@@..@@@@@@..@@..@@@@@@.
         ..@..@@@@..@@..@@..@@..@@@@@@...
         ..@@@..@@@@..@@..@@..@@@@@@.....
         .@@@.@@..@@@@..@@..@@@@@@....@@.
         .@@@.@.@@..@@@@..@@@@@@....@@...
         .@@.@@.@@@@..@@@@@@@@....@@..@@.
         .@@.@.@@@@.@@..@@@@....@@..@@...
         .@@.@.@@@@.@.@@.@....@@..@@..@@.
         .@@.@.@@@.@@.@@@...@@..@@..@@...
         .@@.@.@@@.@.@@@..@@..@@..@@..@@.
         ..@.@.@@@.@.@@..@..@@..@@..@@...
         ..@.@.@@@.@.@@...@@..@@..@@..@@.
         ....@.@@@.@.@@.@@..@@..@@..@@@..
         .....@.@@.@.@@...@@..@@..@@@....
         .......@@.@.@@.@@..@@..@@@......
         ........@.@.@@...@@..@@@........
         ...........@.@@.@..@@@..........
         .............@@@.@@@............
         ...............@@@..............
         ................................

         @@@@@@@@@@@@@@....@@@@@@@@@@@@@@
         @@@@@@@@@@@@........@@@@@@@@@@@@
         @@@@@@@@@@............@@@@@@@@@@
         @@@@@@@@.......@@.......@@@@@@@@
         @@@@@@.......@@..@@.......@@@@@@
         @@@@.......@@......@@.......@@@@
         @@@......@@..........@@.......@@
         @@.....@@..............@@......@
         @@.......@@..........@@.........
         @..........@@......@@..........@
         @............@@..@@............@
         .....@@........@@............@@.
         .....@.....................@@..@
         ....@@...................@@..@@.
         ....@......@@..........@@..@@..@
         ....@......@.........@@..@@..@@.
         ....@.....@@.......@@..@@..@@..@
         ....@.....@......@@..@@..@@..@@.
         @...@.....@.....@..@@..@@..@@..@
         @...@.....@......@@..@@..@@.....
         @@..@.....@....@@..@@..@@......@
         @@@@.@....@......@@..@@.......@@
         @@@@@.....@....@@..@@.......@@@@
         @@@@@@@...@......@@.......@@@@@@
         @@@@@@@@...@....@.......@@@@@@@@
         @@@@@@@@@@@...........@@@@@@@@@@
         @@@@@@@@@@@@@.......@@@@@@@@@@@@
         @@@@@@@@@@@@@@@...@@@@@@@@@@@@@@

							; SPR_TOASTER:    EQU $5E
	B2F0 00 00 00 00 00 03 80 00 00 0F E0 00 00 3C 78 00
	B300 00 F9 9E 00 03 FC 67 80 0F 1F 19 E0 1E 67 C6 78
	B310 3F 19 F1 BC 1F C6 7C 7C 67 F1 9F FE 79 FC 6F CE
	B320 7E 7F 1F B6 7F 9F FF 96 5F E7 F3 B6 77 F9 6D 96
	B330 5D FE 65 96 57 7F 6D 86 65 DF 65 9A 39 77 65 B2
	B340 1E 5D 61 CC 07 97 66 F0 01 E5 6C C0 00 79 73 00
	B350 00 1E BC 00 00 07 B0 00 00 01 C0 00 00 00 00 00
	B360 FF FC 7F FF FF F0 1F FF FF C0 07 FF FF 00 01 FF
	B370 FC 01 80 7F F0 00 60 1F E0 00 18 07 C0 60 06 03
	B380 80 18 01 81 80 06 00 01 60 01 80 00 78 00 60 00
	B390 7E 00 00 00 7F 80 00 00 5F E0 00 00 77 F8 00 00
	B3A0 5D FE 00 00 57 7F 00 00 65 DF 00 18 B9 77 00 30
	B3B0 DE 5D 00 01 E7 97 06 03 F9 E5 0C 0F FE 79 00 3F
	B3C0 FF 9E 80 FF FF E7 83 FF FF F9 CF FF FF FE 3F FF

         ................................
         ..............@@@...............
         ............@@@@@@@.............
         ..........@@@@...@@@@...........
         ........@@@@@..@@..@@@@.........
         ......@@@@@@@@...@@..@@@@.......
         ....@@@@...@@@@@...@@..@@@@.....
         ...@@@@..@@..@@@@@...@@..@@@@...
         ..@@@@@@...@@..@@@@@...@@.@@@@..
         ...@@@@@@@...@@..@@@@@...@@@@@..
         .@@..@@@@@@@...@@..@@@@@@@@@@@@.
         .@@@@..@@@@@@@...@@.@@@@@@..@@@.
         .@@@@@@..@@@@@@@...@@@@@@.@@.@@.
         .@@@@@@@@..@@@@@@@@@@@@@@..@.@@.
         .@.@@@@@@@@..@@@@@@@..@@@.@@.@@.
         .@@@.@@@@@@@@..@.@@.@@.@@..@.@@.
         .@.@@@.@@@@@@@@..@@..@.@@..@.@@.
         .@.@.@@@.@@@@@@@.@@.@@.@@....@@.
         .@@..@.@@@.@@@@@.@@..@.@@..@@.@.
         ..@@@..@.@@@.@@@.@@..@.@@.@@..@.
         ...@@@@..@.@@@.@.@@....@@@..@@..
         .....@@@@..@.@@@.@@..@@.@@@@....
         .......@@@@..@.@.@@.@@..@@......
         .........@@@@..@.@@@..@@........
         ...........@@@@.@.@@@@..........
         .............@@@@.@@............
         ...............@@@..............
         ................................

         @@@@@@@@@@@@@@...@@@@@@@@@@@@@@@
         @@@@@@@@@@@@.......@@@@@@@@@@@@@
         @@@@@@@@@@...........@@@@@@@@@@@
         @@@@@@@@...............@@@@@@@@@
         @@@@@@.........@@........@@@@@@@
         @@@@.............@@........@@@@@
         @@@................@@........@@@
         @@.......@@..........@@.......@@
         @..........@@..........@@......@
         @............@@................@
         .@@............@@...............
         .@@@@............@@.............
         .@@@@@@.........................
         .@@@@@@@@.......................
         .@.@@@@@@@@.....................
         .@@@.@@@@@@@@...................
         .@.@@@.@@@@@@@@.................
         .@.@.@@@.@@@@@@@................
         .@@..@.@@@.@@@@@...........@@...
         @.@@@..@.@@@.@@@..........@@....
         @@.@@@@..@.@@@.@...............@
         @@@..@@@@..@.@@@.....@@.......@@
         @@@@@..@@@@..@.@....@@......@@@@
         @@@@@@@..@@@@..@..........@@@@@@
         @@@@@@@@@..@@@@.@.......@@@@@@@@
         @@@@@@@@@@@..@@@@.....@@@@@@@@@@
         @@@@@@@@@@@@@..@@@..@@@@@@@@@@@@
         @@@@@@@@@@@@@@@...@@@@@@@@@@@@@@

							; SPR_CUSHION:    EQU $5F
	B3D0 00 00 00 00 00 02 C0 00 00 0D 30 00 00 33 CC 00
	B3E0 00 CF F3 00 03 3F FC C0 0C FF FF 30 33 FF FF CC
	B3F0 4F FF FF F2 33 FF FF CC 6C FF FF 36 2B 3F FC D4
	B400 4B 4F F3 52 72 B3 CF CE 1C F4 2D 38 67 2D 74 E2
	B410 31 CB 53 94 6A 72 CE 56 4D 9C 39 5A 5B 47 E6 AA
	B420 33 68 12 CC 0E 6A B6 70 02 DD B3 40 00 D5 9B 00
	B430 00 39 CC 00 00 0B 70 00 00 03 40 00 00 00 00 00
	B440 FF FD 3F FF FF F0 0F FF FF C0 03 FF FF 01 40 FF
	B450 FC 0A A0 3F F0 15 54 0F C0 AA AA 03 81 55 55 41
	B460 0A AA AA A0 81 55 55 41 00 AA AA 00 80 15 54 01
	B470 40 0A A0 02 70 01 40 0E 9C 00 00 39 07 00 00 E0
	B480 81 C0 03 81 00 70 0E 00 00 1C 38 00 00 07 E0 00
	B490 80 00 00 01 C0 00 00 03 F0 00 00 0F FC 00 00 3F
	B4A0 FF 00 00 FF FF C0 03 FF FF F0 0F FF FF FC 3F FF

         ................................
         ..............@.@@..............
         ............@@.@..@@............
         ..........@@..@@@@..@@..........
         ........@@..@@@@@@@@..@@........
         ......@@..@@@@@@@@@@@@..@@......
         ....@@..@@@@@@@@@@@@@@@@..@@....
         ..@@..@@@@@@@@@@@@@@@@@@@@..@@..
         .@..@@@@@@@@@@@@@@@@@@@@@@@@..@.
         ..@@..@@@@@@@@@@@@@@@@@@@@..@@..
         .@@.@@..@@@@@@@@@@@@@@@@..@@.@@.
         ..@.@.@@..@@@@@@@@@@@@..@@.@.@..
         .@..@.@@.@..@@@@@@@@..@@.@.@..@.
         .@@@..@.@.@@..@@@@..@@@@@@..@@@.
         ...@@@..@@@@.@....@.@@.@..@@@...
         .@@..@@@..@.@@.@.@@@.@..@@@...@.
         ..@@...@@@..@.@@.@.@..@@@..@.@..
         .@@.@.@..@@@..@.@@..@@@..@.@.@@.
         .@..@@.@@..@@@....@@@..@.@.@@.@.
         .@.@@.@@.@...@@@@@@..@@.@.@.@.@.
         ..@@..@@.@@.@......@..@.@@..@@..
         ....@@@..@@.@.@.@.@@.@@..@@@....
         ......@.@@.@@@.@@.@@..@@.@......
         ........@@.@.@.@@..@@.@@........
         ..........@@@..@@@..@@..........
         ............@.@@.@@@............
         ..............@@.@..............
         ................................

         @@@@@@@@@@@@@@.@..@@@@@@@@@@@@@@
         @@@@@@@@@@@@........@@@@@@@@@@@@
         @@@@@@@@@@............@@@@@@@@@@
         @@@@@@@@.......@.@......@@@@@@@@
         @@@@@@......@.@.@.@.......@@@@@@
         @@@@.......@.@.@.@.@.@......@@@@
         @@......@.@.@.@.@.@.@.@.......@@
         @......@.@.@.@.@.@.@.@.@.@.....@
         ....@.@.@.@.@.@.@.@.@.@.@.@.....
         @......@.@.@.@.@.@.@.@.@.@.....@
         ........@.@.@.@.@.@.@.@.........
         @..........@.@.@.@.@.@.........@
         .@..........@.@.@.@...........@.
         .@@@...........@.@..........@@@.
         @..@@@....................@@@..@
         .....@@@................@@@.....
         @......@@@............@@@......@
         .........@@@........@@@.........
         ...........@@@....@@@...........
         .............@@@@@@.............
         @..............................@
         @@............................@@
         @@@@........................@@@@
         @@@@@@....................@@@@@@
         @@@@@@@@................@@@@@@@@
         @@@@@@@@@@............@@@@@@@@@@
         @@@@@@@@@@@@........@@@@@@@@@@@@
         @@@@@@@@@@@@@@....@@@@@@@@@@@@@@

;; -----------------------------------------------------------------------------------------------------------
img_2x24.bin:
floor_tile_pattern0:				;; Bookworld floor
	B4B0 30 00 C4 00 2D 00 0B 40 02 D0 00 B8 00 23 00 0C
	B4C0 00 0C 00 23 00 B4 02 D0 0B 40 1D 00 C4 00 30 00
	B4D0 30 00 C4 00 2D 00 0B 40 02 D0 00 B8 00 23 00 0C

	;;Exemple : Bookworld floor tile
	;;  the above 48     |   flippled it
        bytes give this: |   gives:
		..MM............ ............MM..
		MM...M.......... ..........M...MM
		..M.MM.M........ ........M.MM.M..
		....M.MM.M...... ......M.MM.M....
		......M.MM.M.... ....M.MM.M......
		........M.MMM... ...MMM.M........
		..........M...MM MM...M..........
		............MM.. ..MM............
		............MM.. ..MM............  and we see the floor
		..........M...MM MM...M..........   pattern appear!
		........M.MM.M.. ..M.MM.M........
		......M.MM.M.... ....M.MM.M......
		....M.MM.M...... ......M.MM.M....
		...MMM.M........ ........M.MMM...
		MM...M.......... ..........M...MM
		..MM............ ............MM..
		..MM............ ............MM..
		MM...M.......... ..........M...MM
		..M.MM.M........ ........M.MM.M..
		....M.MM.M...... ......M.MM.M....
		......M.MM.M.... ....M.MM.M......
		........M.MMM... ...MMM.M........
		..........M...MM MM...M..........
		............MM.. ..MM............

floor_tile_pattern1:			;; Blacktooth / Prison / Main floor tile
	B4E0 E0 03 78 0C 1E 10 07 80 01 E0 08 78 30 1E C0 07
	B4F0 C0 07 30 1E 08 78 01 E0 07 80 1E 10 78 0C E0 03
	B500 E0 03 78 0C 1E 10 07 80 01 E0 08 78 30 1E C0 07

	;;Exemple : Blacktooth / Main floor tile
	;;  the above 48     |   flippled it
        bytes give this: |   gives:
		MMM...........MM  MMM...........MM
		.MMMM.......MM..  .MMMM.......MM..
		...MMMM....M....  ...MMMM....M....
		.....MMMM.......  .....MMMM.......
		.......MMMM.....  .......MMMM.....
		....M....MMMM...  ....M....MMMM...
		..MM.......MMMM.  ..MM.......MMMM.
		MM...........MMM  MM...........MMM
		MM...........MMM  MMM...........MM
		..MM.......MMMM.  .MMMM.......MM..
		....M....MMMM...  ...MMMM....M....
		.......MMMM.....  .....MMMM.......
		.....MMMM.......  .......MMMM.....
		...MMMM....M....  ....M....MMMM...
		.MMMM.......MM..  ..MM.......MMMM.
		MMM...........MM  MM...........MMM  and we see the floor
		MMM...........MM  MM...........MMM   pattern of room1
		.MMMM.......MM..  ..MM.......MMMM.   appear!
		...MMMM....M....  ....M....MMMM...
		.....MMMM.......  .......MMMM.....
		.......MMMM.....  .....MMMM.......
		....M....MMMM...  ...MMMM....M....
		..MM.......MMMM.  .MMMM.......MM..
		MM...........MMM  MMM...........MM

floor_tile_pattern2: 				Moonbase floor
	B510 07 FC 03 F3 01 CF F0 7F FE 0F F3 80 CF C0 3F E0
	B520 3F E0 CF C0 F3 80 FE 0F F0 7F 01 CF 03 F3 07 FC
	B530 07 FC 03 F3 01 CF F0 7F FE 0F F3 80 CF C0 3F E0

	     .....@@@@@@@@@..
         ......@@@@@@..@@
         .......@@@..@@@@
         @@@@.....@@@@@@@
         @@@@@@@.....@@@@
         @@@@..@@@.......
         @@..@@@@@@......
         ..@@@@@@@@@.....
         ..@@@@@@@@@.....
         @@..@@@@@@......
         @@@@..@@@.......
         @@@@@@@.....@@@@
         @@@@.....@@@@@@@
         .......@@@..@@@@
         ......@@@@@@..@@
         .....@@@@@@@@@..
         .....@@@@@@@@@..
         ......@@@@@@..@@
         .......@@@..@@@@
         @@@@.....@@@@@@@
         @@@@@@@.....@@@@
         @@@@..@@@.......
         @@..@@@@@@......
         ..@@@@@@@@@.....

floor_tile_pattern3: 			Penitentiary floor and Freedom (victory) room
	B540 07 00 03 80 01 C0 F0 78 1E 0F 03 80 01 C0 00 E0
	B550 00 E0 01 C0 03 80 1E 0F F0 78 01 C0 03 80 07 00
	B560 07 00 03 80 01 C0 F0 78 1E 0F 03 80 01 C0 00 E0

		 .....@@@........
         ......@@@.......
         .......@@@......
         @@@@.....@@@@...
         ...@@@@.....@@@@
         ......@@@.......
         .......@@@......
         ........@@@.....
         ........@@@.....
         .......@@@......
         ......@@@.......
         ...@@@@.....@@@@
         @@@@.....@@@@...
         .......@@@......
         ......@@@.......
         .....@@@........
         .....@@@........
         ......@@@.......
         .......@@@......
         @@@@.....@@@@...
         ...@@@@.....@@@@
         ......@@@.......
         .......@@@......
         ........@@@.....

floor_tile_pattern4: 				Egyptus floor
	B570 E0 70 78 1C 1E 07 07 81 81 E0 E0 78 38 1E 0E 07
	B580 0E 07 38 1E E0 78 81 E0 07 81 1E 07 78 1C E0 70
	B590 E0 70 78 1C 1E 07 07 81 81 E0 E0 78 38 1E 0E 07

		 @@@......@@@....
         .@@@@......@@@..
         ...@@@@......@@@
         .....@@@@......@
         @......@@@@.....
         @@@......@@@@...
         ..@@@......@@@@.
         ....@@@......@@@
         ....@@@......@@@
         ..@@@......@@@@.
         @@@......@@@@...
         @......@@@@.....
         .....@@@@......@
         ...@@@@......@@@
         .@@@@......@@@..
         @@@......@@@....
         @@@......@@@....
         .@@@@......@@@..
         ...@@@@......@@@
         .....@@@@......@
         @......@@@@.....
         @@@......@@@@...
         ..@@@......@@@@.
         ....@@@......@@@

floor_tile_pattern5: 				Market and Safari floor
	B5A0 00 00 41 02 00 00 00 00 00 81 20 08 02 00 00 00
	B5B0 10 00 00 00 00 10 42 00 00 02 00 00 00 10 48 00
	B5C0 00 00 04 01 00 00 00 80 20 00 00 08 00 00 21 04

		 ................
         .@.....@......@.
         ................
         ................
         ........@......@
         ..@.........@...
         ......@.........
         ................
         ...@............
         ................
         ...........@....
         .@....@.........
         ..............@.
         ................
         ...........@....
         .@..@...........
         ................
         .....@.........@
         ................
         ........@.......
         ..@.............
         ............@...
         ................
         ..@....@.....@..

floor_tile_pattern6: 				Danger floor
	B5D0 C4 00 3C 00 0E 00 03 10 00 F0 00 38 00 0C 00 03
	B5E0 00 23 00 3C 00 70 08 C0 0F 00 1C 00 30 00 C0 00
	B5F0 C4 00 3C 00 0E 00 03 10 00 F0 00 38 00 0C 00 03

		 @@...@..........
         ..@@@@..........
         ....@@@.........
         ......@@...@....
         ........@@@@....
         ..........@@@...
         ............@@..
         ..............@@
         ..........@...@@
         ..........@@@@..
         .........@@@....
         ....@...@@......
         ....@@@@........
         ...@@@..........
         ..@@............
         @@..............
         @@...@..........
         ..@@@@..........
         ....@@@.........
         ......@@...@....
         ........@@@@....
         ..........@@@...
         ............@@..
         ..............@@

floor_tile_pattern7: 				Empty tile
	B600 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	B610 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	B620 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

;; -----------------------------------------------------------------------------------------------------------
.Char_symbol_data: 			(Note: addr=AB58 before the block move, B630 after)
   B630 00 00 00 00 00 00 00 00		; charID #00 : Space
         ;       ................
         ;       ................
         ;       ................
         ;       ................
         ;       ................
         ;       ................
         ;       ................
         ;       ................
   B638 88 CC EE 77 77 EE CC 88		; charID #01 (char code #21) : menu selected left part
         ;       @@......@@......
         ;       @@@@....@@@@....
         ;       @@@@@@..@@@@@@..
         ;       ..@@@@@@..@@@@@@
         ;       ..@@@@@@..@@@@@@
         ;       @@@@@@..@@@@@@..
         ;       @@@@....@@@@....
         ;       @@......@@......
   B640 88 CC EE 77 77 EE CC 88		; charID #02 (char code #22) : menu selected right part
         ;       @@......@@......
         ;       @@@@....@@@@....
         ;       @@@@@@..@@@@@@..
         ;       ..@@@@@@..@@@@@@
         ;       ..@@@@@@..@@@@@@
         ;       @@@@@@..@@@@@@..
         ;       @@@@....@@@@....
         ;       @@......@@......
   B648 4E 67 73 01 4E 67 73 01		; charID #03 (char code #23) : menu unselected left part
         ;       ..@@....@@@@@@..
         ;       ..@@@@....@@@@@@
         ;       ..@@@@@@....@@@@
         ;       ..............@@
         ;       ..@@....@@@@@@..
         ;       ..@@@@....@@@@@@
         ;       ..@@@@@@....@@@@
         ;       ..............@@
   B650 72 E6 CE 80 72 E6 CE 80		; charID #04 (char code #24) : menu unselected right part
         ;       ..@@@@@@....@@..
         ;       @@@@@@....@@@@..
         ;       @@@@....@@@@@@..
         ;       @@..............
         ;       ..@@@@@@....@@..
         ;       @@@@@@....@@@@..
         ;       @@@@....@@@@@@..
         ;       @@..............
   B658 C0 70 3C 18 3C 0E 03 00		; charID #05 (char code #25) : speed lightning
         ;       @@@@............
         ;       ..@@@@@@........
         ;       ....@@@@@@@@....
         ;       ......@@@@......
         ;       ....@@@@@@@@....
         ;       ........@@@@@@..
         ;       ............@@@@
         ;       ................
   B660 06 03 3B 66 3D 42 3C 00		; charID #06 (char code #26) : spring
         ;       ..........@@@@..
         ;       ............@@@@
         ;       ....@@@@@@..@@@@
         ;       ..@@@@....@@@@..
         ;       ....@@@@@@@@..@@
         ;       ..@@........@@..
         ;       ....@@@@@@@@....
         ;       ................
   B668 FE EE C6 6C 6C 38 10 00		; charID #07 (char code #27) : shield
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@......@@@@..
         ;       ..@@@@..@@@@....
         ;       ..@@@@..@@@@....
         ;       ....@@@@@@......
         ;       ......@@........
         ;       ................
   B670 00 00 00 00 38 38 18 30		; charID #08 : comma
         ;       ................
         ;       ................
         ;       ................
         ;       ................
         ;       ....@@@@@@......
         ;       ....@@@@@@......
         ;       ......@@@@......
         ;       ....@@@@........
   B678 00 00 7E 7E 7E 7E 00 00		; charID #09 : Big block
         ;       ................
         ;       ................
         ;       ..@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@@@..
         ;       ................
         ;       ................
   B680 00 00 00 00 00 38 38 38		; charID #0A : Small Block
         ;       ................
         ;       ................
         ;       ................
         ;       ................
         ;       ................
         ;       ....@@@@@@......
         ;       ....@@@@@@......
         ;       ....@@@@@@......
   B688 3E 3E 7E 7E FC FC F8 F8		; charID #0B : "/"
         ;       ....@@@@@@@@@@..
         ;       ....@@@@@@@@@@..
         ;       ..@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
   B690 7C FE FE EE EE FE FE 7C		; charID #0C : "0"
         ;       ..@@@@@@@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@....
   B698 7C FC 7C 7C 7C FE FE FE		; charID #0D : "1"
         ;       ..@@@@@@@@@@....
         ;       @@@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B6A0 FE FE BE 7C F8 FE FE FE		; charID #0E : "2"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@..@@@@@@@@@@..
         ;       ..@@@@@@@@@@....
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B6A8 FE FE 3E FE FE 3E FE FE		; charID #0F : "3"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ....@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ....@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B6B0 E0 EC EC EC FE FE FE 0C		; charID #10 : "4"
         ;       @@@@@@..........
         ;       @@@@@@..@@@@....
         ;       @@@@@@..@@@@....
         ;       @@@@@@..@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ........@@@@....
   B6B8 FE FE F8 FE FE 1E FE FC		; charID #11 : "5"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ......@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@....
   B6C0 FE FE F8 FE FE EE FE FE		; charID #12 : "6"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B6C8 FE FE 1C 3C 78 78 F0 F0		; charID #13 : "7"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ......@@@@@@....
         ;       ....@@@@@@@@....
         ;       ..@@@@@@@@......
         ;       ..@@@@@@@@......
         ;       @@@@@@@@........
         ;       @@@@@@@@........
   B6D0 FE FE EE 7C FE EE FE FE		; charID #14 : "8"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       ..@@@@@@@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B6D8 FE FE EE FE FE 1E FE FE		; charID #15 : "9"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ......@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B6E0 00 38 38 38 00 38 38 38		; charID #16 : ":"
         ;       ................
         ;       ....@@@@@@......
         ;       ....@@@@@@......
         ;       ....@@@@@@......
         ;       ................
         ;       ....@@@@@@......
         ;       ....@@@@@@......
         ;       ....@@@@@@......
   B6E8 38 38 38 00 38 38 18 30		; charID #17 : ";"
         ;       ....@@@@@@......
         ;       ....@@@@@@......
         ;       ....@@@@@@......
         ;       ................
         ;       ....@@@@@@......
         ;       ....@@@@@@......
         ;       ......@@@@......
         ;       ....@@@@........
   B6F0 00 FE C6 BA AA BE C0 FC		; charID #18 : "@"
         ;       ................
         ;       @@@@@@@@@@@@@@..
         ;       @@@@......@@@@..
         ;       @@..@@@@@@..@@..
         ;       @@..@@..@@..@@..
         ;       @@..@@@@@@@@@@..
         ;       @@@@............
         ;       @@@@@@@@@@@@....
   B6F8 FE FE EE FE FE FE EE EE		; charID #19 : "A"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@..@@@@@@..
   B700 FE F6 FE FC FE F6 F6 FE		; charID #1A : "B"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@..@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@..@@@@..
         ;       @@@@@@@@..@@@@..
         ;       @@@@@@@@@@@@@@..
   B708 FE FE FE F8 F8 FE FE FE		; charID #1B : "C"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B710 FC FE FE EE EE FE FE FC		; charID #1C : "D"
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@....
   B718 FE FE F8 FC FC F8 FE FE		; charID #1D : "E"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B720 FE FE F8 FC FC F8 F8 F8		; charID #1E : "F"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
   B728 FE FE FE F0 F6 FE FE FE		; charID #1F : "G"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@........
         ;       @@@@@@@@..@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B730 EE EE FE FE FE FE EE EE		; charID #20 : "H"
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@..@@@@@@..
   B738 FE FE 7C 7C 7C 7C FE FE		; charID #21 : "I"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B740 1E 1E 1E 1E DE DE FE FE		; charID #22 : "J"
         ;       ......@@@@@@@@..
         ;       ......@@@@@@@@..
         ;       ......@@@@@@@@..
         ;       ......@@@@@@@@..
         ;       @@@@..@@@@@@@@..
         ;       @@@@..@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B748 E6 EE FE FC FC FE EE E6		; charID #23 : "K"
         ;       @@@@@@....@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@....@@@@..
   B750 F8 F8 F8 F8 F8 FE FE FE		; charID #24 : "L"
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B758 EE FE FE FE FE FE D6 C6		; charID #25 : "M"
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@..@@..@@@@..
         ;       @@@@......@@@@..
   B760 F6 F6 FE FE FE FE DE DE		; charID #26 : "N"
         ;       @@@@@@@@..@@@@..
         ;       @@@@@@@@..@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@..@@@@@@@@..
         ;       @@@@..@@@@@@@@..
   B768 FE FE FE EE EE FE FE FE		; charID #27 : "O"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B770 FE FE EE FE FE F8 F8 F8		; charID #28 : "P"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
   B778 FC FC FC EC EC FC FE FE		; charID #29 : "Q"
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@@@....
         ;       @@@@@@..@@@@....
         ;       @@@@@@..@@@@....
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B780 FE FE EE FE FC FE FE EE		; charID #2A : "R"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
   B788 FE FE F8 FE FE 3E FE FE		; charID #2B : "S"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ....@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B790 FE FE FE 7C 7C 7C 7C 7C		; charID #2C : "T"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
   B798 EE EE EE EE FE FE FE FE		; charID #2D : "U"
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B7A0 EE EE EE EE FE FE 7C 7C		; charID #2E : "V"
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
   B7A8 C6 D6 FE FE FE FE FE EE		; charID #2F : "W"
         ;       @@@@......@@@@..
         ;       @@@@..@@..@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
   B7B0 EE FE FE 7C 7C FE FE EE		; charID #30 : "X"
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@..@@@@@@..
   B7B8 EE EE FE FE 7C 7C 7C 7C		; charID #31 : "Y"
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@..@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
   B7C0 FE FE FE 3C 78 FE FE FE		; charID #32 : "Z"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ....@@@@@@@@....
         ;       ..@@@@@@@@......
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B7C8 FE FE F8 F8 F8 F8 FE FE		; charID #33 : "["
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B7D0 F8 F8 FC FC 7E 7E 3E 3E		; charID #34 : "\"
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@@@....
         ;       ..@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@@@..
         ;       ....@@@@@@@@@@..
         ;       ....@@@@@@@@@@..
   B7D8 FE FE 3E 3E 3E 3E FE FE		; charID #35 : "]"
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ....@@@@@@@@@@..
         ;       ....@@@@@@@@@@..
         ;       ....@@@@@@@@@@..
         ;       ....@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
   B7E0 10 38 7C FE 7C 7C 7C 7C		; charID #36 : Up arrow
         ;       ......@@........
         ;       ....@@@@@@......
         ;       ..@@@@@@@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
   B7E8 7C 7C 7C 7C FE 7C 38 10		; charID #37 : Down arrow
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       ..@@@@@@@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@....
         ;       ....@@@@@@......
         ;       ......@@........
   B7F0 00 10 F8 FC FE FC F8 10		; charID #38 : Right arrow
         ;       ................
         ;       ......@@........
         ;       @@@@@@@@@@......
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@....
         ;       @@@@@@@@@@......
         ;       ......@@........
   B7F8 00 10 3E 7E FE 7E 3E 10		; charID #39 : Left arrow
         ;       ................
         ;       ......@@........
         ;       ....@@@@@@@@@@..
         ;       ..@@@@@@@@@@@@..
         ;       @@@@@@@@@@@@@@..
         ;       ..@@@@@@@@@@@@..
         ;       ....@@@@@@@@@@..
         ;       ......@@........

;; -----------------------------------------------------------------------------------------------------------
;; These are the pillars sprites that may go under some of the doors (type 4)
img_pillar_top: 			;; 4x9 *2  Pillar Top
   B800 00 00 00 03 00 00 00 03 00 00 00 3C 00 00 00 CF
   B810 00 01 00 F3 00 0E 00 7C 00 3F 00 9F 00 FF 00 3C
   B820 00 FC 03 F3
   B824 00 F3 0F CF 00 CF 3E 3E 00 3C F8 F8 03 F3 E4 E0
   B834 0F CF 9C 80 3E 3E 78 00 79 78 F8 00 67 60 F0 00
   B844 07 00 C0 08
   ;; (shown as "msk1+msk2 img1+img2 : result" so it is easier to see the result)

         ................ ..............@@ : ..............cc
         ................ ..............@@ : ..............cc
         ................ ..........@@@@.. : ..........cccc..
         ................ ........@@..@@@@ : ........cc..cccc
         ................ .......@@@@@..@@ : .......ccccc..cc
         ................ ....@@@..@@@@@.. : ....ccc..ccccc..
         ................ ..@@@@@@@..@@@@@ : ..ccccccc..ccccc
         ................ @@@@@@@@..@@@@.. : cccccccc..cccc..
         ..............@@ @@@@@@..@@@@..@@ : cccccc..cccc..**
         ............@@@@ @@@@..@@@@..@@@@ : cccc..cccc..****
         ..........@@@@@. @@..@@@@..@@@@@. : cc..cccc..*****.
         ........@@@@@... ..@@@@..@@@@@... : ..cccc..*****...
         ......@@@@@..@.. @@@@..@@@@@..... : cccc..*****..o..
         ....@@@@@..@@@.. @@..@@@@@....... : cc..*****..ooo..
         ..@@@@@..@@@@... ..@@@@@......... : ..*****..oooo...
         .@@@@..@@@@@@... .@@@@........... : .****..oooooo...
         .@@..@@@@@@@.... .@@............. : .**..ooooooo....
         .....@@@@@...... ............@... : .....ooooo..c...

img_pillar_mid:				;; 4x6 *2 Pillar Mid (img1+msk1+img2+msk2 interlaced)
   B848 00 78 00 3C 00 1F 00 F0 20 07 08 C0 38 00 38 00
   B858 5F 40 F4 04 4C 40 64 04
   B860 73 73 9C 9C 1E 1E F0 F0 23 03 88 80 3C 00 78 00
   B870 1F 00 F0 00 07 20 C0 08
   ;; (shown as "msk1+msk2 img1+img2 : result" so it is easier to see the result)

         ................ .@@@@.....@@@@.. : .cccc.....cccc..
         ................ ...@@@@@@@@@.... : ...ccccccccc....
         ..@.........@... .....@@@@@...... : ..o..ccccc..o...
         ..@@@.....@@@... ................ : ..ooo.....ooo...
         .@.@@@@@@@@@.@.. .@...........@.. : .*.ooooooooo.*..
         .@..@@...@@..@.. .@...........@.. : .*..oo...oo..*..
         .@@@..@@@..@@@.. .@@@..@@@..@@@.. : .***..***..***..
         ...@@@@.@@@@.... ...@@@@.@@@@.... : ...****.****....
         ..@...@@@...@... ......@@@....... : ..o...***...o...
         ..@@@@...@@@@... ................ : ..oooo...oooo...
         ...@@@@@@@@@.... ................ : ...ooooooooo....
         .....@@@@@...... ..@.........@... : ..c..ooooo..c...
^
image_pillar_btm:			;; 4x4 *2 Pillar Bottom
   B878 00 78 00 3C 00 7F 00 FC 00 3F 00 F8 00 0F 00 E0
   ;;  B888-B897 : This is missing from the DSK file I used in the file HEADOVER.III !
   ;;  Thus I can see a glitch at the bottom of the pillars.
   ;;  In another DSK version we see it should be 16 "00" bytes and indeed it gets rid of the glich.
   B888 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   ;; (shown as "msk1+msk2 img1+img2 : result" so it is easier to see the result)

         ................ .@@@@.....@@@@.. : .cccc.....cccc..
         ................ .@@@@@@@@@@@@@.. : .ccccccccccccc..
         ................ ..@@@@@@@@@@@... : ..ccccccccccc...
         ................ ....@@@@@@@..... : ....ccccccc.....
         ................ ................ : ................
         ................ ................ : ................
         ................ ................ : ................
         ................ ................ : ................

;; # new end position B887 from old ADAF (addr before it was moved) # fin de HEADOVER.III
;; end of "This block was moved from 6600-ADBF to 70D8-B897  (+0AD8)"

;; -----------------------------------------------------------------------------------------------------------
PillarBuf:				;; #0128 (296) bytes
	;; (top: 4*4 + mid: 4*6 + btm: 4*9) * 2 ("img+mask") = 296 bytes
	B898-B9BF

DoorwayBuf:				;; #0150 (2 * 168 bytes)
DoorwayImgBuf:			;; #00A8 (168) bytes (3*56 (img L+R))
	B9C0-BA67

DoorwayMaskBuf:			;; #00A8 (168) bytes (3*56 (mask L+R))
	BA68-BBB7

;; -----------------------------------------------------------------------------------------------------------
;; TODO : A buffer that is used for saving several things
;; could be  4 + #1D + #19 + #3F0 + (2*#12) bytes long
;; TODO: Saves the other character's (the one not being played) info
;;   first word : Room Id
Other_Character_state:
	; 4 bytes
	BB10 DATABYTE ??														; Saved Room Id
	BB11 DATABYTE ??														; Saved Phase
	BB12 DATABYTE ?? 														; Saved Last direction
	BB13 DATABYTE ??														; Saved Curr direction
	; #1D bytes (29)
	BB14 DATABYTE ??														; Saved ObjListIdx
	BB15 DATAWORD ?? ??														; Saved Object_Destination
	BB17 DATAWORD ?? ??														; Saved ObjListAPtr
	BB19 DATAWORD ?? ??														; Saved ObjListBPtr
	BB1B DATABYTE ?? x 20													; Saved ObjectLists
	BB2F DATAWORD ?? ??														; Saved Saved_Object_Destination
	; #19 bytes (25)
	BB31 DATABYTE ??														; Saved ???
	BB32 DATABYTE ?? ?? ?? 													; Saved (fire) object EntryPosn
	BB35 DATABYTE ??  					        							; Saved ???
	BB36 DATAWORD ?? ??       												; Saved Carrying
	BB38 DATABYTE ?? x #12													; Saved #12 bytes FiredObj_variables
	; #3F0 bytes
	BB4A DATABYTE ?? x #03F0												; Saved Objects buffer
	; #12 bytes
	BF3A DATABYTE ?? x #12													; Saved Character variables
	; #12 bytes
	BF4C DATABYTE ?? x #12													; Saved Other Character variables

;; -----------------------------------------------------------------------------------------------------------
	;
	BF5E-???
